"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@internationalized";
exports.ids = ["vendor-chunks/@internationalized"];
exports.modules = {

/***/ "(ssr)/./node_modules/@internationalized/date/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@internationalized/date/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BuddhistCalendar: () => (/* binding */ $8d73d47422ca7302$export$42d20a78301dee44),\n/* harmony export */   CalendarDate: () => (/* binding */ $35ea8db9cb2ccb90$export$99faa760c7908e4f),\n/* harmony export */   CalendarDateTime: () => (/* binding */ $35ea8db9cb2ccb90$export$ca871e8dbb80966f),\n/* harmony export */   CopticCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1),\n/* harmony export */   DateFormatter: () => (/* binding */ $fb18d541ea1ad717$export$ad991b66133851cf),\n/* harmony export */   EthiopicAmeteAlemCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$d72e0c37005a4914),\n/* harmony export */   EthiopicCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$26ba6eab5e20cd7d),\n/* harmony export */   GregorianCalendar: () => (/* binding */ $3b62074eb05584b2$export$80ee6245ec4f29ec),\n/* harmony export */   HebrewCalendar: () => (/* binding */ $7c5f6fbf42389787$export$ca405048b8fb5af),\n/* harmony export */   IndianCalendar: () => (/* binding */ $82c358003bdda0a8$export$39f31c639fa15726),\n/* harmony export */   IslamicCivilCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$2066795aadd37bfc),\n/* harmony export */   IslamicTabularCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$37f0887f2f9d22f7),\n/* harmony export */   IslamicUmalquraCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$5baab4758c231076),\n/* harmony export */   JapaneseCalendar: () => (/* binding */ $62225008020f0a13$export$b746ab2b60cdffbf),\n/* harmony export */   PersianCalendar: () => (/* binding */ $f3ed2e4472ae7e25$export$37fccdbfd14c5939),\n/* harmony export */   TaiwanCalendar: () => (/* binding */ $5f31bd6f0c8940b2$export$65e01080afcb0799),\n/* harmony export */   Time: () => (/* binding */ $35ea8db9cb2ccb90$export$680ea196effce5f),\n/* harmony export */   ZonedDateTime: () => (/* binding */ $35ea8db9cb2ccb90$export$d3b7288e7994edea),\n/* harmony export */   createCalendar: () => (/* binding */ $64244302c3013299$export$dd0bbc9b26defe37),\n/* harmony export */   endOfMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a2258d9c4118825c),\n/* harmony export */   endOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$ef8b6d9133084f4e),\n/* harmony export */   endOfYear: () => (/* binding */ $14e0f24ef4ac5c92$export$8b7aa55c66d5569e),\n/* harmony export */   fromAbsolute: () => (/* binding */ $11d87f3f76e88657$export$1b96692a1ba042ac),\n/* harmony export */   fromDate: () => (/* binding */ $11d87f3f76e88657$export$e57ff100d91bd4b9),\n/* harmony export */   getDayOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$2061056d06d7cdf7),\n/* harmony export */   getHoursInDay: () => (/* binding */ $14e0f24ef4ac5c92$export$126c91c941de7e),\n/* harmony export */   getLocalTimeZone: () => (/* binding */ $14e0f24ef4ac5c92$export$aa8b41735afcabd2),\n/* harmony export */   getMinimumDayInMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$b2f4953d301981d5),\n/* harmony export */   getMinimumMonthInYear: () => (/* binding */ $14e0f24ef4ac5c92$export$5412ac11713b72ad),\n/* harmony export */   getWeeksInMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$ccc1b2479e7dd654),\n/* harmony export */   isEqualDay: () => (/* binding */ $14e0f24ef4ac5c92$export$91b62ebf2ba703ee),\n/* harmony export */   isEqualMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2),\n/* harmony export */   isEqualYear: () => (/* binding */ $14e0f24ef4ac5c92$export$ea840f5a6dda8147),\n/* harmony export */   isSameDay: () => (/* binding */ $14e0f24ef4ac5c92$export$ea39ec197993aef0),\n/* harmony export */   isSameMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a18c89cbd24170ff),\n/* harmony export */   isSameYear: () => (/* binding */ $14e0f24ef4ac5c92$export$5841f9eb9773f25f),\n/* harmony export */   isToday: () => (/* binding */ $14e0f24ef4ac5c92$export$629b0a497aa65267),\n/* harmony export */   isWeekday: () => (/* binding */ $14e0f24ef4ac5c92$export$ee9d87258e1d19ed),\n/* harmony export */   isWeekend: () => (/* binding */ $14e0f24ef4ac5c92$export$618d60ea299da42),\n/* harmony export */   maxDate: () => (/* binding */ $14e0f24ef4ac5c92$export$a75f2bff57811055),\n/* harmony export */   minDate: () => (/* binding */ $14e0f24ef4ac5c92$export$5c333a116e949cdd),\n/* harmony export */   now: () => (/* binding */ $14e0f24ef4ac5c92$export$461939dd4422153),\n/* harmony export */   parseAbsolute: () => (/* binding */ $fae977aafc393c5c$export$5adfdab05168c219),\n/* harmony export */   parseAbsoluteToLocal: () => (/* binding */ $fae977aafc393c5c$export$8e384432362ed0f0),\n/* harmony export */   parseDate: () => (/* binding */ $fae977aafc393c5c$export$6b862160d295c8e),\n/* harmony export */   parseDateTime: () => (/* binding */ $fae977aafc393c5c$export$588937bcd60ade55),\n/* harmony export */   parseDuration: () => (/* binding */ $fae977aafc393c5c$export$ecae829bb3747ea6),\n/* harmony export */   parseTime: () => (/* binding */ $fae977aafc393c5c$export$c9698ec7f05a07e1),\n/* harmony export */   parseZonedDateTime: () => (/* binding */ $fae977aafc393c5c$export$fd7893f06e92a6a4),\n/* harmony export */   startOfMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a5a3b454ada2268e),\n/* harmony export */   startOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$42c81a444fbfb5d4),\n/* harmony export */   startOfYear: () => (/* binding */ $14e0f24ef4ac5c92$export$f91e89d3d0406102),\n/* harmony export */   toCalendar: () => (/* binding */ $11d87f3f76e88657$export$b4a036af3fc0b032),\n/* harmony export */   toCalendarDate: () => (/* binding */ $11d87f3f76e88657$export$93522d1a439f3617),\n/* harmony export */   toCalendarDateTime: () => (/* binding */ $11d87f3f76e88657$export$b21e0b124e224484),\n/* harmony export */   toLocalTimeZone: () => (/* binding */ $11d87f3f76e88657$export$d9b67bc93c097491),\n/* harmony export */   toTime: () => (/* binding */ $11d87f3f76e88657$export$d33f79e3ffc3dc83),\n/* harmony export */   toTimeZone: () => (/* binding */ $11d87f3f76e88657$export$538b00033cc11c75),\n/* harmony export */   toZoned: () => (/* binding */ $11d87f3f76e88657$export$84c95a83c799e074),\n/* harmony export */   today: () => (/* binding */ $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\nfunction $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {\r\n    return amount - numerator * Math.floor(amount / numerator);\r\n}\r\nfunction $2b4dce13dd5a17fa$export$784d13d8ee351f07(date) {\r\n    if (date.era) return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.calendar, date.era, date.year, date.month, date.day);\r\n    else return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.calendar, date.year, date.month, date.day);\r\n}\r\nfunction $2b4dce13dd5a17fa$export$27fa0172ae2644b3(date) {\r\n    if (date.era) return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\r\n    else return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.year, date.month, date.day, date.hour, date.minute, date.second);\r\n}\r\n\r\n\r\nconst $3b62074eb05584b2$var$EPOCH = 1721426; // 001/01/03 Julian C.E.\r\nfunction $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {\r\n    year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);\r\n    let y1 = year - 1;\r\n    let monthOffset = -2;\r\n    if (month <= 2) monthOffset = 0;\r\n    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;\r\n    return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);\r\n}\r\nfunction $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {\r\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n}\r\nfunction $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {\r\n    return era === \"BC\" ? 1 - year : year;\r\n}\r\nfunction $3b62074eb05584b2$export$4475b7e617eb123c(year) {\r\n    let era = \"AD\";\r\n    if (year <= 0) {\r\n        era = \"BC\";\r\n        year = 1 - year;\r\n    }\r\n    return [\r\n        era,\r\n        year\r\n    ];\r\n}\r\nconst $3b62074eb05584b2$var$daysInMonth = {\r\n    standard: [\r\n        31,\r\n        28,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31\r\n    ],\r\n    leapyear: [\r\n        31,\r\n        29,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31\r\n    ]\r\n};\r\nclass $3b62074eb05584b2$export$80ee6245ec4f29ec {\r\n    fromJulianDay(jd) {\r\n        let jd0 = jd;\r\n        let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;\r\n        let quadricent = Math.floor(depoch / 146097);\r\n        let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);\r\n        let cent = Math.floor(dqc / 36524);\r\n        let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);\r\n        let quad = Math.floor(dcent / 1461);\r\n        let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);\r\n        let yindex = Math.floor(dquad / 365);\r\n        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);\r\n        let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);\r\n        let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);\r\n        let leapAdj = 2;\r\n        if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;\r\n        else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;\r\n        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);\r\n        let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);\r\n    }\r\n    toJulianDay(date) {\r\n        return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);\r\n    }\r\n    getDaysInMonth(date) {\r\n        return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? \"leapyear\" : \"standard\"][date.month - 1];\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    getMonthsInYear(date) {\r\n        return 12;\r\n    }\r\n    getDaysInYear(date) {\r\n        return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    getYearsInEra(date) {\r\n        return 9999;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"BC\",\r\n            \"AD\"\r\n        ];\r\n    }\r\n    isInverseEra(date) {\r\n        return date.era === \"BC\";\r\n    }\r\n    balanceDate(date) {\r\n        if (date.year <= 0) {\r\n            date.era = date.era === \"BC\" ? \"AD\" : \"BC\";\r\n            date.year = 1 - date.year;\r\n        }\r\n    }\r\n    constructor(){\r\n        this.identifier = \"gregory\";\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json\r\n// Locales starting on Sunday have been removed for compression.\r\nconst $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {\r\n    \"001\": 1,\r\n    AD: 1,\r\n    AE: 6,\r\n    AF: 6,\r\n    AI: 1,\r\n    AL: 1,\r\n    AM: 1,\r\n    AN: 1,\r\n    AR: 1,\r\n    AT: 1,\r\n    AU: 1,\r\n    AX: 1,\r\n    AZ: 1,\r\n    BA: 1,\r\n    BE: 1,\r\n    BG: 1,\r\n    BH: 6,\r\n    BM: 1,\r\n    BN: 1,\r\n    BY: 1,\r\n    CH: 1,\r\n    CL: 1,\r\n    CM: 1,\r\n    CN: 1,\r\n    CR: 1,\r\n    CY: 1,\r\n    CZ: 1,\r\n    DE: 1,\r\n    DJ: 6,\r\n    DK: 1,\r\n    DZ: 6,\r\n    EC: 1,\r\n    EE: 1,\r\n    EG: 6,\r\n    ES: 1,\r\n    FI: 1,\r\n    FJ: 1,\r\n    FO: 1,\r\n    FR: 1,\r\n    GB: 1,\r\n    GE: 1,\r\n    GF: 1,\r\n    GP: 1,\r\n    GR: 1,\r\n    HR: 1,\r\n    HU: 1,\r\n    IE: 1,\r\n    IQ: 6,\r\n    IR: 6,\r\n    IS: 1,\r\n    IT: 1,\r\n    JO: 6,\r\n    KG: 1,\r\n    KW: 6,\r\n    KZ: 1,\r\n    LB: 1,\r\n    LI: 1,\r\n    LK: 1,\r\n    LT: 1,\r\n    LU: 1,\r\n    LV: 1,\r\n    LY: 6,\r\n    MC: 1,\r\n    MD: 1,\r\n    ME: 1,\r\n    MK: 1,\r\n    MN: 1,\r\n    MQ: 1,\r\n    MV: 5,\r\n    MY: 1,\r\n    NL: 1,\r\n    NO: 1,\r\n    NZ: 1,\r\n    OM: 6,\r\n    PL: 1,\r\n    QA: 6,\r\n    RE: 1,\r\n    RO: 1,\r\n    RS: 1,\r\n    RU: 1,\r\n    SD: 6,\r\n    SE: 1,\r\n    SI: 1,\r\n    SK: 1,\r\n    SM: 1,\r\n    SY: 6,\r\n    TJ: 1,\r\n    TM: 1,\r\n    TR: 1,\r\n    UA: 1,\r\n    UY: 1,\r\n    UZ: 1,\r\n    VA: 1,\r\n    VN: 1,\r\n    XK: 1\r\n};\r\n\r\n\r\nfunction $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {\r\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\r\n    return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {\r\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\r\n    // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.\r\n    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);\r\n    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);\r\n    return a.era === b.era && a.year === b.year && a.month === b.month;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$5841f9eb9773f25f(a, b) {\r\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\r\n    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);\r\n    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);\r\n    return a.era === b.era && a.year === b.year;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {\r\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {\r\n    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);\r\n    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);\r\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$ea840f5a6dda8147(a, b) {\r\n    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);\r\n    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);\r\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {\r\n    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));\r\n}\r\nfunction $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale) {\r\n    let julian = date.calendar.toJulianDay(date);\r\n    // If julian is negative, then julian % 7 will be negative, so we adjust\r\n    // accordingly.  Julian day 0 is Monday.\r\n    let dayOfWeek = Math.ceil(julian + 1 - $14e0f24ef4ac5c92$var$getWeekStart(locale)) % 7;\r\n    if (dayOfWeek < 0) dayOfWeek += 7;\r\n    return dayOfWeek;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {\r\n    return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);\r\n}\r\nfunction $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {\r\n    return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));\r\n}\r\nfunction $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {\r\n    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);\r\n}\r\nfunction $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {\r\n    return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);\r\n}\r\nfunction $14e0f24ef4ac5c92$var$timeToMs(a) {\r\n    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$126c91c941de7e(a, timeZone) {\r\n    let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(a, timeZone);\r\n    let tomorrow = a.add({\r\n        days: 1\r\n    });\r\n    let tomorrowMs = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(tomorrow, timeZone);\r\n    return (tomorrowMs - ms) / 3600000;\r\n}\r\nlet $14e0f24ef4ac5c92$var$localTimeZone = null;\r\nfunction $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {\r\n    // TODO: invalidate this somehow?\r\n    if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n    return $14e0f24ef4ac5c92$var$localTimeZone;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {\r\n    // Use `subtract` instead of `set` so we don't get constrained in an era.\r\n    return date.subtract({\r\n        days: date.day - 1\r\n    });\r\n}\r\nfunction $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {\r\n    return date.add({\r\n        days: date.calendar.getDaysInMonth(date) - date.day\r\n    });\r\n}\r\nfunction $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {\r\n    return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({\r\n        months: date.month - 1\r\n    }));\r\n}\r\nfunction $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {\r\n    return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({\r\n        months: date.calendar.getMonthsInYear(date) - date.month\r\n    }));\r\n}\r\nfunction $14e0f24ef4ac5c92$export$5412ac11713b72ad(date) {\r\n    if (date.calendar.getMinimumMonthInYear) return date.calendar.getMinimumMonthInYear(date);\r\n    return 1;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$b2f4953d301981d5(date) {\r\n    if (date.calendar.getMinimumDayInMonth) return date.calendar.getMinimumDayInMonth(date);\r\n    return 1;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale) {\r\n    let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);\r\n    return date.subtract({\r\n        days: dayOfWeek\r\n    });\r\n}\r\nfunction $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale) {\r\n    return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale).add({\r\n        days: 6\r\n    });\r\n}\r\nconst $14e0f24ef4ac5c92$var$cachedRegions = new Map();\r\nfunction $14e0f24ef4ac5c92$var$getRegion(locale) {\r\n    // If the Intl.Locale API is available, use it to get the region for the locale.\r\n    // @ts-ignore\r\n    if (Intl.Locale) {\r\n        // Constructing an Intl.Locale is expensive, so cache the result.\r\n        let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);\r\n        if (!region) {\r\n            // @ts-ignore\r\n            region = new Intl.Locale(locale).maximize().region;\r\n            if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);\r\n        }\r\n        return region;\r\n    }\r\n    // If not, just try splitting the string.\r\n    // If the second part of the locale string is 'u',\r\n    // then this is a unicode extension, so ignore it.\r\n    // Otherwise, it should be the region.\r\n    let part = locale.split(\"-\")[1];\r\n    return part === \"u\" ? undefined : part;\r\n}\r\nfunction $14e0f24ef4ac5c92$var$getWeekStart(locale) {\r\n    // TODO: use Intl.Locale for this once browsers support the weekInfo property\r\n    // https://github.com/tc39/proposal-intl-locale-info\r\n    let region = $14e0f24ef4ac5c92$var$getRegion(locale);\r\n    return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale) {\r\n    let days = date.calendar.getDaysInMonth(date);\r\n    return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale) + days) / 7);\r\n}\r\nfunction $14e0f24ef4ac5c92$export$5c333a116e949cdd(a, b) {\r\n    if (a && b) return a.compare(b) <= 0 ? a : b;\r\n    return a || b;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$a75f2bff57811055(a, b) {\r\n    if (a && b) return a.compare(b) >= 0 ? a : b;\r\n    return a || b;\r\n}\r\nconst $14e0f24ef4ac5c92$var$WEEKEND_DATA = {\r\n    AF: [\r\n        4,\r\n        5\r\n    ],\r\n    AE: [\r\n        5,\r\n        6\r\n    ],\r\n    BH: [\r\n        5,\r\n        6\r\n    ],\r\n    DZ: [\r\n        5,\r\n        6\r\n    ],\r\n    EG: [\r\n        5,\r\n        6\r\n    ],\r\n    IL: [\r\n        5,\r\n        6\r\n    ],\r\n    IQ: [\r\n        5,\r\n        6\r\n    ],\r\n    IR: [\r\n        5,\r\n        5\r\n    ],\r\n    JO: [\r\n        5,\r\n        6\r\n    ],\r\n    KW: [\r\n        5,\r\n        6\r\n    ],\r\n    LY: [\r\n        5,\r\n        6\r\n    ],\r\n    OM: [\r\n        5,\r\n        6\r\n    ],\r\n    QA: [\r\n        5,\r\n        6\r\n    ],\r\n    SA: [\r\n        5,\r\n        6\r\n    ],\r\n    SD: [\r\n        5,\r\n        6\r\n    ],\r\n    SY: [\r\n        5,\r\n        6\r\n    ],\r\n    YE: [\r\n        5,\r\n        6\r\n    ]\r\n};\r\nfunction $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {\r\n    let julian = date.calendar.toJulianDay(date);\r\n    // If julian is negative, then julian % 7 will be negative, so we adjust\r\n    // accordingly.  Julian day 0 is Monday.\r\n    let dayOfWeek = Math.ceil(julian + 1) % 7;\r\n    if (dayOfWeek < 0) dayOfWeek += 7;\r\n    let region = $14e0f24ef4ac5c92$var$getRegion(locale);\r\n    // Use Intl.Locale for this once weekInfo is supported.\r\n    // https://github.com/tc39/proposal-intl-locale-info\r\n    let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [\r\n        6,\r\n        0\r\n    ];\r\n    return dayOfWeek === start || dayOfWeek === end;\r\n}\r\nfunction $14e0f24ef4ac5c92$export$ee9d87258e1d19ed(date, locale) {\r\n    return !$14e0f24ef4ac5c92$export$618d60ea299da42(date, locale);\r\n}\r\n\r\n\r\nfunction $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {\r\n    date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\r\n    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);\r\n    return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\r\n}\r\nfunction $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {\r\n    // Note: Date.UTC() interprets one and two-digit years as being in the\r\n    // 20th century, so don't use it\r\n    let date = new Date();\r\n    date.setUTCHours(hour, minute, second, millisecond);\r\n    date.setUTCFullYear(year, month - 1, day);\r\n    return date.getTime();\r\n}\r\nfunction $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {\r\n    // Fast path for UTC.\r\n    if (timeZone === \"UTC\") return 0;\r\n    // Fast path: for local timezone after 1970, use native Date.\r\n    if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -60000;\r\n    let { year: year, month: month, day: day, hour: hour, minute: minute, second: second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);\r\n    let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);\r\n    return utc - Math.floor(ms / 1000) * 1000;\r\n}\r\nconst $11d87f3f76e88657$var$formattersByTimeZone = new Map();\r\nfunction $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {\r\n    let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);\r\n    if (!formatter) {\r\n        formatter = new Intl.DateTimeFormat(\"en-US\", {\r\n            timeZone: timeZone,\r\n            hour12: false,\r\n            era: \"short\",\r\n            year: \"numeric\",\r\n            month: \"numeric\",\r\n            day: \"numeric\",\r\n            hour: \"numeric\",\r\n            minute: \"numeric\",\r\n            second: \"numeric\"\r\n        });\r\n        $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);\r\n    }\r\n    let parts = formatter.formatToParts(new Date(ms));\r\n    let namedParts = {};\r\n    for (let part of parts)if (part.type !== \"literal\") namedParts[part.type] = part.value;\r\n    return {\r\n        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\r\n        year: namedParts.era === \"BC\" || namedParts.era === \"B\" ? -namedParts.year + 1 : +namedParts.year,\r\n        month: +namedParts.month,\r\n        day: +namedParts.day,\r\n        hour: namedParts.hour === \"24\" ? 0 : +namedParts.hour,\r\n        minute: +namedParts.minute,\r\n        second: +namedParts.second\r\n    };\r\n}\r\nconst $11d87f3f76e88657$var$DAYMILLIS = 86400000;\r\nfunction $11d87f3f76e88657$export$136f38efe7caf549(date, timeZone) {\r\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date);\r\n    let earlier = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);\r\n    let later = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);\r\n    return $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later);\r\n}\r\nfunction $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {\r\n    let found = earlier === later ? [\r\n        earlier\r\n    ] : [\r\n        earlier,\r\n        later\r\n    ];\r\n    return found.filter((absolute)=>$11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));\r\n}\r\nfunction $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {\r\n    let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);\r\n    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;\r\n}\r\nfunction $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = \"compatible\") {\r\n    let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);\r\n    // Fast path: if the time zone is UTC, use native Date.\r\n    if (timeZone === \"UTC\") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);\r\n    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.\r\n    if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === \"compatible\") {\r\n        dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\r\n        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.\r\n        let date = new Date();\r\n        let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);\r\n        date.setFullYear(year, dateTime.month - 1, dateTime.day);\r\n        date.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);\r\n        return date.getTime();\r\n    }\r\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);\r\n    let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);\r\n    let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);\r\n    let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);\r\n    if (valid.length === 1) return valid[0];\r\n    if (valid.length > 1) switch(disambiguation){\r\n        // 'compatible' means 'earlier' for \"fall back\" transitions\r\n        case \"compatible\":\r\n        case \"earlier\":\r\n            return valid[0];\r\n        case \"later\":\r\n            return valid[valid.length - 1];\r\n        case \"reject\":\r\n            throw new RangeError(\"Multiple possible absolute times found\");\r\n    }\r\n    switch(disambiguation){\r\n        case \"earlier\":\r\n            return Math.min(ms - offsetBefore, ms - offsetAfter);\r\n        // 'compatible' means 'later' for \"spring forward\" transitions\r\n        case \"compatible\":\r\n        case \"later\":\r\n            return Math.max(ms - offsetBefore, ms - offsetAfter);\r\n        case \"reject\":\r\n            throw new RangeError(\"No such absolute time found\");\r\n    }\r\n}\r\nfunction $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = \"compatible\") {\r\n    return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));\r\n}\r\nfunction $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {\r\n    let offset = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);\r\n    let date = new Date(ms + offset);\r\n    let year = date.getUTCFullYear();\r\n    let month = date.getUTCMonth() + 1;\r\n    let day = date.getUTCDate();\r\n    let hour = date.getUTCHours();\r\n    let minute = date.getUTCMinutes();\r\n    let second = date.getUTCSeconds();\r\n    let millisecond = date.getUTCMilliseconds();\r\n    return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year, month, day, timeZone, offset, hour, minute, second, millisecond);\r\n}\r\nfunction $11d87f3f76e88657$export$e57ff100d91bd4b9(date, timeZone) {\r\n    return $11d87f3f76e88657$export$1b96692a1ba042ac(date.getTime(), timeZone);\r\n}\r\nfunction $11d87f3f76e88657$export$d7f92bcd3596b086(date) {\r\n    return $11d87f3f76e88657$export$e57ff100d91bd4b9(date, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\r\n}\r\nfunction $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {\r\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);\r\n}\r\nfunction $11d87f3f76e88657$export$6f4d78149f3f53ac(date) {\r\n    return {\r\n        era: date.era,\r\n        year: date.year,\r\n        month: date.month,\r\n        day: date.day\r\n    };\r\n}\r\nfunction $11d87f3f76e88657$export$4d0393e732857be5(date) {\r\n    return {\r\n        hour: date.hour,\r\n        minute: date.minute,\r\n        second: date.second,\r\n        millisecond: date.millisecond\r\n    };\r\n}\r\nfunction $11d87f3f76e88657$export$b21e0b124e224484(date, time) {\r\n    let hour = 0, minute = 0, second = 0, millisecond = 0;\r\n    if (\"timeZone\" in date) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = date);\r\n    else if (\"hour\" in date && !time) return date;\r\n    if (time) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = time);\r\n    return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);\r\n}\r\nfunction $11d87f3f76e88657$export$d33f79e3ffc3dc83(dateTime) {\r\n    return new (0, $35ea8db9cb2ccb90$export$680ea196effce5f)(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);\r\n}\r\nfunction $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {\r\n    if (date.calendar.identifier === calendar.identifier) return date;\r\n    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));\r\n    let copy = date.copy();\r\n    copy.calendar = calendar;\r\n    copy.era = calendarDate.era;\r\n    copy.year = calendarDate.year;\r\n    copy.month = calendarDate.month;\r\n    copy.day = calendarDate.day;\r\n    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);\r\n    return copy;\r\n}\r\nfunction $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {\r\n    if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {\r\n        if (date.timeZone === timeZone) return date;\r\n        return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);\r\n    }\r\n    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);\r\n    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);\r\n}\r\nfunction $11d87f3f76e88657$export$83aac07b4c37b25(date) {\r\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;\r\n    return new Date(ms);\r\n}\r\nfunction $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {\r\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;\r\n    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);\r\n}\r\nfunction $11d87f3f76e88657$export$d9b67bc93c097491(date) {\r\n    return $11d87f3f76e88657$export$538b00033cc11c75(date, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\r\n}\r\n\r\n\r\n\r\nconst $735220c2d4774dd3$var$ONE_HOUR = 3600000;\r\nfunction $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {\r\n    let mutableDate = date.copy();\r\n    let days = \"hour\" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;\r\n    $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);\r\n    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);\r\n    mutableDate.month += duration.months || 0;\r\n    $735220c2d4774dd3$var$balanceYearMonth(mutableDate);\r\n    $735220c2d4774dd3$var$constrainMonthDay(mutableDate);\r\n    mutableDate.day += (duration.weeks || 0) * 7;\r\n    mutableDate.day += duration.days || 0;\r\n    mutableDate.day += days;\r\n    $735220c2d4774dd3$var$balanceDay(mutableDate);\r\n    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);\r\n    // Constrain in case adding ended up with a date outside the valid range for the calendar system.\r\n    // The behavior here is slightly different than when constraining in the `set` function in that\r\n    // we adjust smaller fields to their minimum/maximum values rather than constraining each field\r\n    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\r\n    if (mutableDate.year < 1) {\r\n        mutableDate.year = 1;\r\n        mutableDate.month = 1;\r\n        mutableDate.day = 1;\r\n    }\r\n    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\r\n    if (mutableDate.year > maxYear) {\r\n        var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;\r\n        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);\r\n        mutableDate.year = maxYear;\r\n        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\r\n        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\r\n    }\r\n    if (mutableDate.month < 1) {\r\n        mutableDate.month = 1;\r\n        mutableDate.day = 1;\r\n    }\r\n    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\r\n    if (mutableDate.month > maxMonth) {\r\n        mutableDate.month = maxMonth;\r\n        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\r\n    }\r\n    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\r\n    return mutableDate;\r\n}\r\nfunction $735220c2d4774dd3$var$addYears(date, years) {\r\n    var _date_calendar_isInverseEra, _date_calendar;\r\n    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;\r\n    date.year += years;\r\n}\r\nfunction $735220c2d4774dd3$var$balanceYearMonth(date) {\r\n    while(date.month < 1){\r\n        $735220c2d4774dd3$var$addYears(date, -1);\r\n        date.month += date.calendar.getMonthsInYear(date);\r\n    }\r\n    let monthsInYear = 0;\r\n    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){\r\n        date.month -= monthsInYear;\r\n        $735220c2d4774dd3$var$addYears(date, 1);\r\n    }\r\n}\r\nfunction $735220c2d4774dd3$var$balanceDay(date) {\r\n    while(date.day < 1){\r\n        date.month--;\r\n        $735220c2d4774dd3$var$balanceYearMonth(date);\r\n        date.day += date.calendar.getDaysInMonth(date);\r\n    }\r\n    while(date.day > date.calendar.getDaysInMonth(date)){\r\n        date.day -= date.calendar.getDaysInMonth(date);\r\n        date.month++;\r\n        $735220c2d4774dd3$var$balanceYearMonth(date);\r\n    }\r\n}\r\nfunction $735220c2d4774dd3$var$constrainMonthDay(date) {\r\n    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\r\n    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\r\n}\r\nfunction $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {\r\n    if (date.calendar.constrainDate) date.calendar.constrainDate(date);\r\n    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\r\n    $735220c2d4774dd3$var$constrainMonthDay(date);\r\n}\r\nfunction $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {\r\n    let inverseDuration = {};\r\n    for(let key in duration)if (typeof duration[key] === \"number\") inverseDuration[key] = -duration[key];\r\n    return inverseDuration;\r\n}\r\nfunction $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {\r\n    return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\r\n}\r\nfunction $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {\r\n    let mutableDate = date.copy();\r\n    if (fields.era != null) mutableDate.era = fields.era;\r\n    if (fields.year != null) mutableDate.year = fields.year;\r\n    if (fields.month != null) mutableDate.month = fields.month;\r\n    if (fields.day != null) mutableDate.day = fields.day;\r\n    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);\r\n    return mutableDate;\r\n}\r\nfunction $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {\r\n    let mutableValue = value.copy();\r\n    if (fields.hour != null) mutableValue.hour = fields.hour;\r\n    if (fields.minute != null) mutableValue.minute = fields.minute;\r\n    if (fields.second != null) mutableValue.second = fields.second;\r\n    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;\r\n    $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);\r\n    return mutableValue;\r\n}\r\nfunction $735220c2d4774dd3$var$balanceTime(time) {\r\n    time.second += Math.floor(time.millisecond / 1000);\r\n    time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);\r\n    time.minute += Math.floor(time.second / 60);\r\n    time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);\r\n    time.hour += Math.floor(time.minute / 60);\r\n    time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);\r\n    let days = Math.floor(time.hour / 24);\r\n    time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);\r\n    return days;\r\n}\r\nfunction $735220c2d4774dd3$export$7555de1e070510cb(time) {\r\n    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\r\n    time.second = Math.max(0, Math.min(time.second, 59));\r\n    time.minute = Math.max(0, Math.min(time.minute, 59));\r\n    time.hour = Math.max(0, Math.min(time.hour, 23));\r\n}\r\nfunction $735220c2d4774dd3$var$nonNegativeMod(a, b) {\r\n    let result = a % b;\r\n    if (result < 0) result += b;\r\n    return result;\r\n}\r\nfunction $735220c2d4774dd3$var$addTimeFields(time, duration) {\r\n    time.hour += duration.hours || 0;\r\n    time.minute += duration.minutes || 0;\r\n    time.second += duration.seconds || 0;\r\n    time.millisecond += duration.milliseconds || 0;\r\n    return $735220c2d4774dd3$var$balanceTime(time);\r\n}\r\nfunction $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {\r\n    let res = time.copy();\r\n    $735220c2d4774dd3$var$addTimeFields(res, duration);\r\n    return res;\r\n}\r\nfunction $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {\r\n    return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\r\n}\r\nfunction $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {\r\n    let mutable = value.copy();\r\n    switch(field){\r\n        case \"era\":\r\n            {\r\n                let eras = value.calendar.getEras();\r\n                let eraIndex = eras.indexOf(value.era);\r\n                if (eraIndex < 0) throw new Error(\"Invalid era: \" + value.era);\r\n                eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);\r\n                mutable.era = eras[eraIndex];\r\n                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\r\n                $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\r\n                break;\r\n            }\r\n        case \"year\":\r\n            var _mutable_calendar_isInverseEra, _mutable_calendar;\r\n            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;\r\n            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\r\n            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\r\n            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\r\n            mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);\r\n            if (mutable.year === -Infinity) mutable.year = 1;\r\n            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);\r\n            break;\r\n        case \"month\":\r\n            mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);\r\n            break;\r\n        case \"day\":\r\n            mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);\r\n            break;\r\n        default:\r\n            throw new Error(\"Unsupported field \" + field);\r\n    }\r\n    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);\r\n    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\r\n    return mutable;\r\n}\r\nfunction $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {\r\n    let mutable = value.copy();\r\n    switch(field){\r\n        case \"hour\":\r\n            {\r\n                let hours = value.hour;\r\n                let min = 0;\r\n                let max = 23;\r\n                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\r\n                    let isPM = hours >= 12;\r\n                    min = isPM ? 12 : 0;\r\n                    max = isPM ? 23 : 11;\r\n                }\r\n                mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);\r\n                break;\r\n            }\r\n        case \"minute\":\r\n            mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\r\n            break;\r\n        case \"second\":\r\n            mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\r\n            break;\r\n        case \"millisecond\":\r\n            mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);\r\n            break;\r\n        default:\r\n            throw new Error(\"Unsupported field \" + field);\r\n    }\r\n    return mutable;\r\n}\r\nfunction $735220c2d4774dd3$var$cycleValue(value, amount, min, max, round = false) {\r\n    if (round) {\r\n        value += Math.sign(amount);\r\n        if (value < min) value = max;\r\n        let div = Math.abs(amount);\r\n        if (amount > 0) value = Math.ceil(value / div) * div;\r\n        else value = Math.floor(value / div) * div;\r\n        if (value > max) value = min;\r\n    } else {\r\n        value += amount;\r\n        if (value < min) value = max - (min - value - 1);\r\n        else if (value > max) value = min + (value - max - 1);\r\n    }\r\n    return value;\r\n}\r\nfunction $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {\r\n    let ms;\r\n    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {\r\n        let res = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {\r\n            years: duration.years,\r\n            months: duration.months,\r\n            weeks: duration.weeks,\r\n            days: duration.days\r\n        });\r\n        // Changing the date may change the timezone offset, so we need to recompute\r\n        // using the 'compatible' disambiguation.\r\n        ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\r\n    } else // Otherwise, preserve the offset of the original date.\r\n    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\r\n    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\r\n    // For example, adding one hour during a DST transition may result in the hour field staying the same or\r\n    // skipping an hour. This results in the offset field changing value instead of the specified field.\r\n    ms += duration.milliseconds || 0;\r\n    ms += (duration.seconds || 0) * 1000;\r\n    ms += (duration.minutes || 0) * 60000;\r\n    ms += (duration.hours || 0) * 3600000;\r\n    let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);\r\n    return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);\r\n}\r\nfunction $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {\r\n    return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\r\n}\r\nfunction $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {\r\n    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\r\n    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\r\n    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\r\n    switch(field){\r\n        case \"hour\":\r\n            {\r\n                let min = 0;\r\n                let max = 23;\r\n                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\r\n                    let isPM = dateTime.hour >= 12;\r\n                    min = isPM ? 12 : 0;\r\n                    max = isPM ? 23 : 11;\r\n                }\r\n                // The minimum and maximum hour may be affected by daylight saving time.\r\n                // For example, it might jump forward at midnight, and skip 1am.\r\n                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\r\n                // the possible absolute times for the min and max, and find the maximum range\r\n                // that is within the current day.\r\n                let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\r\n                let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\r\n                    hour: min\r\n                }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\r\n                let minAbsolute = [\r\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, \"earlier\"),\r\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, \"later\")\r\n                ].filter((ms)=>(0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];\r\n                let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\r\n                    hour: max\r\n                }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\r\n                let maxAbsolute = [\r\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, \"earlier\"),\r\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, \"later\")\r\n                ].filter((ms)=>(0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();\r\n                // Since hours may repeat, we need to operate on the absolute time in milliseconds.\r\n                // This is done in hours from the Unix epoch so that cycleValue works correctly,\r\n                // and then converted back to milliseconds.\r\n                let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\r\n                let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);\r\n                let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;\r\n                ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;\r\n                // Now compute the new timezone offset, and convert the absolute time back to local time.\r\n                return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\r\n            }\r\n        case \"minute\":\r\n        case \"second\":\r\n        case \"millisecond\":\r\n            // @ts-ignore\r\n            return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);\r\n        case \"era\":\r\n        case \"year\":\r\n        case \"month\":\r\n        case \"day\":\r\n            {\r\n                let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);\r\n                let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\r\n                return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\r\n            }\r\n        default:\r\n            throw new Error(\"Unsupported field \" + field);\r\n    }\r\n}\r\nfunction $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {\r\n    // Set the date/time fields, and recompute the UTC offset to account for DST changes.\r\n    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\r\n    let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\r\n    let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);\r\n    // If the resulting plain date time values are equal, return the original time.\r\n    // We don't want to change the offset when setting the time to the same value.\r\n    if (res.compare(plainDateTime) === 0) return dateTime;\r\n    let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);\r\n    return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\r\n}\r\n\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\n\r\n\r\n\r\nconst $fae977aafc393c5c$var$TIME_RE = /^(\\d{2})(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?$/;\r\nconst $fae977aafc393c5c$var$DATE_RE = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\r\nconst $fae977aafc393c5c$var$DATE_TIME_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?$/;\r\nconst $fae977aafc393c5c$var$ZONED_DATE_TIME_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?(?:([+-]\\d{2})(?::?(\\d{2}))?)?\\[(.*?)\\]$/;\r\nconst $fae977aafc393c5c$var$ABSOLUTE_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?(?:(?:([+-]\\d{2})(?::?(\\d{2}))?)|Z)$/;\r\nconst $fae977aafc393c5c$var$DATE_TIME_DURATION_RE = /^((?<negative>-)|\\+)?P((?<years>\\d*)Y)?((?<months>\\d*)M)?((?<weeks>\\d*)W)?((?<days>\\d*)D)?((?<time>T)((?<hours>\\d*[.,]?\\d{1,9})H)?((?<minutes>\\d*[.,]?\\d{1,9})M)?((?<seconds>\\d*[.,]?\\d{1,9})S)?)?$/;\r\nconst $fae977aafc393c5c$var$requiredDurationTimeGroups = [\r\n    \"hours\",\r\n    \"minutes\",\r\n    \"seconds\"\r\n];\r\nconst $fae977aafc393c5c$var$requiredDurationGroups = [\r\n    \"years\",\r\n    \"months\",\r\n    \"weeks\",\r\n    \"days\",\r\n    ...$fae977aafc393c5c$var$requiredDurationTimeGroups\r\n];\r\nfunction $fae977aafc393c5c$export$c9698ec7f05a07e1(value) {\r\n    let m = value.match($fae977aafc393c5c$var$TIME_RE);\r\n    if (!m) throw new Error(\"Invalid ISO 8601 time string: \" + value);\r\n    return new (0, $35ea8db9cb2ccb90$export$680ea196effce5f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 23), m[2] ? $fae977aafc393c5c$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $fae977aafc393c5c$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);\r\n}\r\nfunction $fae977aafc393c5c$export$6b862160d295c8e(value) {\r\n    let m = value.match($fae977aafc393c5c$var$DATE_RE);\r\n    if (!m) throw new Error(\"Invalid ISO 8601 date string: \" + value);\r\n    let date = new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);\r\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\r\n    return date;\r\n}\r\nfunction $fae977aafc393c5c$export$588937bcd60ade55(value) {\r\n    let m = value.match($fae977aafc393c5c$var$DATE_TIME_RE);\r\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\r\n    let date = new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\r\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\r\n    return date;\r\n}\r\nfunction $fae977aafc393c5c$export$fd7893f06e92a6a4(value, disambiguation) {\r\n    let m = value.match($fae977aafc393c5c$var$ZONED_DATE_TIME_RE);\r\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\r\n    let date = new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\r\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\r\n    let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(date);\r\n    let ms;\r\n    if (m[8]) {\r\n        var _m_;\r\n        date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : \"0\", 0, 59) * 60000;\r\n        ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(date) - date.offset;\r\n        // Validate offset against parsed date.\r\n        let absolutes = (0, $11d87f3f76e88657$export$136f38efe7caf549)(plainDateTime, date.timeZone);\r\n        if (!absolutes.includes(ms)) throw new Error(`Offset ${$fae977aafc393c5c$var$offsetToString(date.offset)} is invalid for ${$fae977aafc393c5c$export$4223de14708adc63(date)} in ${date.timeZone}`);\r\n    } else // Convert to absolute and back to fix invalid times due to DST.\r\n    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)((0, $11d87f3f76e88657$export$b21e0b124e224484)(plainDateTime), date.timeZone, disambiguation);\r\n    return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, date.timeZone);\r\n}\r\nfunction $fae977aafc393c5c$export$5adfdab05168c219(value, timeZone) {\r\n    let m = value.match($fae977aafc393c5c$var$ABSOLUTE_RE);\r\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\r\n    let date = new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\r\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\r\n    var _m_;\r\n    if (m[8]) date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : \"0\", 0, 59) * 60000;\r\n    return (0, $11d87f3f76e88657$export$538b00033cc11c75)(date, timeZone);\r\n}\r\nfunction $fae977aafc393c5c$export$8e384432362ed0f0(value) {\r\n    return $fae977aafc393c5c$export$5adfdab05168c219(value, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\r\n}\r\nfunction $fae977aafc393c5c$var$parseNumber(value, min, max) {\r\n    let val = Number(value);\r\n    if (val < min || val > max) throw new RangeError(`Value out of range: ${min} <= ${val} <= ${max}`);\r\n    return val;\r\n}\r\nfunction $fae977aafc393c5c$export$f59dee82248f5ad4(time) {\r\n    return `${String(time.hour).padStart(2, \"0\")}:${String(time.minute).padStart(2, \"0\")}:${String(time.second).padStart(2, \"0\")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : \"\"}`;\r\n}\r\nfunction $fae977aafc393c5c$export$60dfd74aa96791bd(date) {\r\n    let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\r\n    return `${String(gregorianDate.year).padStart(4, \"0\")}-${String(gregorianDate.month).padStart(2, \"0\")}-${String(gregorianDate.day).padStart(2, \"0\")}`;\r\n}\r\nfunction $fae977aafc393c5c$export$4223de14708adc63(date) {\r\n    // @ts-ignore\r\n    return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;\r\n}\r\nfunction $fae977aafc393c5c$var$offsetToString(offset) {\r\n    let sign = Math.sign(offset) < 0 ? \"-\" : \"+\";\r\n    offset = Math.abs(offset);\r\n    let offsetHours = Math.floor(offset / 3600000);\r\n    let offsetMinutes = offset % 3600000 / 60000;\r\n    return `${sign}${String(offsetHours).padStart(2, \"0\")}:${String(offsetMinutes).padStart(2, \"0\")}`;\r\n}\r\nfunction $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {\r\n    return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;\r\n}\r\nfunction $fae977aafc393c5c$export$ecae829bb3747ea6(value) {\r\n    var _match_groups, _match_groups1, _match_groups2, _match_groups3, _match_groups4, _match_groups5, _match_groups6, _match_groups7, _match_groups8;\r\n    const match = value.match($fae977aafc393c5c$var$DATE_TIME_DURATION_RE);\r\n    if (!match) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\r\n    const parseDurationGroup = (group, isNegative, min, max)=>{\r\n        if (!group) return 0;\r\n        try {\r\n            const sign = isNegative ? -1 : 1;\r\n            return sign * $fae977aafc393c5c$var$parseNumber(group.replace(\",\", \".\"), min, max);\r\n        } catch  {\r\n            throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\r\n        }\r\n    };\r\n    const isNegative = !!((_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups.negative);\r\n    const hasRequiredGroups = $fae977aafc393c5c$var$requiredDurationGroups.some((group)=>{\r\n        var _match_groups;\r\n        return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];\r\n    });\r\n    if (!hasRequiredGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\r\n    const durationStringIncludesTime = (_match_groups1 = match.groups) === null || _match_groups1 === void 0 ? void 0 : _match_groups1.time;\r\n    if (durationStringIncludesTime) {\r\n        const hasRequiredDurationTimeGroups = $fae977aafc393c5c$var$requiredDurationTimeGroups.some((group)=>{\r\n            var _match_groups;\r\n            return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];\r\n        });\r\n        if (!hasRequiredDurationTimeGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\r\n    }\r\n    const duration = {\r\n        years: parseDurationGroup((_match_groups2 = match.groups) === null || _match_groups2 === void 0 ? void 0 : _match_groups2.years, isNegative, 0, 9999),\r\n        months: parseDurationGroup((_match_groups3 = match.groups) === null || _match_groups3 === void 0 ? void 0 : _match_groups3.months, isNegative, 0, 12),\r\n        weeks: parseDurationGroup((_match_groups4 = match.groups) === null || _match_groups4 === void 0 ? void 0 : _match_groups4.weeks, isNegative, 0, Infinity),\r\n        days: parseDurationGroup((_match_groups5 = match.groups) === null || _match_groups5 === void 0 ? void 0 : _match_groups5.days, isNegative, 0, 31),\r\n        hours: parseDurationGroup((_match_groups6 = match.groups) === null || _match_groups6 === void 0 ? void 0 : _match_groups6.hours, isNegative, 0, 23),\r\n        minutes: parseDurationGroup((_match_groups7 = match.groups) === null || _match_groups7 === void 0 ? void 0 : _match_groups7.minutes, isNegative, 0, 59),\r\n        seconds: parseDurationGroup((_match_groups8 = match.groups) === null || _match_groups8 === void 0 ? void 0 : _match_groups8.seconds, isNegative, 0, 59)\r\n    };\r\n    if (duration.hours !== undefined && duration.hours % 1 !== 0 && (duration.minutes || duration.seconds)) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);\r\n    if (duration.minutes !== undefined && duration.minutes % 1 !== 0 && duration.seconds) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);\r\n    return duration;\r\n}\r\n\r\n\r\n\r\n\r\nfunction $35ea8db9cb2ccb90$var$shiftArgs(args) {\r\n    let calendar = typeof args[0] === \"object\" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();\r\n    let era;\r\n    if (typeof args[0] === \"string\") era = args.shift();\r\n    else {\r\n        let eras = calendar.getEras();\r\n        era = eras[eras.length - 1];\r\n    }\r\n    let year = args.shift();\r\n    let month = args.shift();\r\n    let day = args.shift();\r\n    return [\r\n        calendar,\r\n        era,\r\n        year,\r\n        month,\r\n        day\r\n    ];\r\n}\r\nvar // This prevents TypeScript from allowing other types with the same fields to match.\r\n// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.\r\n// If that behavior is desired, use the AnyCalendarDate interface instead.\r\n// @ts-ignore\r\n$35ea8db9cb2ccb90$var$_type = /*#__PURE__*/ new WeakMap();\r\nclass $35ea8db9cb2ccb90$export$99faa760c7908e4f {\r\n    /** Returns a copy of this date. */ copy() {\r\n        if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);\r\n        else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);\r\n    }\r\n    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {\r\n        return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\r\n    }\r\n    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {\r\n        return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\r\n    }\r\n    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\r\n        return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);\r\n    }\r\n    /**\r\n   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.\r\n   * When the resulting value reaches the limits of the field, it wraps around.\r\n   */ cycle(field, amount, options) {\r\n        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\r\n    }\r\n    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {\r\n        return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);\r\n    }\r\n    /** Converts the date to an ISO 8601 formatted string. */ toString() {\r\n        return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);\r\n    }\r\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\r\n        return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\r\n    }\r\n    constructor(...args){\r\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type, {\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\r\n        this.calendar = calendar;\r\n        this.era = era;\r\n        this.year = year;\r\n        this.month = month;\r\n        this.day = day;\r\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\r\n    }\r\n}\r\nvar // This prevents TypeScript from allowing other types with the same fields to match.\r\n// @ts-ignore\r\n$35ea8db9cb2ccb90$var$_type1 = /*#__PURE__*/ new WeakMap();\r\nclass $35ea8db9cb2ccb90$export$680ea196effce5f {\r\n    /** Returns a copy of this time. */ copy() {\r\n        return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);\r\n    }\r\n    /** Returns a new `Time` with the given duration added to it. */ add(duration) {\r\n        return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);\r\n    }\r\n    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {\r\n        return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);\r\n    }\r\n    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\r\n        return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);\r\n    }\r\n    /**\r\n   * Returns a new `Time` with the given field adjusted by a specified amount.\r\n   * When the resulting value reaches the limits of the field, it wraps around.\r\n   */ cycle(field, amount, options) {\r\n        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\r\n    }\r\n    /** Converts the time to an ISO 8601 formatted string. */ toString() {\r\n        return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);\r\n    }\r\n    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {\r\n        return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);\r\n    }\r\n    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){\r\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type1, {\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.hour = hour;\r\n        this.minute = minute;\r\n        this.second = second;\r\n        this.millisecond = millisecond;\r\n        (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);\r\n    }\r\n}\r\nvar // This prevents TypeScript from allowing other types with the same fields to match.\r\n// @ts-ignore\r\n$35ea8db9cb2ccb90$var$_type2 = /*#__PURE__*/ new WeakMap();\r\nclass $35ea8db9cb2ccb90$export$ca871e8dbb80966f {\r\n    /** Returns a copy of this date. */ copy() {\r\n        if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n        else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n    }\r\n    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {\r\n        return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\r\n    }\r\n    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {\r\n        return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\r\n    }\r\n    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\r\n        return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);\r\n    }\r\n    /**\r\n   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.\r\n   * When the resulting value reaches the limits of the field, it wraps around.\r\n   */ cycle(field, amount, options) {\r\n        switch(field){\r\n            case \"era\":\r\n            case \"year\":\r\n            case \"month\":\r\n            case \"day\":\r\n                return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\r\n            default:\r\n                return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\r\n        }\r\n    }\r\n    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {\r\n        return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);\r\n    }\r\n    /** Converts the date to an ISO 8601 formatted string. */ toString() {\r\n        return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);\r\n    }\r\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\r\n        let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\r\n        if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));\r\n        return res;\r\n    }\r\n    constructor(...args){\r\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type2, {\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\r\n        this.calendar = calendar;\r\n        this.era = era;\r\n        this.year = year;\r\n        this.month = month;\r\n        this.day = day;\r\n        this.hour = args.shift() || 0;\r\n        this.minute = args.shift() || 0;\r\n        this.second = args.shift() || 0;\r\n        this.millisecond = args.shift() || 0;\r\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\r\n    }\r\n}\r\nvar // This prevents TypeScript from allowing other types with the same fields to match.\r\n// @ts-ignore\r\n$35ea8db9cb2ccb90$var$_type3 = /*#__PURE__*/ new WeakMap();\r\nclass $35ea8db9cb2ccb90$export$d3b7288e7994edea {\r\n    /** Returns a copy of this date. */ copy() {\r\n        if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\r\n        else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\r\n    }\r\n    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {\r\n        return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);\r\n    }\r\n    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {\r\n        return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);\r\n    }\r\n    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {\r\n        return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);\r\n    }\r\n    /**\r\n   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.\r\n   * When the resulting value reaches the limits of the field, it wraps around.\r\n   */ cycle(field, amount, options) {\r\n        return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);\r\n    }\r\n    /** Converts the date to a native JavaScript Date object. */ toDate() {\r\n        return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);\r\n    }\r\n    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {\r\n        return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);\r\n    }\r\n    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {\r\n        return this.toDate().toISOString();\r\n    }\r\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\r\n        // TODO: Is this a bad idea??\r\n        return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();\r\n    }\r\n    constructor(...args){\r\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type3, {\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\r\n        let timeZone = args.shift();\r\n        let offset = args.shift();\r\n        this.calendar = calendar;\r\n        this.era = era;\r\n        this.year = year;\r\n        this.month = month;\r\n        this.day = day;\r\n        this.timeZone = timeZone;\r\n        this.offset = offset;\r\n        this.hour = args.shift() || 0;\r\n        this.minute = args.shift() || 0;\r\n        this.second = args.shift() || 0;\r\n        this.millisecond = args.shift() || 0;\r\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\nconst $62225008020f0a13$var$ERA_START_DATES = [\r\n    [\r\n        1868,\r\n        9,\r\n        8\r\n    ],\r\n    [\r\n        1912,\r\n        7,\r\n        30\r\n    ],\r\n    [\r\n        1926,\r\n        12,\r\n        25\r\n    ],\r\n    [\r\n        1989,\r\n        1,\r\n        8\r\n    ],\r\n    [\r\n        2019,\r\n        5,\r\n        1\r\n    ]\r\n];\r\nconst $62225008020f0a13$var$ERA_END_DATES = [\r\n    [\r\n        1912,\r\n        7,\r\n        29\r\n    ],\r\n    [\r\n        1926,\r\n        12,\r\n        24\r\n    ],\r\n    [\r\n        1989,\r\n        1,\r\n        7\r\n    ],\r\n    [\r\n        2019,\r\n        4,\r\n        30\r\n    ]\r\n];\r\nconst $62225008020f0a13$var$ERA_ADDENDS = [\r\n    1867,\r\n    1911,\r\n    1925,\r\n    1988,\r\n    2018\r\n];\r\nconst $62225008020f0a13$var$ERA_NAMES = [\r\n    \"meiji\",\r\n    \"taisho\",\r\n    \"showa\",\r\n    \"heisei\",\r\n    \"reiwa\"\r\n];\r\nfunction $62225008020f0a13$var$findEraFromGregorianDate(date) {\r\n    const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day])=>{\r\n        if (date.year < year) return true;\r\n        if (date.year === year && date.month < month) return true;\r\n        if (date.year === year && date.month === month && date.day < day) return true;\r\n        return false;\r\n    });\r\n    if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;\r\n    if (idx === 0) return 0;\r\n    return idx - 1;\r\n}\r\nfunction $62225008020f0a13$var$toGregorian(date) {\r\n    let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];\r\n    if (!eraAddend) throw new Error(\"Unknown era: \" + date.era);\r\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);\r\n}\r\nclass $62225008020f0a13$export$b746ab2b60cdffbf extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\r\n    fromJulianDay(jd) {\r\n        let date = super.fromJulianDay(jd);\r\n        let era = $62225008020f0a13$var$findEraFromGregorianDate(date);\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);\r\n    }\r\n    toJulianDay(date) {\r\n        return super.toJulianDay($62225008020f0a13$var$toGregorian(date));\r\n    }\r\n    balanceDate(date) {\r\n        let gregorianDate = $62225008020f0a13$var$toGregorian(date);\r\n        let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);\r\n        if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {\r\n            date.era = $62225008020f0a13$var$ERA_NAMES[era];\r\n            date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];\r\n        }\r\n        // Constrain in case we went before the first supported era.\r\n        this.constrainDate(date);\r\n    }\r\n    constrainDate(date) {\r\n        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\r\n        let end = $62225008020f0a13$var$ERA_END_DATES[idx];\r\n        if (end != null) {\r\n            let [endYear, endMonth, endDay] = end;\r\n            // Constrain the year to the maximum possible value in the era.\r\n            // Then constrain the month and day fields within that.\r\n            let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];\r\n            date.year = Math.max(1, Math.min(maxYear, date.year));\r\n            if (date.year === maxYear) {\r\n                date.month = Math.min(endMonth, date.month);\r\n                if (date.month === endMonth) date.day = Math.min(endDay, date.day);\r\n            }\r\n        }\r\n        if (date.year === 1 && idx >= 0) {\r\n            let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];\r\n            date.month = Math.max(startMonth, date.month);\r\n            if (date.month === startMonth) date.day = Math.max(startDay, date.day);\r\n        }\r\n    }\r\n    getEras() {\r\n        return $62225008020f0a13$var$ERA_NAMES;\r\n    }\r\n    getYearsInEra(date) {\r\n        // Get the number of years in the era, taking into account the date's month and day fields.\r\n        let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\r\n        let cur = $62225008020f0a13$var$ERA_START_DATES[era];\r\n        let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];\r\n        if (next == null) // 9999 gregorian is the maximum year allowed.\r\n        return 9999 - cur[0] + 1;\r\n        let years = next[0] - cur[0];\r\n        if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;\r\n        return years;\r\n    }\r\n    getDaysInMonth(date) {\r\n        return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));\r\n    }\r\n    getMinimumMonthInYear(date) {\r\n        let start = $62225008020f0a13$var$getMinimums(date);\r\n        return start ? start[1] : 1;\r\n    }\r\n    getMinimumDayInMonth(date) {\r\n        let start = $62225008020f0a13$var$getMinimums(date);\r\n        return start && date.month === start[1] ? start[2] : 1;\r\n    }\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"japanese\";\r\n    }\r\n}\r\nfunction $62225008020f0a13$var$getMinimums(date) {\r\n    if (date.year === 1) {\r\n        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\r\n        return $62225008020f0a13$var$ERA_START_DATES[idx];\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\nconst $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;\r\nclass $8d73d47422ca7302$export$42d20a78301dee44 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\r\n    fromJulianDay(jd) {\r\n        let gregorianDate = super.fromJulianDay(jd);\r\n        let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);\r\n    }\r\n    toJulianDay(date) {\r\n        return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date));\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"BE\"\r\n        ];\r\n    }\r\n    getDaysInMonth(date) {\r\n        return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date));\r\n    }\r\n    balanceDate() {}\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"buddhist\";\r\n    }\r\n}\r\nfunction $8d73d47422ca7302$var$toGregorian(date) {\r\n    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(date.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);\r\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\nconst $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;\r\nfunction $5f31bd6f0c8940b2$var$gregorianYear(date) {\r\n    return date.era === \"minguo\" ? date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\r\n}\r\nfunction $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {\r\n    let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\r\n    if (y > 0) return [\r\n        \"minguo\",\r\n        y\r\n    ];\r\n    else return [\r\n        \"before_minguo\",\r\n        1 - y\r\n    ];\r\n}\r\nclass $5f31bd6f0c8940b2$export$65e01080afcb0799 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\r\n    fromJulianDay(jd) {\r\n        let date = super.fromJulianDay(jd);\r\n        let extendedYear = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);\r\n        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(extendedYear);\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, date.month, date.day);\r\n    }\r\n    toJulianDay(date) {\r\n        return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date));\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"before_minguo\",\r\n            \"minguo\"\r\n        ];\r\n    }\r\n    balanceDate(date) {\r\n        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date));\r\n        date.era = era;\r\n        date.year = year;\r\n    }\r\n    isInverseEra(date) {\r\n        return date.era === \"before_minguo\";\r\n    }\r\n    getDaysInMonth(date) {\r\n        return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date));\r\n    }\r\n    getYearsInEra(date) {\r\n        return date.era === \"before_minguo\" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\r\n    }\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"roc\" // Republic of China\r\n        ;\r\n    }\r\n}\r\nfunction $5f31bd6f0c8940b2$var$toGregorian(date) {\r\n    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)($5f31bd6f0c8940b2$var$gregorianYear(date));\r\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\nconst $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.\r\nfunction $f3ed2e4472ae7e25$var$isLeapYear(year) {\r\n    let y0 = year > 0 ? year - 474 : year - 473;\r\n    let y1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(y0, 2820) + 474;\r\n    return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)((y1 + 38) * 31, 128) < 31;\r\n}\r\nfunction $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, day) {\r\n    let y0 = year > 0 ? year - 474 : year - 473;\r\n    let y1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(y0, 2820) + 474;\r\n    let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;\r\n    return $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;\r\n}\r\nclass $f3ed2e4472ae7e25$export$37fccdbfd14c5939 {\r\n    fromJulianDay(jd) {\r\n        let d0 = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(475, 1, 1);\r\n        let n2820 = Math.floor(d0 / 1029983);\r\n        let d1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(d0, 1029983);\r\n        let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);\r\n        let year = 474 + 2820 * n2820 + y2820;\r\n        if (year <= 0) year--;\r\n        let yDay = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, 1, 1) + 1;\r\n        let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);\r\n        let day = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, 1) + 1;\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);\r\n    }\r\n    toJulianDay(date) {\r\n        return $f3ed2e4472ae7e25$var$persianToJulianDay(date.year, date.month, date.day);\r\n    }\r\n    getMonthsInYear() {\r\n        return 12;\r\n    }\r\n    getDaysInMonth(date) {\r\n        if (date.month <= 6) return 31;\r\n        if (date.month <= 11) return 30;\r\n        return $f3ed2e4472ae7e25$var$isLeapYear(date.year) ? 30 : 29;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"AP\"\r\n        ];\r\n    }\r\n    getYearsInEra() {\r\n        // 9378-10-10 persian is 9999-12-31 gregorian.\r\n        // Round down to 9377 to set the maximum full year.\r\n        return 9377;\r\n    }\r\n    constructor(){\r\n        this.identifier = \"persian\";\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\n// Starts in 78 AD,\r\nconst $82c358003bdda0a8$var$INDIAN_ERA_START = 78;\r\n// The Indian year starts 80 days later than the Gregorian year.\r\nconst $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;\r\nclass $82c358003bdda0a8$export$39f31c639fa15726 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\r\n    fromJulianDay(jd) {\r\n        // Gregorian date for Julian day\r\n        let date = super.fromJulianDay(jd);\r\n        // Year in Saka era\r\n        let indianYear = date.year - $82c358003bdda0a8$var$INDIAN_ERA_START;\r\n        // Day number in Gregorian year (starting from 0)\r\n        let yDay = jd - (0, $3b62074eb05584b2$export$f297eb839006d339)(date.era, date.year, 1, 1);\r\n        let leapMonth;\r\n        if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {\r\n            //  Day is at the end of the preceding Saka year\r\n            indianYear--;\r\n            // Days in leapMonth this year, previous Gregorian year\r\n            leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;\r\n            yDay += leapMonth + 155 + 90 + 10;\r\n        } else {\r\n            // Days in leapMonth this year\r\n            leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;\r\n            yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;\r\n        }\r\n        let indianMonth;\r\n        let indianDay;\r\n        if (yDay < leapMonth) {\r\n            indianMonth = 1;\r\n            indianDay = yDay + 1;\r\n        } else {\r\n            let mDay = yDay - leapMonth;\r\n            if (mDay < 155) {\r\n                indianMonth = Math.floor(mDay / 31) + 2;\r\n                indianDay = mDay % 31 + 1;\r\n            } else {\r\n                mDay -= 155;\r\n                indianMonth = Math.floor(mDay / 30) + 7;\r\n                indianDay = mDay % 30 + 1;\r\n            }\r\n        }\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);\r\n    }\r\n    toJulianDay(date) {\r\n        let extendedYear = date.year + $82c358003bdda0a8$var$INDIAN_ERA_START;\r\n        let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(extendedYear);\r\n        let leapMonth;\r\n        let jd;\r\n        if ((0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(year)) {\r\n            leapMonth = 31;\r\n            jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 21);\r\n        } else {\r\n            leapMonth = 30;\r\n            jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 22);\r\n        }\r\n        if (date.month === 1) return jd + date.day - 1;\r\n        jd += leapMonth + Math.min(date.month - 2, 5) * 31;\r\n        if (date.month >= 8) jd += (date.month - 7) * 30;\r\n        jd += date.day - 1;\r\n        return jd;\r\n    }\r\n    getDaysInMonth(date) {\r\n        if (date.month === 1 && (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;\r\n        if (date.month >= 2 && date.month <= 6) return 31;\r\n        return 30;\r\n    }\r\n    getYearsInEra() {\r\n        // 9999-12-31 gregorian is 9920-10-10 indian.\r\n        // Round down to 9919 for the last full year.\r\n        return 9919;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"saka\"\r\n        ];\r\n    }\r\n    balanceDate() {}\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"indian\";\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\nconst $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)\r\nconst $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)\r\nconst $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;\r\nconst $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;\r\nconst $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;\r\nfunction $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {\r\n    return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;\r\n}\r\nfunction $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar, epoch, jd) {\r\n    let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);\r\n    let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);\r\n    let day = jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1;\r\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(calendar, year, month, day);\r\n}\r\nfunction $f2f3e0e3a817edbd$var$isLeapYear(year) {\r\n    return (14 + 11 * year) % 30 < 11;\r\n}\r\nclass $f2f3e0e3a817edbd$export$2066795aadd37bfc {\r\n    fromJulianDay(jd) {\r\n        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);\r\n    }\r\n    toJulianDay(date) {\r\n        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date.year, date.month, date.day);\r\n    }\r\n    getDaysInMonth(date) {\r\n        let length = 29 + date.month % 2;\r\n        if (date.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date.year)) length++;\r\n        return length;\r\n    }\r\n    getMonthsInYear() {\r\n        return 12;\r\n    }\r\n    getDaysInYear(date) {\r\n        return $f2f3e0e3a817edbd$var$isLeapYear(date.year) ? 355 : 354;\r\n    }\r\n    getYearsInEra() {\r\n        // 9999 gregorian\r\n        return 9665;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"AH\"\r\n        ];\r\n    }\r\n    constructor(){\r\n        this.identifier = \"islamic-civil\";\r\n    }\r\n}\r\nclass $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {\r\n    fromJulianDay(jd) {\r\n        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);\r\n    }\r\n    toJulianDay(date) {\r\n        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);\r\n    }\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"islamic-tbla\";\r\n    }\r\n}\r\n// Generated by scripts/generate-umalqura.js\r\nconst $f2f3e0e3a817edbd$var$UMALQURA_DATA = \"qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=\";\r\nlet $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;\r\nlet $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;\r\nfunction $f2f3e0e3a817edbd$var$umalquraYearStart(year) {\r\n    return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];\r\n}\r\nfunction $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {\r\n    let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;\r\n    let mask = 0x01 << 11 - (month - 1);\r\n    if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;\r\n    else return 30;\r\n}\r\nfunction $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {\r\n    let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);\r\n    for(let i = 1; i < month; i++)day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);\r\n    return day;\r\n}\r\nfunction $f2f3e0e3a817edbd$var$umalquraYearLength(year) {\r\n    return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];\r\n}\r\nclass $f2f3e0e3a817edbd$export$5baab4758c231076 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {\r\n    fromJulianDay(jd) {\r\n        let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;\r\n        let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);\r\n        let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);\r\n        if (days < startDays || days > endDays) return super.fromJulianDay(jd);\r\n        else {\r\n            let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;\r\n            let m = 1;\r\n            let d = 1;\r\n            while(d > 0){\r\n                y++;\r\n                d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;\r\n                let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);\r\n                if (d === yearLength) {\r\n                    m = 12;\r\n                    break;\r\n                } else if (d < yearLength) {\r\n                    let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);\r\n                    m = 1;\r\n                    while(d > monthLength){\r\n                        d -= monthLength;\r\n                        m++;\r\n                        monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, y, m, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m) + 1);\r\n        }\r\n    }\r\n    toJulianDay(date) {\r\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date);\r\n        return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);\r\n    }\r\n    getDaysInMonth(date) {\r\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);\r\n        return $f2f3e0e3a817edbd$var$umalquraMonthLength(date.year, date.month);\r\n    }\r\n    getDaysInYear(date) {\r\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);\r\n        return $f2f3e0e3a817edbd$var$umalquraYearLength(date.year);\r\n    }\r\n    constructor(){\r\n        super();\r\n        this.identifier = \"islamic-umalqura\";\r\n        if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c)=>c.charCodeAt(0)).buffer);\r\n        if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {\r\n            $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);\r\n            let yearStart = 0;\r\n            for(let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++){\r\n                $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;\r\n                for(let i = 1; i <= 12; i++)yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\n\r\nconst $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;\r\n// Hebrew date calculations are performed in terms of days, hours, and\r\n// \"parts\" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.\r\nconst $7c5f6fbf42389787$var$HOUR_PARTS = 1080;\r\nconst $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;\r\n// An approximate value for the length of a lunar month.\r\n// It is used to calculate the approximate year and month of a given\r\n// absolute date.\r\nconst $7c5f6fbf42389787$var$MONTH_DAYS = 29;\r\nconst $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;\r\nconst $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;\r\nfunction $7c5f6fbf42389787$var$isLeapYear(year) {\r\n    return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;\r\n}\r\n// Test for delay of start of new year and to avoid\r\n// Sunday, Wednesday, and Friday as start of the new year.\r\nfunction $7c5f6fbf42389787$var$hebrewDelay1(year) {\r\n    let months = Math.floor((235 * year - 234) / 19);\r\n    let parts = 12084 + 13753 * months;\r\n    let day = months * 29 + Math.floor(parts / 25920);\r\n    if ((0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;\r\n    return day;\r\n}\r\n// Check for delay in start of new year due to length of adjacent years\r\nfunction $7c5f6fbf42389787$var$hebrewDelay2(year) {\r\n    let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);\r\n    let present = $7c5f6fbf42389787$var$hebrewDelay1(year);\r\n    let next = $7c5f6fbf42389787$var$hebrewDelay1(year + 1);\r\n    if (next - present === 356) return 2;\r\n    if (present - last === 382) return 1;\r\n    return 0;\r\n}\r\nfunction $7c5f6fbf42389787$var$startOfYear(year) {\r\n    return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);\r\n}\r\nfunction $7c5f6fbf42389787$var$getDaysInYear(year) {\r\n    return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);\r\n}\r\nfunction $7c5f6fbf42389787$var$getYearType(year) {\r\n    let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);\r\n    if (yearLength > 380) yearLength -= 30; // Subtract length of leap month.\r\n    switch(yearLength){\r\n        case 353:\r\n            return 0; // deficient\r\n        case 354:\r\n            return 1; // normal\r\n        case 355:\r\n            return 2; // complete\r\n    }\r\n}\r\nfunction $7c5f6fbf42389787$var$getDaysInMonth(year, month) {\r\n    // Normalize month numbers from 1 - 13, even on non-leap years\r\n    if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;\r\n    // First of all, dispose of fixed-length 29 day months\r\n    if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;\r\n    let yearType = $7c5f6fbf42389787$var$getYearType(year);\r\n    // If it's Heshvan, days depend on length of year\r\n    if (month === 2) return yearType === 2 ? 30 : 29;\r\n    // Similarly, Kislev varies with the length of year\r\n    if (month === 3) return yearType === 0 ? 29 : 30;\r\n    // Adar I only exists in leap years\r\n    if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;\r\n    return 30;\r\n}\r\nclass $7c5f6fbf42389787$export$ca405048b8fb5af {\r\n    fromJulianDay(jd) {\r\n        let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;\r\n        let m = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS; // Months (approx)\r\n        let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)\r\n        let ys = $7c5f6fbf42389787$var$startOfYear(year); // 1st day of year\r\n        let dayOfYear = Math.floor(d - ys);\r\n        // Because of the postponement rules, it's possible to guess wrong.  Fix it.\r\n        while(dayOfYear < 1){\r\n            year--;\r\n            ys = $7c5f6fbf42389787$var$startOfYear(year);\r\n            dayOfYear = Math.floor(d - ys);\r\n        }\r\n        // Now figure out which month we're in, and the date within that month\r\n        let month = 1;\r\n        let monthStart = 0;\r\n        while(monthStart < dayOfYear){\r\n            monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);\r\n            month++;\r\n        }\r\n        month--;\r\n        monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);\r\n        let day = dayOfYear - monthStart;\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);\r\n    }\r\n    toJulianDay(date) {\r\n        let jd = $7c5f6fbf42389787$var$startOfYear(date.year);\r\n        for(let month = 1; month < date.month; month++)jd += $7c5f6fbf42389787$var$getDaysInMonth(date.year, month);\r\n        return jd + date.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;\r\n    }\r\n    getDaysInMonth(date) {\r\n        return $7c5f6fbf42389787$var$getDaysInMonth(date.year, date.month);\r\n    }\r\n    getMonthsInYear(date) {\r\n        return $7c5f6fbf42389787$var$isLeapYear(date.year) ? 13 : 12;\r\n    }\r\n    getDaysInYear(date) {\r\n        return $7c5f6fbf42389787$var$getDaysInYear(date.year);\r\n    }\r\n    getYearsInEra() {\r\n        // 6239 gregorian\r\n        return 9999;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"AM\"\r\n        ];\r\n    }\r\n    balanceYearMonth(date, previousDate) {\r\n        // Keep date in the same month when switching between leap years and non leap years\r\n        if (previousDate.year !== date.year) {\r\n            if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;\r\n            else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;\r\n        }\r\n    }\r\n    constructor(){\r\n        this.identifier = \"hebrew\";\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from ICU.\r\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\r\n\r\nconst $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;\r\nconst $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;\r\n// The delta between Amete Alem 1 and Amete Mihret 1\r\n// AA 5501 = AM 1\r\nconst $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;\r\nfunction $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {\r\n    return epoch // difference from Julian epoch to 1,1,1\r\n     + 365 * year // number of days from years\r\n     + Math.floor(year / 4) // extra day of leap year\r\n     + 30 * (month - 1 // number of days from months (1 based)\r\n    ) + day - 1 // number of days for present month (1 based)\r\n    ;\r\n}\r\nfunction $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {\r\n    let year = Math.floor(4 * (jd - epoch) / 1461);\r\n    let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);\r\n    let day = jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1);\r\n    return [\r\n        year,\r\n        month,\r\n        day\r\n    ];\r\n}\r\nfunction $b956b2d7a6cf451f$var$getLeapDay(year) {\r\n    return Math.floor(year % 4 / 3);\r\n}\r\nfunction $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {\r\n    // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and\r\n    // an intercalary month at the end of the year of 5 or 6 days, depending whether\r\n    // the year is a leap year or not. The Leap Year follows the same rules as the\r\n    // Julian Calendar so that the extra month always has six days in the year before\r\n    // a Julian Leap Year.\r\n    if (month % 13 !== 0) // not intercalary month\r\n    return 30;\r\n    else // intercalary month 5 days + possible leap day\r\n    return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;\r\n}\r\nclass $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\r\n    fromJulianDay(jd) {\r\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);\r\n        let era = \"AM\";\r\n        if (year <= 0) {\r\n            era = \"AA\";\r\n            year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\r\n        }\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);\r\n    }\r\n    toJulianDay(date) {\r\n        let year = date.year;\r\n        if (date.era === \"AA\") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\r\n        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date.month, date.day);\r\n    }\r\n    getDaysInMonth(date) {\r\n        return $b956b2d7a6cf451f$var$getDaysInMonth(date.year, date.month);\r\n    }\r\n    getMonthsInYear() {\r\n        return 13;\r\n    }\r\n    getDaysInYear(date) {\r\n        return 365 + $b956b2d7a6cf451f$var$getLeapDay(date.year);\r\n    }\r\n    getYearsInEra(date) {\r\n        // 9999-12-31 gregorian is 9992-20-02 ethiopic.\r\n        // Round down to 9991 for the last full year.\r\n        // AA 9999-01-01 ethiopic is 4506-09-30 gregorian.\r\n        return date.era === \"AA\" ? 9999 : 9991;\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"AA\",\r\n            \"AM\"\r\n        ];\r\n    }\r\n    constructor(){\r\n        this.identifier = \"ethiopic\";\r\n    }\r\n}\r\nclass $b956b2d7a6cf451f$export$d72e0c37005a4914 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\r\n    fromJulianDay(jd) {\r\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);\r\n        year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, \"AA\", year, month, day);\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"AA\"\r\n        ];\r\n    }\r\n    getYearsInEra() {\r\n        // 9999-13-04 ethioaa is the maximum date, which is equivalent to 4506-09-29 gregorian.\r\n        return 9999;\r\n    }\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"ethioaa\" // also known as 'ethiopic-amete-alem' in ICU\r\n        ;\r\n    }\r\n}\r\nclass $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\r\n    fromJulianDay(jd) {\r\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);\r\n        let era = \"CE\";\r\n        if (year <= 0) {\r\n            era = \"BCE\";\r\n            year = 1 - year;\r\n        }\r\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);\r\n    }\r\n    toJulianDay(date) {\r\n        let year = date.year;\r\n        if (date.era === \"BCE\") year = 1 - year;\r\n        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date.month, date.day);\r\n    }\r\n    getDaysInMonth(date) {\r\n        let year = date.year;\r\n        if (date.era === \"BCE\") year = 1 - year;\r\n        return $b956b2d7a6cf451f$var$getDaysInMonth(year, date.month);\r\n    }\r\n    isInverseEra(date) {\r\n        return date.era === \"BCE\";\r\n    }\r\n    balanceDate(date) {\r\n        if (date.year <= 0) {\r\n            date.era = date.era === \"BCE\" ? \"CE\" : \"BCE\";\r\n            date.year = 1 - date.year;\r\n        }\r\n    }\r\n    getEras() {\r\n        return [\r\n            \"BCE\",\r\n            \"CE\"\r\n        ];\r\n    }\r\n    getYearsInEra(date) {\r\n        // 9999-12-30 gregorian is 9716-02-20 coptic.\r\n        // Round down to 9715 for the last full year.\r\n        // BCE 9999-01-01 coptic is BC 9716-06-15 gregorian.\r\n        return date.era === \"BCE\" ? 9999 : 9715;\r\n    }\r\n    constructor(...args){\r\n        super(...args);\r\n        this.identifier = \"coptic\";\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction $64244302c3013299$export$dd0bbc9b26defe37(name) {\r\n    switch(name){\r\n        case \"buddhist\":\r\n            return new (0, $8d73d47422ca7302$export$42d20a78301dee44)();\r\n        case \"ethiopic\":\r\n            return new (0, $b956b2d7a6cf451f$export$26ba6eab5e20cd7d)();\r\n        case \"ethioaa\":\r\n            return new (0, $b956b2d7a6cf451f$export$d72e0c37005a4914)();\r\n        case \"coptic\":\r\n            return new (0, $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1)();\r\n        case \"hebrew\":\r\n            return new (0, $7c5f6fbf42389787$export$ca405048b8fb5af)();\r\n        case \"indian\":\r\n            return new (0, $82c358003bdda0a8$export$39f31c639fa15726)();\r\n        case \"islamic-civil\":\r\n            return new (0, $f2f3e0e3a817edbd$export$2066795aadd37bfc)();\r\n        case \"islamic-tbla\":\r\n            return new (0, $f2f3e0e3a817edbd$export$37f0887f2f9d22f7)();\r\n        case \"islamic-umalqura\":\r\n            return new (0, $f2f3e0e3a817edbd$export$5baab4758c231076)();\r\n        case \"japanese\":\r\n            return new (0, $62225008020f0a13$export$b746ab2b60cdffbf)();\r\n        case \"persian\":\r\n            return new (0, $f3ed2e4472ae7e25$export$37fccdbfd14c5939)();\r\n        case \"roc\":\r\n            return new (0, $5f31bd6f0c8940b2$export$65e01080afcb0799)();\r\n        case \"gregory\":\r\n        default:\r\n            return new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ let $fb18d541ea1ad717$var$formatterCache = new Map();\r\nclass $fb18d541ea1ad717$export$ad991b66133851cf {\r\n    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {\r\n        return this.formatter.format(value);\r\n    }\r\n    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {\r\n        return this.formatter.formatToParts(value);\r\n    }\r\n    /** Formats a date range as a string. */ formatRange(start, end) {\r\n        // @ts-ignore\r\n        if (typeof this.formatter.formatRange === \"function\") // @ts-ignore\r\n        return this.formatter.formatRange(start, end);\r\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\r\n        // Very basic fallback for old browsers.\r\n        return `${this.formatter.format(start)} \\u{2013} ${this.formatter.format(end)}`;\r\n    }\r\n    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {\r\n        // @ts-ignore\r\n        if (typeof this.formatter.formatRangeToParts === \"function\") // @ts-ignore\r\n        return this.formatter.formatRangeToParts(start, end);\r\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\r\n        let startParts = this.formatter.formatToParts(start);\r\n        let endParts = this.formatter.formatToParts(end);\r\n        return [\r\n            ...startParts.map((p)=>({\r\n                    ...p,\r\n                    source: \"startRange\"\r\n                })),\r\n            {\r\n                type: \"literal\",\r\n                value: \" \\u2013 \",\r\n                source: \"shared\"\r\n            },\r\n            ...endParts.map((p)=>({\r\n                    ...p,\r\n                    source: \"endRange\"\r\n                }))\r\n        ];\r\n    }\r\n    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {\r\n        let resolvedOptions = this.formatter.resolvedOptions();\r\n        if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {\r\n            if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);\r\n            resolvedOptions.hourCycle = this.resolvedHourCycle;\r\n            resolvedOptions.hour12 = this.resolvedHourCycle === \"h11\" || this.resolvedHourCycle === \"h12\";\r\n        }\r\n        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.\r\n        // https://bugs.webkit.org/show_bug.cgi?id=241564\r\n        if (resolvedOptions.calendar === \"ethiopic-amete-alem\") resolvedOptions.calendar = \"ethioaa\";\r\n        return resolvedOptions;\r\n    }\r\n    constructor(locale, options = {}){\r\n        this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);\r\n        this.options = options;\r\n    }\r\n}\r\n// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.\r\n//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)\r\n//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)\r\n//     rather than h12 (12:00 - 11:59).\r\n//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal\r\n//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]\r\n// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791\r\n// [2] https://github.com/tc39/ecma402/issues/402\r\n// [3] https://bugs.webkit.org/show_bug.cgi?id=229313\r\n// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802\r\nconst $fb18d541ea1ad717$var$hour12Preferences = {\r\n    true: {\r\n        // Only Japanese uses the h11 style for 12 hour time. All others use h12.\r\n        ja: \"h11\"\r\n    },\r\n    false: {\r\n    }\r\n};\r\nfunction $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {\r\n    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.\r\n    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.\r\n    if (typeof options.hour12 === \"boolean\" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {\r\n        options = {\r\n            ...options\r\n        };\r\n        let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split(\"-\")[0]];\r\n        let defaultHourCycle = options.hour12 ? \"h12\" : \"h23\";\r\n        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;\r\n        delete options.hour12;\r\n    }\r\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\r\n    if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);\r\n    let numberFormatter = new Intl.DateTimeFormat(locale, options);\r\n    $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);\r\n    return numberFormatter;\r\n}\r\nlet $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;\r\nfunction $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {\r\n    if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat(\"en-US\", {\r\n        hour: \"numeric\",\r\n        hour12: false\r\n    }).format(new Date(2020, 2, 3, 0)) === \"24\";\r\n    return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;\r\n}\r\nlet $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;\r\nfunction $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {\r\n    if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat(\"fr\", {\r\n        hour: \"numeric\",\r\n        hour12: false\r\n    }).resolvedOptions().hourCycle === \"h12\";\r\n    return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;\r\n}\r\nfunction $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {\r\n    if (!options.timeStyle && !options.hour) return undefined;\r\n    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.\r\n    // Format the minimum possible hour and maximum possible hour in a day and parse the results.\r\n    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, \"\");\r\n    locale += (locale.includes(\"-u-\") ? \"\" : \"-u\") + \"-nu-latn\";\r\n    let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {\r\n        ...options,\r\n        timeZone: undefined // use local timezone\r\n    });\r\n    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === \"hour\").value, 10);\r\n    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === \"hour\").value, 10);\r\n    if (min === 0 && max === 23) return \"h23\";\r\n    if (min === 24 && max === 23) return \"h24\";\r\n    if (min === 0 && max === 11) return \"h11\";\r\n    if (min === 12 && max === 11) return \"h12\";\r\n    throw new Error(\"Unexpected hour cycle result\");\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=module.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL2RhdGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRkFBaUY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQXVFO0FBQ3RHO0FBQ0EsaUJBQWlCLHVFQUF1RTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRTtBQUN0RSw0Q0FBNEMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQzlELGlEQUFpRCxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDeEcsdURBQXVELEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxVQUFVLEVBQUU7QUFDbEosZ0RBQWdELEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSx5QkFBeUIsRUFBRSxVQUFVLEVBQUU7QUFDOUksK0tBQStLLElBQUksMkJBQTJCLElBQUksMkJBQTJCLElBQUk7QUFDalA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxtREFBbUQsaUJBQWlCLGlEQUFpRCxLQUFLLGNBQWM7QUFDdk0sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DLEdBQUcscUNBQXFDLEdBQUcscUNBQXFDLEVBQUUsaUVBQWlFO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQTRDLEdBQUcsNkNBQTZDLEdBQUcsMkNBQTJDO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQWdELEdBQUcsZ0RBQWdEO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLHFDQUFxQyxHQUFHLHVDQUF1QztBQUNwRztBQUNBO0FBQ0EsY0FBYyxnREFBZ0QsRUFBRSxrREFBa0QsR0FBRyxjQUFjO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUZBQWlGLE1BQU07QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpR0FBaUcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlLQUFpSyxPQUFPO0FBQ3hLLCtJQUErSSxPQUFPO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0VBQVE7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBUTtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9FQUFRO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0VBQVE7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGlEQUFpRDtBQUN2SDtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLHlEQUF5RDtBQUN6RCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEIsR0FBRyxNQUFNLEVBQUUsMkJBQTJCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQysvRztBQUMvL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9udXRyaS1zbWFydC8uL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L2ltcG9ydC5tanM/YjVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge18gYXMgJGNVVnVOJF99IGZyb20gXCJAc3djL2hlbHBlcnMvXy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9pbml0XCI7XHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gdGhlIFRDMzkgVGVtcG9yYWwgcHJvcG9zYWwuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cclxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuZnVuY3Rpb24gJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEoYW1vdW50LCBudW1lcmF0b3IpIHtcclxuICAgIHJldHVybiBhbW91bnQgLSBudW1lcmF0b3IgKiBNYXRoLmZsb29yKGFtb3VudCAvIG51bWVyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDc4NGQxM2Q4ZWUzNTFmMDcoZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUuZXJhKSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xyXG4gICAgZWxzZSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XHJcbn1cclxuZnVuY3Rpb24gJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDI3ZmEwMTcyYWUyNjQ0YjMoZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUuZXJhKSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGRhdGUuaG91ciwgZGF0ZS5taW51dGUsIGRhdGUuc2Vjb25kLCBkYXRlLm1pbGxpc2Vjb25kKTtcclxuICAgIGVsc2UgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYpKGRhdGUuY2FsZW5kYXIsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGRhdGUuaG91ciwgZGF0ZS5taW51dGUsIGRhdGUuc2Vjb25kKTtcclxufVxyXG5cclxuXHJcbmNvbnN0ICQzYjYyMDc0ZWIwNTU4NGIyJHZhciRFUE9DSCA9IDE3MjE0MjY7IC8vIDAwMS8wMS8wMyBKdWxpYW4gQy5FLlxyXG5mdW5jdGlvbiAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOShlcmEsIHllYXIsIG1vbnRoLCBkYXkpIHtcclxuICAgIHllYXIgPSAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkYzM2ZTBlY2IyZDRmYTY5ZChlcmEsIHllYXIpO1xyXG4gICAgbGV0IHkxID0geWVhciAtIDE7XHJcbiAgICBsZXQgbW9udGhPZmZzZXQgPSAtMjtcclxuICAgIGlmIChtb250aCA8PSAyKSBtb250aE9mZnNldCA9IDA7XHJcbiAgICBlbHNlIGlmICgkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCh5ZWFyKSkgbW9udGhPZmZzZXQgPSAtMTtcclxuICAgIHJldHVybiAkM2I2MjA3NGViMDU1ODRiMiR2YXIkRVBPQ0ggLSAxICsgMzY1ICogeTEgKyBNYXRoLmZsb29yKHkxIC8gNCkgLSBNYXRoLmZsb29yKHkxIC8gMTAwKSArIE1hdGguZmxvb3IoeTEgLyA0MDApICsgTWF0aC5mbG9vcigoMzY3ICogbW9udGggLSAzNjIpIC8gMTIgKyBtb250aE9mZnNldCArIGRheSk7XHJcbn1cclxuZnVuY3Rpb24gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzAoeWVhcikge1xyXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xyXG59XHJcbmZ1bmN0aW9uICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRjMzZlMGVjYjJkNGZhNjlkKGVyYSwgeWVhcikge1xyXG4gICAgcmV0dXJuIGVyYSA9PT0gXCJCQ1wiID8gMSAtIHllYXIgOiB5ZWFyO1xyXG59XHJcbmZ1bmN0aW9uICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjKHllYXIpIHtcclxuICAgIGxldCBlcmEgPSBcIkFEXCI7XHJcbiAgICBpZiAoeWVhciA8PSAwKSB7XHJcbiAgICAgICAgZXJhID0gXCJCQ1wiO1xyXG4gICAgICAgIHllYXIgPSAxIC0geWVhcjtcclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgZXJhLFxyXG4gICAgICAgIHllYXJcclxuICAgIF07XHJcbn1cclxuY29uc3QgJDNiNjIwNzRlYjA1NTg0YjIkdmFyJGRheXNJbk1vbnRoID0ge1xyXG4gICAgc3RhbmRhcmQ6IFtcclxuICAgICAgICAzMSxcclxuICAgICAgICAyOCxcclxuICAgICAgICAzMSxcclxuICAgICAgICAzMCxcclxuICAgICAgICAzMSxcclxuICAgICAgICAzMCxcclxuICAgICAgICAzMSxcclxuICAgICAgICAzMSxcclxuICAgICAgICAzMCxcclxuICAgICAgICAzMSxcclxuICAgICAgICAzMCxcclxuICAgICAgICAzMVxyXG4gICAgXSxcclxuICAgIGxlYXB5ZWFyOiBbXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMjksXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMzAsXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMzAsXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMzAsXHJcbiAgICAgICAgMzEsXHJcbiAgICAgICAgMzAsXHJcbiAgICAgICAgMzFcclxuICAgIF1cclxufTtcclxuY2xhc3MgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMge1xyXG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xyXG4gICAgICAgIGxldCBqZDAgPSBqZDtcclxuICAgICAgICBsZXQgZGVwb2NoID0gamQwIC0gJDNiNjIwNzRlYjA1NTg0YjIkdmFyJEVQT0NIO1xyXG4gICAgICAgIGxldCBxdWFkcmljZW50ID0gTWF0aC5mbG9vcihkZXBvY2ggLyAxNDYwOTcpO1xyXG4gICAgICAgIGxldCBkcWMgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKGRlcG9jaCwgMTQ2MDk3KTtcclxuICAgICAgICBsZXQgY2VudCA9IE1hdGguZmxvb3IoZHFjIC8gMzY1MjQpO1xyXG4gICAgICAgIGxldCBkY2VudCA9ICgwLCAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSkoZHFjLCAzNjUyNCk7XHJcbiAgICAgICAgbGV0IHF1YWQgPSBNYXRoLmZsb29yKGRjZW50IC8gMTQ2MSk7XHJcbiAgICAgICAgbGV0IGRxdWFkID0gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKShkY2VudCwgMTQ2MSk7XHJcbiAgICAgICAgbGV0IHlpbmRleCA9IE1hdGguZmxvb3IoZHF1YWQgLyAzNjUpO1xyXG4gICAgICAgIGxldCBleHRlbmRlZFllYXIgPSBxdWFkcmljZW50ICogNDAwICsgY2VudCAqIDEwMCArIHF1YWQgKiA0ICsgeWluZGV4ICsgKGNlbnQgIT09IDQgJiYgeWluZGV4ICE9PSA0ID8gMSA6IDApO1xyXG4gICAgICAgIGxldCBbZXJhLCB5ZWFyXSA9ICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjKGV4dGVuZGVkWWVhcik7XHJcbiAgICAgICAgbGV0IHllYXJEYXkgPSBqZDAgLSAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOShlcmEsIHllYXIsIDEsIDEpO1xyXG4gICAgICAgIGxldCBsZWFwQWRqID0gMjtcclxuICAgICAgICBpZiAoamQwIDwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkoZXJhLCB5ZWFyLCAzLCAxKSkgbGVhcEFkaiA9IDA7XHJcbiAgICAgICAgZWxzZSBpZiAoJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzAoeWVhcikpIGxlYXBBZGogPSAxO1xyXG4gICAgICAgIGxldCBtb250aCA9IE1hdGguZmxvb3IoKCh5ZWFyRGF5ICsgbGVhcEFkaikgKiAxMiArIDM3MykgLyAzNjcpO1xyXG4gICAgICAgIGxldCBkYXkgPSBqZDAgLSAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOShlcmEsIHllYXIsIG1vbnRoLCAxKSArIDE7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKGVyYSwgeWVhciwgbW9udGgsIGRheSk7XHJcbiAgICB9XHJcbiAgICB0b0p1bGlhbkRheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KGRhdGUuZXJhLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gJDNiNjIwNzRlYjA1NTg0YjIkdmFyJGRheXNJbk1vbnRoWyQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKGRhdGUueWVhcikgPyBcImxlYXB5ZWFyXCIgOiBcInN0YW5kYXJkXCJdW2RhdGUubW9udGggLSAxXTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIGdldE1vbnRoc0luWWVhcihkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIDEyO1xyXG4gICAgfVxyXG4gICAgZ2V0RGF5c0luWWVhcihkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKGRhdGUueWVhcikgPyAzNjYgOiAzNjU7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBnZXRZZWFyc0luRXJhKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gOTk5OTtcclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgXCJCQ1wiLFxyXG4gICAgICAgICAgICBcIkFEXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgaXNJbnZlcnNlRXJhKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gZGF0ZS5lcmEgPT09IFwiQkNcIjtcclxuICAgIH1cclxuICAgIGJhbGFuY2VEYXRlKGRhdGUpIHtcclxuICAgICAgICBpZiAoZGF0ZS55ZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgZGF0ZS5lcmEgPSBkYXRlLmVyYSA9PT0gXCJCQ1wiID8gXCJBRFwiIDogXCJCQ1wiO1xyXG4gICAgICAgICAgICBkYXRlLnllYXIgPSAxIC0gZGF0ZS55ZWFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJncmVnb3J5XCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLy8gRGF0YSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bmljb2RlLWNsZHIvY2xkci1jb3JlL2Jsb2IvbWFzdGVyL3N1cHBsZW1lbnRhbC93ZWVrRGF0YS5qc29uXHJcbi8vIExvY2FsZXMgc3RhcnRpbmcgb24gU3VuZGF5IGhhdmUgYmVlbiByZW1vdmVkIGZvciBjb21wcmVzc2lvbi5cclxuY29uc3QgJDJmZTI4NmQyZmI0NDlhYmIkZXhwb3J0JDdhNWFjYmQ3N2Q0MTRiZDkgPSB7XHJcbiAgICBcIjAwMVwiOiAxLFxyXG4gICAgQUQ6IDEsXHJcbiAgICBBRTogNixcclxuICAgIEFGOiA2LFxyXG4gICAgQUk6IDEsXHJcbiAgICBBTDogMSxcclxuICAgIEFNOiAxLFxyXG4gICAgQU46IDEsXHJcbiAgICBBUjogMSxcclxuICAgIEFUOiAxLFxyXG4gICAgQVU6IDEsXHJcbiAgICBBWDogMSxcclxuICAgIEFaOiAxLFxyXG4gICAgQkE6IDEsXHJcbiAgICBCRTogMSxcclxuICAgIEJHOiAxLFxyXG4gICAgQkg6IDYsXHJcbiAgICBCTTogMSxcclxuICAgIEJOOiAxLFxyXG4gICAgQlk6IDEsXHJcbiAgICBDSDogMSxcclxuICAgIENMOiAxLFxyXG4gICAgQ006IDEsXHJcbiAgICBDTjogMSxcclxuICAgIENSOiAxLFxyXG4gICAgQ1k6IDEsXHJcbiAgICBDWjogMSxcclxuICAgIERFOiAxLFxyXG4gICAgREo6IDYsXHJcbiAgICBESzogMSxcclxuICAgIERaOiA2LFxyXG4gICAgRUM6IDEsXHJcbiAgICBFRTogMSxcclxuICAgIEVHOiA2LFxyXG4gICAgRVM6IDEsXHJcbiAgICBGSTogMSxcclxuICAgIEZKOiAxLFxyXG4gICAgRk86IDEsXHJcbiAgICBGUjogMSxcclxuICAgIEdCOiAxLFxyXG4gICAgR0U6IDEsXHJcbiAgICBHRjogMSxcclxuICAgIEdQOiAxLFxyXG4gICAgR1I6IDEsXHJcbiAgICBIUjogMSxcclxuICAgIEhVOiAxLFxyXG4gICAgSUU6IDEsXHJcbiAgICBJUTogNixcclxuICAgIElSOiA2LFxyXG4gICAgSVM6IDEsXHJcbiAgICBJVDogMSxcclxuICAgIEpPOiA2LFxyXG4gICAgS0c6IDEsXHJcbiAgICBLVzogNixcclxuICAgIEtaOiAxLFxyXG4gICAgTEI6IDEsXHJcbiAgICBMSTogMSxcclxuICAgIExLOiAxLFxyXG4gICAgTFQ6IDEsXHJcbiAgICBMVTogMSxcclxuICAgIExWOiAxLFxyXG4gICAgTFk6IDYsXHJcbiAgICBNQzogMSxcclxuICAgIE1EOiAxLFxyXG4gICAgTUU6IDEsXHJcbiAgICBNSzogMSxcclxuICAgIE1OOiAxLFxyXG4gICAgTVE6IDEsXHJcbiAgICBNVjogNSxcclxuICAgIE1ZOiAxLFxyXG4gICAgTkw6IDEsXHJcbiAgICBOTzogMSxcclxuICAgIE5aOiAxLFxyXG4gICAgT006IDYsXHJcbiAgICBQTDogMSxcclxuICAgIFFBOiA2LFxyXG4gICAgUkU6IDEsXHJcbiAgICBSTzogMSxcclxuICAgIFJTOiAxLFxyXG4gICAgUlU6IDEsXHJcbiAgICBTRDogNixcclxuICAgIFNFOiAxLFxyXG4gICAgU0k6IDEsXHJcbiAgICBTSzogMSxcclxuICAgIFNNOiAxLFxyXG4gICAgU1k6IDYsXHJcbiAgICBUSjogMSxcclxuICAgIFRNOiAxLFxyXG4gICAgVFI6IDEsXHJcbiAgICBVQTogMSxcclxuICAgIFVZOiAxLFxyXG4gICAgVVo6IDEsXHJcbiAgICBWQTogMSxcclxuICAgIFZOOiAxLFxyXG4gICAgWEs6IDFcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWEzOWVjMTk3OTkzYWVmMChhLCBiKSB7XHJcbiAgICBiID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShiLCBhLmNhbGVuZGFyKTtcclxuICAgIHJldHVybiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXIgJiYgYS5tb250aCA9PT0gYi5tb250aCAmJiBhLmRheSA9PT0gYi5kYXk7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGExOGM4OWNiZDI0MTcwZmYoYSwgYikge1xyXG4gICAgYiA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoYiwgYS5jYWxlbmRhcik7XHJcbiAgICAvLyBJbiB0aGUgSmFwYW5lc2UgY2FsZW5kYXIsIG1vbnRocyBjYW4gc3BhbiBtdWx0aXBsZSBlcmFzL3llYXJzLCBzbyBvbmx5IGNvbXBhcmUgdGhlIGZpcnN0IG9mIHRoZSBtb250aC5cclxuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShhKTtcclxuICAgIGIgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShiKTtcclxuICAgIHJldHVybiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXIgJiYgYS5tb250aCA9PT0gYi5tb250aDtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNTg0MWY5ZWI5NzczZjI1ZihhLCBiKSB7XHJcbiAgICBiID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShiLCBhLmNhbGVuZGFyKTtcclxuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZjkxZTg5ZDNkMDQwNjEwMihhKTtcclxuICAgIGIgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZjkxZTg5ZDNkMDQwNjEwMihiKTtcclxuICAgIHJldHVybiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXI7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDkxYjYyZWJmMmJhNzAzZWUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gYi5jYWxlbmRhci5pZGVudGlmaWVyICYmIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhciAmJiBhLm1vbnRoID09PSBiLm1vbnRoICYmIGEuZGF5ID09PSBiLmRheTtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNWE4ZGEwYzQ0YTNhZmRmMihhLCBiKSB7XHJcbiAgICBhID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYSk7XHJcbiAgICBiID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYik7XHJcbiAgICByZXR1cm4gYS5jYWxlbmRhci5pZGVudGlmaWVyID09PSBiLmNhbGVuZGFyLmlkZW50aWZpZXIgJiYgYS5lcmEgPT09IGIuZXJhICYmIGEueWVhciA9PT0gYi55ZWFyICYmIGEubW9udGggPT09IGIubW9udGg7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVhODQwZjVhNmRkYTgxNDcoYSwgYikge1xyXG4gICAgYSA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGEpO1xyXG4gICAgYiA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGIpO1xyXG4gICAgcmV0dXJuIGEuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gYi5jYWxlbmRhci5pZGVudGlmaWVyICYmIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhcjtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjI5YjBhNDk3YWE2NTI2NyhkYXRlLCB0aW1lWm9uZSkge1xyXG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwKGRhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzKHRpbWVab25lKSk7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDIwNjEwNTZkMDZkN2NkZjcoZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICBsZXQganVsaWFuID0gZGF0ZS5jYWxlbmRhci50b0p1bGlhbkRheShkYXRlKTtcclxuICAgIC8vIElmIGp1bGlhbiBpcyBuZWdhdGl2ZSwgdGhlbiBqdWxpYW4gJSA3IHdpbGwgYmUgbmVnYXRpdmUsIHNvIHdlIGFkanVzdFxyXG4gICAgLy8gYWNjb3JkaW5nbHkuICBKdWxpYW4gZGF5IDAgaXMgTW9uZGF5LlxyXG4gICAgbGV0IGRheU9mV2VlayA9IE1hdGguY2VpbChqdWxpYW4gKyAxIC0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFdlZWtTdGFydChsb2NhbGUpKSAlIDc7XHJcbiAgICBpZiAoZGF5T2ZXZWVrIDwgMCkgZGF5T2ZXZWVrICs9IDc7XHJcbiAgICByZXR1cm4gZGF5T2ZXZWVrO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ0NjE5MzlkZDQ0MjIxNTModGltZVpvbmUpIHtcclxuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKERhdGUubm93KCksIHRpbWVab25lKTtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZDBiZGY0NWFmMDNhNmVhMyh0aW1lWm9uZSkge1xyXG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkOTM1MjJkMWE0MzlmMzYxNykoJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQ2MTkzOWRkNDQyMjE1Myh0aW1lWm9uZSkpO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2ODc4MWRkZjMxYzAwOTBmKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmNhbGVuZGFyLnRvSnVsaWFuRGF5KGEpIC0gYi5jYWxlbmRhci50b0p1bGlhbkRheShiKTtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYzE5YTgwYTk3MjFiODBmNihhLCBiKSB7XHJcbiAgICByZXR1cm4gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJHRpbWVUb01zKGEpIC0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJHRpbWVUb01zKGIpO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJHZhciR0aW1lVG9NcyhhKSB7XHJcbiAgICByZXR1cm4gYS5ob3VyICogMzYwMDAwMCArIGEubWludXRlICogNjAwMDAgKyBhLnNlY29uZCAqIDEwMDAgKyBhLm1pbGxpc2Vjb25kO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQxMjZjOTFjOTQxZGU3ZShhLCB0aW1lWm9uZSkge1xyXG4gICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShhLCB0aW1lWm9uZSk7XHJcbiAgICBsZXQgdG9tb3Jyb3cgPSBhLmFkZCh7XHJcbiAgICAgICAgZGF5czogMVxyXG4gICAgfSk7XHJcbiAgICBsZXQgdG9tb3Jyb3dNcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykodG9tb3Jyb3csIHRpbWVab25lKTtcclxuICAgIHJldHVybiAodG9tb3Jyb3dNcyAtIG1zKSAvIDM2MDAwMDA7XHJcbn1cclxubGV0ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRsb2NhbFRpbWVab25lID0gbnVsbDtcclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGFhOGI0MTczNWFmY2FiZDIoKSB7XHJcbiAgICAvLyBUT0RPOiBpbnZhbGlkYXRlIHRoaXMgc29tZWhvdz9cclxuICAgIGlmICgkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZSA9PSBudWxsKSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XHJcbiAgICByZXR1cm4gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGxvY2FsVGltZVpvbmU7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoZGF0ZSkge1xyXG4gICAgLy8gVXNlIGBzdWJ0cmFjdGAgaW5zdGVhZCBvZiBgc2V0YCBzbyB3ZSBkb24ndCBnZXQgY29uc3RyYWluZWQgaW4gYW4gZXJhLlxyXG4gICAgcmV0dXJuIGRhdGUuc3VidHJhY3Qoe1xyXG4gICAgICAgIGRheXM6IGRhdGUuZGF5IC0gMVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGEyMjU4ZDljNDExODgyNWMoZGF0ZSkge1xyXG4gICAgcmV0dXJuIGRhdGUuYWRkKHtcclxuICAgICAgICBkYXlzOiBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpIC0gZGF0ZS5kYXlcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGRhdGUpIHtcclxuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShkYXRlLnN1YnRyYWN0KHtcclxuICAgICAgICBtb250aHM6IGRhdGUubW9udGggLSAxXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDhiN2FhNTVjNjZkNTU2OWUoZGF0ZSkge1xyXG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMjI1OGQ5YzQxMTg4MjVjKGRhdGUuYWRkKHtcclxuICAgICAgICBtb250aHM6IGRhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKGRhdGUpIC0gZGF0ZS5tb250aFxyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1NDEyYWMxMTcxM2I3MmFkKGRhdGUpIHtcclxuICAgIGlmIChkYXRlLmNhbGVuZGFyLmdldE1pbmltdW1Nb250aEluWWVhcikgcmV0dXJuIGRhdGUuY2FsZW5kYXIuZ2V0TWluaW11bU1vbnRoSW5ZZWFyKGRhdGUpO1xyXG4gICAgcmV0dXJuIDE7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGIyZjQ5NTNkMzAxOTgxZDUoZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuZ2V0TWluaW11bURheUluTW9udGgpIHJldHVybiBkYXRlLmNhbGVuZGFyLmdldE1pbmltdW1EYXlJbk1vbnRoKGRhdGUpO1xyXG4gICAgcmV0dXJuIDE7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQyYzgxYTQ0NGZiZmI1ZDQoZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICBsZXQgZGF5T2ZXZWVrID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDIwNjEwNTZkMDZkN2NkZjcoZGF0ZSwgbG9jYWxlKTtcclxuICAgIHJldHVybiBkYXRlLnN1YnRyYWN0KHtcclxuICAgICAgICBkYXlzOiBkYXlPZldlZWtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlZjhiNmQ5MTMzMDg0ZjRlKGRhdGUsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ0MmM4MWE0NDRmYmZiNWQ0KGRhdGUsIGxvY2FsZSkuYWRkKHtcclxuICAgICAgICBkYXlzOiA2XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkY2FjaGVkUmVnaW9ucyA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFJlZ2lvbihsb2NhbGUpIHtcclxuICAgIC8vIElmIHRoZSBJbnRsLkxvY2FsZSBBUEkgaXMgYXZhaWxhYmxlLCB1c2UgaXQgdG8gZ2V0IHRoZSByZWdpb24gZm9yIHRoZSBsb2NhbGUuXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAoSW50bC5Mb2NhbGUpIHtcclxuICAgICAgICAvLyBDb25zdHJ1Y3RpbmcgYW4gSW50bC5Mb2NhbGUgaXMgZXhwZW5zaXZlLCBzbyBjYWNoZSB0aGUgcmVzdWx0LlxyXG4gICAgICAgIGxldCByZWdpb24gPSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkY2FjaGVkUmVnaW9ucy5nZXQobG9jYWxlKTtcclxuICAgICAgICBpZiAoIXJlZ2lvbikge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHJlZ2lvbiA9IG5ldyBJbnRsLkxvY2FsZShsb2NhbGUpLm1heGltaXplKCkucmVnaW9uO1xyXG4gICAgICAgICAgICBpZiAocmVnaW9uKSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkY2FjaGVkUmVnaW9ucy5zZXQobG9jYWxlLCByZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVnaW9uO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgbm90LCBqdXN0IHRyeSBzcGxpdHRpbmcgdGhlIHN0cmluZy5cclxuICAgIC8vIElmIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgbG9jYWxlIHN0cmluZyBpcyAndScsXHJcbiAgICAvLyB0aGVuIHRoaXMgaXMgYSB1bmljb2RlIGV4dGVuc2lvbiwgc28gaWdub3JlIGl0LlxyXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCBzaG91bGQgYmUgdGhlIHJlZ2lvbi5cclxuICAgIGxldCBwYXJ0ID0gbG9jYWxlLnNwbGl0KFwiLVwiKVsxXTtcclxuICAgIHJldHVybiBwYXJ0ID09PSBcInVcIiA/IHVuZGVmaW5lZCA6IHBhcnQ7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFdlZWtTdGFydChsb2NhbGUpIHtcclxuICAgIC8vIFRPRE86IHVzZSBJbnRsLkxvY2FsZSBmb3IgdGhpcyBvbmNlIGJyb3dzZXJzIHN1cHBvcnQgdGhlIHdlZWtJbmZvIHByb3BlcnR5XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbnRsLWxvY2FsZS1pbmZvXHJcbiAgICBsZXQgcmVnaW9uID0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFJlZ2lvbihsb2NhbGUpO1xyXG4gICAgcmV0dXJuIHJlZ2lvbiA/ICgwLCAkMmZlMjg2ZDJmYjQ0OWFiYiRleHBvcnQkN2E1YWNiZDc3ZDQxNGJkOSlbcmVnaW9uXSB8fCAwIDogMDtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkY2NjMWIyNDc5ZTdkZDY1NChkYXRlLCBsb2NhbGUpIHtcclxuICAgIGxldCBkYXlzID0gZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoKCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3KCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGRhdGUpLCBsb2NhbGUpICsgZGF5cykgLyA3KTtcclxufVxyXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNWMzMzNhMTE2ZTk0OWNkZChhLCBiKSB7XHJcbiAgICBpZiAoYSAmJiBiKSByZXR1cm4gYS5jb21wYXJlKGIpIDw9IDAgPyBhIDogYjtcclxuICAgIHJldHVybiBhIHx8IGI7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE3NWYyYmZmNTc4MTEwNTUoYSwgYikge1xyXG4gICAgaWYgKGEgJiYgYikgcmV0dXJuIGEuY29tcGFyZShiKSA+PSAwID8gYSA6IGI7XHJcbiAgICByZXR1cm4gYSB8fCBiO1xyXG59XHJcbmNvbnN0ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRXRUVLRU5EX0RBVEEgPSB7XHJcbiAgICBBRjogW1xyXG4gICAgICAgIDQsXHJcbiAgICAgICAgNVxyXG4gICAgXSxcclxuICAgIEFFOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA2XHJcbiAgICBdLFxyXG4gICAgQkg6IFtcclxuICAgICAgICA1LFxyXG4gICAgICAgIDZcclxuICAgIF0sXHJcbiAgICBEWjogW1xyXG4gICAgICAgIDUsXHJcbiAgICAgICAgNlxyXG4gICAgXSxcclxuICAgIEVHOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA2XHJcbiAgICBdLFxyXG4gICAgSUw6IFtcclxuICAgICAgICA1LFxyXG4gICAgICAgIDZcclxuICAgIF0sXHJcbiAgICBJUTogW1xyXG4gICAgICAgIDUsXHJcbiAgICAgICAgNlxyXG4gICAgXSxcclxuICAgIElSOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA1XHJcbiAgICBdLFxyXG4gICAgSk86IFtcclxuICAgICAgICA1LFxyXG4gICAgICAgIDZcclxuICAgIF0sXHJcbiAgICBLVzogW1xyXG4gICAgICAgIDUsXHJcbiAgICAgICAgNlxyXG4gICAgXSxcclxuICAgIExZOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA2XHJcbiAgICBdLFxyXG4gICAgT006IFtcclxuICAgICAgICA1LFxyXG4gICAgICAgIDZcclxuICAgIF0sXHJcbiAgICBRQTogW1xyXG4gICAgICAgIDUsXHJcbiAgICAgICAgNlxyXG4gICAgXSxcclxuICAgIFNBOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA2XHJcbiAgICBdLFxyXG4gICAgU0Q6IFtcclxuICAgICAgICA1LFxyXG4gICAgICAgIDZcclxuICAgIF0sXHJcbiAgICBTWTogW1xyXG4gICAgICAgIDUsXHJcbiAgICAgICAgNlxyXG4gICAgXSxcclxuICAgIFlFOiBbXHJcbiAgICAgICAgNSxcclxuICAgICAgICA2XHJcbiAgICBdXHJcbn07XHJcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIoZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICBsZXQganVsaWFuID0gZGF0ZS5jYWxlbmRhci50b0p1bGlhbkRheShkYXRlKTtcclxuICAgIC8vIElmIGp1bGlhbiBpcyBuZWdhdGl2ZSwgdGhlbiBqdWxpYW4gJSA3IHdpbGwgYmUgbmVnYXRpdmUsIHNvIHdlIGFkanVzdFxyXG4gICAgLy8gYWNjb3JkaW5nbHkuICBKdWxpYW4gZGF5IDAgaXMgTW9uZGF5LlxyXG4gICAgbGV0IGRheU9mV2VlayA9IE1hdGguY2VpbChqdWxpYW4gKyAxKSAlIDc7XHJcbiAgICBpZiAoZGF5T2ZXZWVrIDwgMCkgZGF5T2ZXZWVrICs9IDc7XHJcbiAgICBsZXQgcmVnaW9uID0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFJlZ2lvbihsb2NhbGUpO1xyXG4gICAgLy8gVXNlIEludGwuTG9jYWxlIGZvciB0aGlzIG9uY2Ugd2Vla0luZm8gaXMgc3VwcG9ydGVkLlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaW50bC1sb2NhbGUtaW5mb1xyXG4gICAgbGV0IFtzdGFydCwgZW5kXSA9ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRXRUVLRU5EX0RBVEFbcmVnaW9uXSB8fCBbXHJcbiAgICAgICAgNixcclxuICAgICAgICAwXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGRheU9mV2VlayA9PT0gc3RhcnQgfHwgZGF5T2ZXZWVrID09PSBlbmQ7XHJcbn1cclxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVlOWQ4NzI1OGUxZDE5ZWQoZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gISQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIoZGF0ZSwgbG9jYWxlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIoZGF0ZSkge1xyXG4gICAgZGF0ZSA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKGRhdGUsIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCkpO1xyXG4gICAgbGV0IHllYXIgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQpKGRhdGUuZXJhLCBkYXRlLnllYXIpO1xyXG4gICAgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRlcG9jaEZyb21QYXJ0cyh5ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSwgZGF0ZS5ob3VyLCBkYXRlLm1pbnV0ZSwgZGF0ZS5zZWNvbmQsIGRhdGUubWlsbGlzZWNvbmQpO1xyXG59XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRlcG9jaEZyb21QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpIHtcclxuICAgIC8vIE5vdGU6IERhdGUuVVRDKCkgaW50ZXJwcmV0cyBvbmUgYW5kIHR3by1kaWdpdCB5ZWFycyBhcyBiZWluZyBpbiB0aGVcclxuICAgIC8vIDIwdGggY2VudHVyeSwgc28gZG9uJ3QgdXNlIGl0XHJcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCk7XHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcclxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcywgdGltZVpvbmUpIHtcclxuICAgIC8vIEZhc3QgcGF0aCBmb3IgVVRDLlxyXG4gICAgaWYgKHRpbWVab25lID09PSBcIlVUQ1wiKSByZXR1cm4gMDtcclxuICAgIC8vIEZhc3QgcGF0aDogZm9yIGxvY2FsIHRpbWV6b25lIGFmdGVyIDE5NzAsIHVzZSBuYXRpdmUgRGF0ZS5cclxuICAgIGlmIChtcyA+IDAgJiYgdGltZVpvbmUgPT09ICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSkgcmV0dXJuIG5ldyBEYXRlKG1zKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTYwMDAwO1xyXG4gICAgbGV0IHsgeWVhcjogeWVhciwgbW9udGg6IG1vbnRoLCBkYXk6IGRheSwgaG91cjogaG91ciwgbWludXRlOiBtaW51dGUsIHNlY29uZDogc2Vjb25kIH0gPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VGltZVpvbmVQYXJ0cyhtcywgdGltZVpvbmUpO1xyXG4gICAgbGV0IHV0YyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRlcG9jaEZyb21QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgMCk7XHJcbiAgICByZXR1cm4gdXRjIC0gTWF0aC5mbG9vcihtcyAvIDEwMDApICogMTAwMDtcclxufVxyXG5jb25zdCAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZm9ybWF0dGVyc0J5VGltZVpvbmUgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRnZXRUaW1lWm9uZVBhcnRzKG1zLCB0aW1lWm9uZSkge1xyXG4gICAgbGV0IGZvcm1hdHRlciA9ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRmb3JtYXR0ZXJzQnlUaW1lWm9uZS5nZXQodGltZVpvbmUpO1xyXG4gICAgaWYgKCFmb3JtYXR0ZXIpIHtcclxuICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcclxuICAgICAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxyXG4gICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcmE6IFwic2hvcnRcIixcclxuICAgICAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXHJcbiAgICAgICAgICAgIG1vbnRoOiBcIm51bWVyaWNcIixcclxuICAgICAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcclxuICAgICAgICAgICAgaG91cjogXCJudW1lcmljXCIsXHJcbiAgICAgICAgICAgIG1pbnV0ZTogXCJudW1lcmljXCIsXHJcbiAgICAgICAgICAgIHNlY29uZDogXCJudW1lcmljXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZm9ybWF0dGVyc0J5VGltZVpvbmUuc2V0KHRpbWVab25lLCBmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMobmV3IERhdGUobXMpKTtcclxuICAgIGxldCBuYW1lZFBhcnRzID0ge307XHJcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKWlmIChwYXJ0LnR5cGUgIT09IFwibGl0ZXJhbFwiKSBuYW1lZFBhcnRzW3BhcnQudHlwZV0gPSBwYXJ0LnZhbHVlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgQiBpbnN0ZWFkIG9mIEJDLi4uIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3NTIyNTNcclxuICAgICAgICB5ZWFyOiBuYW1lZFBhcnRzLmVyYSA9PT0gXCJCQ1wiIHx8IG5hbWVkUGFydHMuZXJhID09PSBcIkJcIiA/IC1uYW1lZFBhcnRzLnllYXIgKyAxIDogK25hbWVkUGFydHMueWVhcixcclxuICAgICAgICBtb250aDogK25hbWVkUGFydHMubW9udGgsXHJcbiAgICAgICAgZGF5OiArbmFtZWRQYXJ0cy5kYXksXHJcbiAgICAgICAgaG91cjogbmFtZWRQYXJ0cy5ob3VyID09PSBcIjI0XCIgPyAwIDogK25hbWVkUGFydHMuaG91cixcclxuICAgICAgICBtaW51dGU6ICtuYW1lZFBhcnRzLm1pbnV0ZSxcclxuICAgICAgICBzZWNvbmQ6ICtuYW1lZFBhcnRzLnNlY29uZFxyXG4gICAgfTtcclxufVxyXG5jb25zdCAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkREFZTUlMTElTID0gODY0MDAwMDA7XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxMzZmMzhlZmU3Y2FmNTQ5KGRhdGUsIHRpbWVab25lKSB7XHJcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpO1xyXG4gICAgbGV0IGVhcmxpZXIgPSBtcyAtICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zIC0gJDExZDg3ZjNmNzZlODg2NTckdmFyJERBWU1JTExJUywgdGltZVpvbmUpO1xyXG4gICAgbGV0IGxhdGVyID0gbXMgLSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyArICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcclxuICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VmFsaWRXYWxsVGltZXMoZGF0ZSwgdGltZVpvbmUsIGVhcmxpZXIsIGxhdGVyKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VmFsaWRXYWxsVGltZXMoZGF0ZSwgdGltZVpvbmUsIGVhcmxpZXIsIGxhdGVyKSB7XHJcbiAgICBsZXQgZm91bmQgPSBlYXJsaWVyID09PSBsYXRlciA/IFtcclxuICAgICAgICBlYXJsaWVyXHJcbiAgICBdIDogW1xyXG4gICAgICAgIGVhcmxpZXIsXHJcbiAgICAgICAgbGF0ZXJcclxuICAgIF07XHJcbiAgICByZXR1cm4gZm91bmQuZmlsdGVyKChhYnNvbHV0ZSk9PiQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRpc1ZhbGlkV2FsbFRpbWUoZGF0ZSwgdGltZVpvbmUsIGFic29sdXRlKSk7XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckdmFyJGlzVmFsaWRXYWxsVGltZShkYXRlLCB0aW1lWm9uZSwgYWJzb2x1dGUpIHtcclxuICAgIGxldCBwYXJ0cyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRnZXRUaW1lWm9uZVBhcnRzKGFic29sdXRlLCB0aW1lWm9uZSk7XHJcbiAgICByZXR1cm4gZGF0ZS55ZWFyID09PSBwYXJ0cy55ZWFyICYmIGRhdGUubW9udGggPT09IHBhcnRzLm1vbnRoICYmIGRhdGUuZGF5ID09PSBwYXJ0cy5kYXkgJiYgZGF0ZS5ob3VyID09PSBwYXJ0cy5ob3VyICYmIGRhdGUubWludXRlID09PSBwYXJ0cy5taW51dGUgJiYgZGF0ZS5zZWNvbmQgPT09IHBhcnRzLnNlY29uZDtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YyhkYXRlLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24gPSBcImNvbXBhdGlibGVcIikge1xyXG4gICAgbGV0IGRhdGVUaW1lID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQoZGF0ZSk7XHJcbiAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSB0aW1lIHpvbmUgaXMgVVRDLCB1c2UgbmF0aXZlIERhdGUuXHJcbiAgICBpZiAodGltZVpvbmUgPT09IFwiVVRDXCIpIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGVUaW1lKTtcclxuICAgIC8vIEZhc3QgcGF0aDogaWYgdGhlIHRpbWUgem9uZSBpcyB0aGUgbG9jYWwgdGltZXpvbmUgYW5kIGRpc2FtYmlndWF0aW9uIGlzIGNvbXBhdGlibGUsIHVzZSBuYXRpdmUgRGF0ZS5cclxuICAgIGlmICh0aW1lWm9uZSA9PT0gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpICYmIGRpc2FtYmlndWF0aW9uID09PSBcImNvbXBhdGlibGVcIikge1xyXG4gICAgICAgIGRhdGVUaW1lID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoZGF0ZVRpbWUsIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCkpO1xyXG4gICAgICAgIC8vIERvbid0IHVzZSBEYXRlIGNvbnN0cnVjdG9yIGhlcmUgYmVjYXVzZSB0d28tZGlnaXQgeWVhcnMgYXJlIGludGVycHJldGVkIGluIHRoZSAyMHRoIGNlbnR1cnkuXHJcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGxldCB5ZWFyID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRjMzZlMGVjYjJkNGZhNjlkKShkYXRlVGltZS5lcmEsIGRhdGVUaW1lLnllYXIpO1xyXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhciwgZGF0ZVRpbWUubW9udGggLSAxLCBkYXRlVGltZS5kYXkpO1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoZGF0ZVRpbWUuaG91ciwgZGF0ZVRpbWUubWludXRlLCBkYXRlVGltZS5zZWNvbmQsIGRhdGVUaW1lLm1pbGxpc2Vjb25kKTtcclxuICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XHJcbiAgICB9XHJcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGVUaW1lKTtcclxuICAgIGxldCBvZmZzZXRCZWZvcmUgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyAtICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcclxuICAgIGxldCBvZmZzZXRBZnRlciA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zICsgJDExZDg3ZjNmNzZlODg2NTckdmFyJERBWU1JTExJUywgdGltZVpvbmUpO1xyXG4gICAgbGV0IHZhbGlkID0gJDExZDg3ZjNmNzZlODg2NTckdmFyJGdldFZhbGlkV2FsbFRpbWVzKGRhdGVUaW1lLCB0aW1lWm9uZSwgbXMgLSBvZmZzZXRCZWZvcmUsIG1zIC0gb2Zmc2V0QWZ0ZXIpO1xyXG4gICAgaWYgKHZhbGlkLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHZhbGlkWzBdO1xyXG4gICAgaWYgKHZhbGlkLmxlbmd0aCA+IDEpIHN3aXRjaChkaXNhbWJpZ3VhdGlvbil7XHJcbiAgICAgICAgLy8gJ2NvbXBhdGlibGUnIG1lYW5zICdlYXJsaWVyJyBmb3IgXCJmYWxsIGJhY2tcIiB0cmFuc2l0aW9uc1xyXG4gICAgICAgIGNhc2UgXCJjb21wYXRpYmxlXCI6XHJcbiAgICAgICAgY2FzZSBcImVhcmxpZXJcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkWzBdO1xyXG4gICAgICAgIGNhc2UgXCJsYXRlclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRbdmFsaWQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgY2FzZSBcInJlamVjdFwiOlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIHBvc3NpYmxlIGFic29sdXRlIHRpbWVzIGZvdW5kXCIpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoKGRpc2FtYmlndWF0aW9uKXtcclxuICAgICAgICBjYXNlIFwiZWFybGllclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4obXMgLSBvZmZzZXRCZWZvcmUsIG1zIC0gb2Zmc2V0QWZ0ZXIpO1xyXG4gICAgICAgIC8vICdjb21wYXRpYmxlJyBtZWFucyAnbGF0ZXInIGZvciBcInNwcmluZyBmb3J3YXJkXCIgdHJhbnNpdGlvbnNcclxuICAgICAgICBjYXNlIFwiY29tcGF0aWJsZVwiOlxyXG4gICAgICAgIGNhc2UgXCJsYXRlclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgobXMgLSBvZmZzZXRCZWZvcmUsIG1zIC0gb2Zmc2V0QWZ0ZXIpO1xyXG4gICAgICAgIGNhc2UgXCJyZWplY3RcIjpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBzdWNoIGFic29sdXRlIHRpbWUgZm91bmRcIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU2N2EwOTVjNjIwYjg2ZmUoZGF0ZVRpbWUsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbiA9IFwiY29tcGF0aWJsZVwiKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMoZGF0ZVRpbWUsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbikpO1xyXG59XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKG1zLCB0aW1lWm9uZSkge1xyXG4gICAgbGV0IG9mZnNldCA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zLCB0aW1lWm9uZSk7XHJcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKG1zICsgb2Zmc2V0KTtcclxuICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpICsgMTtcclxuICAgIGxldCBkYXkgPSBkYXRlLmdldFVUQ0RhdGUoKTtcclxuICAgIGxldCBob3VyID0gZGF0ZS5nZXRVVENIb3VycygpO1xyXG4gICAgbGV0IG1pbnV0ZSA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgbGV0IHNlY29uZCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgbGV0IG1pbGxpc2Vjb25kID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKSh5ZWFyLCBtb250aCwgZGF5LCB0aW1lWm9uZSwgb2Zmc2V0LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xyXG59XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRlNTdmZjEwMGQ5MWJkNGI5KGRhdGUsIHRpbWVab25lKSB7XHJcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMoZGF0ZS5nZXRUaW1lKCksIHRpbWVab25lKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDdmOTJiY2QzNTk2YjA4NihkYXRlKSB7XHJcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU1N2ZmMTAwZDkxYmQ0YjkoZGF0ZSwgKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkOTM1MjJkMWE0MzlmMzYxNyhkYXRlVGltZSkge1xyXG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKGRhdGVUaW1lLmNhbGVuZGFyLCBkYXRlVGltZS5lcmEsIGRhdGVUaW1lLnllYXIsIGRhdGVUaW1lLm1vbnRoLCBkYXRlVGltZS5kYXkpO1xyXG59XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ2ZjRkNzgxNDlmM2Y1M2FjKGRhdGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXJhOiBkYXRlLmVyYSxcclxuICAgICAgICB5ZWFyOiBkYXRlLnllYXIsXHJcbiAgICAgICAgbW9udGg6IGRhdGUubW9udGgsXHJcbiAgICAgICAgZGF5OiBkYXRlLmRheVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNGQwMzkzZTczMjg1N2JlNShkYXRlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhvdXI6IGRhdGUuaG91cixcclxuICAgICAgICBtaW51dGU6IGRhdGUubWludXRlLFxyXG4gICAgICAgIHNlY29uZDogZGF0ZS5zZWNvbmQsXHJcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGRhdGUubWlsbGlzZWNvbmRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQoZGF0ZSwgdGltZSkge1xyXG4gICAgbGV0IGhvdXIgPSAwLCBtaW51dGUgPSAwLCBzZWNvbmQgPSAwLCBtaWxsaXNlY29uZCA9IDA7XHJcbiAgICBpZiAoXCJ0aW1lWm9uZVwiIGluIGRhdGUpICh7IGhvdXI6IGhvdXIsIG1pbnV0ZTogbWludXRlLCBzZWNvbmQ6IHNlY29uZCwgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kIH0gPSBkYXRlKTtcclxuICAgIGVsc2UgaWYgKFwiaG91clwiIGluIGRhdGUgJiYgIXRpbWUpIHJldHVybiBkYXRlO1xyXG4gICAgaWYgKHRpbWUpICh7IGhvdXI6IGhvdXIsIG1pbnV0ZTogbWludXRlLCBzZWNvbmQ6IHNlY29uZCwgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kIH0gPSB0aW1lKTtcclxuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmKShkYXRlLmNhbGVuZGFyLCBkYXRlLmVyYSwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDMzZjc5ZTNmZmMzZGM4MyhkYXRlVGltZSkge1xyXG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZikoZGF0ZVRpbWUuaG91ciwgZGF0ZVRpbWUubWludXRlLCBkYXRlVGltZS5zZWNvbmQsIGRhdGVUaW1lLm1pbGxpc2Vjb25kKTtcclxufVxyXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMihkYXRlLCBjYWxlbmRhcikge1xyXG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gY2FsZW5kYXIuaWRlbnRpZmllcikgcmV0dXJuIGRhdGU7XHJcbiAgICBsZXQgY2FsZW5kYXJEYXRlID0gY2FsZW5kYXIuZnJvbUp1bGlhbkRheShkYXRlLmNhbGVuZGFyLnRvSnVsaWFuRGF5KGRhdGUpKTtcclxuICAgIGxldCBjb3B5ID0gZGF0ZS5jb3B5KCk7XHJcbiAgICBjb3B5LmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICBjb3B5LmVyYSA9IGNhbGVuZGFyRGF0ZS5lcmE7XHJcbiAgICBjb3B5LnllYXIgPSBjYWxlbmRhckRhdGUueWVhcjtcclxuICAgIGNvcHkubW9udGggPSBjYWxlbmRhckRhdGUubW9udGg7XHJcbiAgICBjb3B5LmRheSA9IGNhbGVuZGFyRGF0ZS5kYXk7XHJcbiAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIpKGNvcHkpO1xyXG4gICAgcmV0dXJuIGNvcHk7XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDg0Yzk1YTgzYzc5OWUwNzQoZGF0ZSwgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uKSB7XHJcbiAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSkpIHtcclxuICAgICAgICBpZiAoZGF0ZS50aW1lWm9uZSA9PT0gdGltZVpvbmUpIHJldHVybiBkYXRlO1xyXG4gICAgICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NShkYXRlLCB0aW1lWm9uZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YyhkYXRlLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pO1xyXG4gICAgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKG1zLCB0aW1lWm9uZSk7XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDgzYWFjMDdiNGMzN2IyNShkYXRlKSB7XHJcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpIC0gZGF0ZS5vZmZzZXQ7XHJcbiAgICByZXR1cm4gbmV3IERhdGUobXMpO1xyXG59XHJcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MzhiMDAwMzNjYzExYzc1KGRhdGUsIHRpbWVab25lKSB7XHJcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpIC0gZGF0ZS5vZmZzZXQ7XHJcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMobXMsIHRpbWVab25lKSwgZGF0ZS5jYWxlbmRhcik7XHJcbn1cclxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQ5YjY3YmM5M2MwOTc0OTEoZGF0ZSkge1xyXG4gICAgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MzhiMDAwMzNjYzExYzc1KGRhdGUsICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSk7XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSID0gMzYwMDAwMDtcclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYoZGF0ZSwgZHVyYXRpb24pIHtcclxuICAgIGxldCBtdXRhYmxlRGF0ZSA9IGRhdGUuY29weSgpO1xyXG4gICAgbGV0IGRheXMgPSBcImhvdXJcIiBpbiBtdXRhYmxlRGF0ZSA/ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRUaW1lRmllbGRzKG11dGFibGVEYXRlLCBkdXJhdGlvbikgOiAwO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFllYXJzKG11dGFibGVEYXRlLCBkdXJhdGlvbi55ZWFycyB8fCAwKTtcclxuICAgIGlmIChtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKG11dGFibGVEYXRlLCBkYXRlKTtcclxuICAgIG11dGFibGVEYXRlLm1vbnRoICs9IGR1cmF0aW9uLm1vbnRocyB8fCAwO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VZZWFyTW9udGgobXV0YWJsZURhdGUpO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGNvbnN0cmFpbk1vbnRoRGF5KG11dGFibGVEYXRlKTtcclxuICAgIG11dGFibGVEYXRlLmRheSArPSAoZHVyYXRpb24ud2Vla3MgfHwgMCkgKiA3O1xyXG4gICAgbXV0YWJsZURhdGUuZGF5ICs9IGR1cmF0aW9uLmRheXMgfHwgMDtcclxuICAgIG11dGFibGVEYXRlLmRheSArPSBkYXlzO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VEYXkobXV0YWJsZURhdGUpO1xyXG4gICAgaWYgKG11dGFibGVEYXRlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlRGF0ZShtdXRhYmxlRGF0ZSk7XHJcbiAgICAvLyBDb25zdHJhaW4gaW4gY2FzZSBhZGRpbmcgZW5kZWQgdXAgd2l0aCBhIGRhdGUgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UgZm9yIHRoZSBjYWxlbmRhciBzeXN0ZW0uXHJcbiAgICAvLyBUaGUgYmVoYXZpb3IgaGVyZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiB3aGVuIGNvbnN0cmFpbmluZyBpbiB0aGUgYHNldGAgZnVuY3Rpb24gaW4gdGhhdFxyXG4gICAgLy8gd2UgYWRqdXN0IHNtYWxsZXIgZmllbGRzIHRvIHRoZWlyIG1pbmltdW0vbWF4aW11bSB2YWx1ZXMgcmF0aGVyIHRoYW4gY29uc3RyYWluaW5nIGVhY2ggZmllbGRcclxuICAgIC8vIGluZGl2aWR1YWxseS4gVGhpcyBtYXRjaGVzIHRoZSBnZW5lcmFsIGJlaGF2aW9yIG9mIGBhZGRgIHZzIGBzZXRgIHJlZ2FyZGluZyBob3cgZmllbGRzIGFyZSBiYWxhbmNlZC5cclxuICAgIGlmIChtdXRhYmxlRGF0ZS55ZWFyIDwgMSkge1xyXG4gICAgICAgIG11dGFibGVEYXRlLnllYXIgPSAxO1xyXG4gICAgICAgIG11dGFibGVEYXRlLm1vbnRoID0gMTtcclxuICAgICAgICBtdXRhYmxlRGF0ZS5kYXkgPSAxO1xyXG4gICAgfVxyXG4gICAgbGV0IG1heFllYXIgPSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRZZWFyc0luRXJhKG11dGFibGVEYXRlKTtcclxuICAgIGlmIChtdXRhYmxlRGF0ZS55ZWFyID4gbWF4WWVhcikge1xyXG4gICAgICAgIHZhciBfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLCBfbXV0YWJsZURhdGVfY2FsZW5kYXI7XHJcbiAgICAgICAgbGV0IGlzSW52ZXJzZUVyYSA9IChfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID0gKF9tdXRhYmxlRGF0ZV9jYWxlbmRhciA9IG11dGFibGVEYXRlLmNhbGVuZGFyKS5pc0ludmVyc2VFcmEpID09PSBudWxsIHx8IF9tdXRhYmxlRGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tdXRhYmxlRGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEuY2FsbChfbXV0YWJsZURhdGVfY2FsZW5kYXIsIG11dGFibGVEYXRlKTtcclxuICAgICAgICBtdXRhYmxlRGF0ZS55ZWFyID0gbWF4WWVhcjtcclxuICAgICAgICBtdXRhYmxlRGF0ZS5tb250aCA9IGlzSW52ZXJzZUVyYSA/IDEgOiBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIobXV0YWJsZURhdGUpO1xyXG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IGlzSW52ZXJzZUVyYSA/IDEgOiBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChtdXRhYmxlRGF0ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobXV0YWJsZURhdGUubW9udGggPCAxKSB7XHJcbiAgICAgICAgbXV0YWJsZURhdGUubW9udGggPSAxO1xyXG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IDE7XHJcbiAgICB9XHJcbiAgICBsZXQgbWF4TW9udGggPSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIobXV0YWJsZURhdGUpO1xyXG4gICAgaWYgKG11dGFibGVEYXRlLm1vbnRoID4gbWF4TW9udGgpIHtcclxuICAgICAgICBtdXRhYmxlRGF0ZS5tb250aCA9IG1heE1vbnRoO1xyXG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IG11dGFibGVEYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKG11dGFibGVEYXRlKTtcclxuICAgIH1cclxuICAgIG11dGFibGVEYXRlLmRheSA9IE1hdGgubWF4KDEsIE1hdGgubWluKG11dGFibGVEYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKG11dGFibGVEYXRlKSwgbXV0YWJsZURhdGUuZGF5KSk7XHJcbiAgICByZXR1cm4gbXV0YWJsZURhdGU7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFllYXJzKGRhdGUsIHllYXJzKSB7XHJcbiAgICB2YXIgX2RhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLCBfZGF0ZV9jYWxlbmRhcjtcclxuICAgIGlmICgoX2RhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID0gKF9kYXRlX2NhbGVuZGFyID0gZGF0ZS5jYWxlbmRhcikuaXNJbnZlcnNlRXJhKSA9PT0gbnVsbCB8fCBfZGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYS5jYWxsKF9kYXRlX2NhbGVuZGFyLCBkYXRlKSkgeWVhcnMgPSAteWVhcnM7XHJcbiAgICBkYXRlLnllYXIgKz0geWVhcnM7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VZZWFyTW9udGgoZGF0ZSkge1xyXG4gICAgd2hpbGUoZGF0ZS5tb250aCA8IDEpe1xyXG4gICAgICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRZZWFycyhkYXRlLCAtMSk7XHJcbiAgICAgICAgZGF0ZS5tb250aCArPSBkYXRlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcihkYXRlKTtcclxuICAgIH1cclxuICAgIGxldCBtb250aHNJblllYXIgPSAwO1xyXG4gICAgd2hpbGUoZGF0ZS5tb250aCA+IChtb250aHNJblllYXIgPSBkYXRlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcihkYXRlKSkpe1xyXG4gICAgICAgIGRhdGUubW9udGggLT0gbW9udGhzSW5ZZWFyO1xyXG4gICAgICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRZZWFycyhkYXRlLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZURheShkYXRlKSB7XHJcbiAgICB3aGlsZShkYXRlLmRheSA8IDEpe1xyXG4gICAgICAgIGRhdGUubW9udGgtLTtcclxuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChkYXRlKTtcclxuICAgICAgICBkYXRlLmRheSArPSBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpO1xyXG4gICAgfVxyXG4gICAgd2hpbGUoZGF0ZS5kYXkgPiBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKXtcclxuICAgICAgICBkYXRlLmRheSAtPSBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpO1xyXG4gICAgICAgIGRhdGUubW9udGgrKztcclxuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChkYXRlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY29uc3RyYWluTW9udGhEYXkoZGF0ZSkge1xyXG4gICAgZGF0ZS5tb250aCA9IE1hdGgubWF4KDEsIE1hdGgubWluKGRhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKGRhdGUpLCBkYXRlLm1vbnRoKSk7XHJcbiAgICBkYXRlLmRheSA9IE1hdGgubWF4KDEsIE1hdGgubWluKGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSksIGRhdGUuZGF5KSk7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIoZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuY29uc3RyYWluRGF0ZSkgZGF0ZS5jYWxlbmRhci5jb25zdHJhaW5EYXRlKGRhdGUpO1xyXG4gICAgZGF0ZS55ZWFyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZGF0ZS5jYWxlbmRhci5nZXRZZWFyc0luRXJhKGRhdGUpLCBkYXRlLnllYXIpKTtcclxuICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjb25zdHJhaW5Nb250aERheShkYXRlKTtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikge1xyXG4gICAgbGV0IGludmVyc2VEdXJhdGlvbiA9IHt9O1xyXG4gICAgZm9yKGxldCBrZXkgaW4gZHVyYXRpb24paWYgKHR5cGVvZiBkdXJhdGlvbltrZXldID09PSBcIm51bWJlclwiKSBpbnZlcnNlRHVyYXRpb25ba2V5XSA9IC1kdXJhdGlvbltrZXldO1xyXG4gICAgcmV0dXJuIGludmVyc2VEdXJhdGlvbjtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMyhkYXRlLCBkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlMTZkODUyMGFmNDRhMDk2KGRhdGUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQzZTI1NDRlODhhMjViZmY4KGR1cmF0aW9uKSk7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUoZGF0ZSwgZmllbGRzKSB7XHJcbiAgICBsZXQgbXV0YWJsZURhdGUgPSBkYXRlLmNvcHkoKTtcclxuICAgIGlmIChmaWVsZHMuZXJhICE9IG51bGwpIG11dGFibGVEYXRlLmVyYSA9IGZpZWxkcy5lcmE7XHJcbiAgICBpZiAoZmllbGRzLnllYXIgIT0gbnVsbCkgbXV0YWJsZURhdGUueWVhciA9IGZpZWxkcy55ZWFyO1xyXG4gICAgaWYgKGZpZWxkcy5tb250aCAhPSBudWxsKSBtdXRhYmxlRGF0ZS5tb250aCA9IGZpZWxkcy5tb250aDtcclxuICAgIGlmIChmaWVsZHMuZGF5ICE9IG51bGwpIG11dGFibGVEYXRlLmRheSA9IGZpZWxkcy5kYXk7XHJcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlRGF0ZSk7XHJcbiAgICByZXR1cm4gbXV0YWJsZURhdGU7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYodmFsdWUsIGZpZWxkcykge1xyXG4gICAgbGV0IG11dGFibGVWYWx1ZSA9IHZhbHVlLmNvcHkoKTtcclxuICAgIGlmIChmaWVsZHMuaG91ciAhPSBudWxsKSBtdXRhYmxlVmFsdWUuaG91ciA9IGZpZWxkcy5ob3VyO1xyXG4gICAgaWYgKGZpZWxkcy5taW51dGUgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLm1pbnV0ZSA9IGZpZWxkcy5taW51dGU7XHJcbiAgICBpZiAoZmllbGRzLnNlY29uZCAhPSBudWxsKSBtdXRhYmxlVmFsdWUuc2Vjb25kID0gZmllbGRzLnNlY29uZDtcclxuICAgIGlmIChmaWVsZHMubWlsbGlzZWNvbmQgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLm1pbGxpc2Vjb25kID0gZmllbGRzLm1pbGxpc2Vjb25kO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IobXV0YWJsZVZhbHVlKTtcclxuICAgIHJldHVybiBtdXRhYmxlVmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHRpbWUuc2Vjb25kICs9IE1hdGguZmxvb3IodGltZS5taWxsaXNlY29uZCAvIDEwMDApO1xyXG4gICAgdGltZS5taWxsaXNlY29uZCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLm1pbGxpc2Vjb25kLCAxMDAwKTtcclxuICAgIHRpbWUubWludXRlICs9IE1hdGguZmxvb3IodGltZS5zZWNvbmQgLyA2MCk7XHJcbiAgICB0aW1lLnNlY29uZCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLnNlY29uZCwgNjApO1xyXG4gICAgdGltZS5ob3VyICs9IE1hdGguZmxvb3IodGltZS5taW51dGUgLyA2MCk7XHJcbiAgICB0aW1lLm1pbnV0ZSA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLm1pbnV0ZSwgNjApO1xyXG4gICAgbGV0IGRheXMgPSBNYXRoLmZsb29yKHRpbWUuaG91ciAvIDI0KTtcclxuICAgIHRpbWUuaG91ciA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLmhvdXIsIDI0KTtcclxuICAgIHJldHVybiBkYXlzO1xyXG59XHJcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ3NTU1ZGUxZTA3MDUxMGNiKHRpbWUpIHtcclxuICAgIHRpbWUubWlsbGlzZWNvbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLm1pbGxpc2Vjb25kLCAxMDAwKSk7XHJcbiAgICB0aW1lLnNlY29uZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUuc2Vjb25kLCA1OSkpO1xyXG4gICAgdGltZS5taW51dGUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLm1pbnV0ZSwgNTkpKTtcclxuICAgIHRpbWUuaG91ciA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUuaG91ciwgMjMpKTtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkbm9uTmVnYXRpdmVNb2QoYSwgYikge1xyXG4gICAgbGV0IHJlc3VsdCA9IGEgJSBiO1xyXG4gICAgaWYgKHJlc3VsdCA8IDApIHJlc3VsdCArPSBiO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkVGltZUZpZWxkcyh0aW1lLCBkdXJhdGlvbikge1xyXG4gICAgdGltZS5ob3VyICs9IGR1cmF0aW9uLmhvdXJzIHx8IDA7XHJcbiAgICB0aW1lLm1pbnV0ZSArPSBkdXJhdGlvbi5taW51dGVzIHx8IDA7XHJcbiAgICB0aW1lLnNlY29uZCArPSBkdXJhdGlvbi5zZWNvbmRzIHx8IDA7XHJcbiAgICB0aW1lLm1pbGxpc2Vjb25kICs9IGR1cmF0aW9uLm1pbGxpc2Vjb25kcyB8fCAwO1xyXG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRiYWxhbmNlVGltZSh0aW1lKTtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkN2VkODdiNmJjMjUwNjQ3MCh0aW1lLCBkdXJhdGlvbikge1xyXG4gICAgbGV0IHJlcyA9IHRpbWUuY29weSgpO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFRpbWVGaWVsZHMocmVzLCBkdXJhdGlvbik7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRmZTM0ZDNhMzgxY2Q3NTAxKHRpbWUsIGR1cmF0aW9uKSB7XHJcbiAgICByZXR1cm4gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDdlZDg3YjZiYzI1MDY0NzAodGltZSwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDNlMjU0NGU4OGEyNWJmZjgoZHVyYXRpb24pKTtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0Yyh2YWx1ZSwgZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xyXG4gICAgbGV0IG11dGFibGUgPSB2YWx1ZS5jb3B5KCk7XHJcbiAgICBzd2l0Y2goZmllbGQpe1xyXG4gICAgICAgIGNhc2UgXCJlcmFcIjpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVyYXMgPSB2YWx1ZS5jYWxlbmRhci5nZXRFcmFzKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXJhSW5kZXggPSBlcmFzLmluZGV4T2YodmFsdWUuZXJhKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcmFJbmRleCA8IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXJhOiBcIiArIHZhbHVlLmVyYSk7XHJcbiAgICAgICAgICAgICAgICBlcmFJbmRleCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKGVyYUluZGV4LCBhbW91bnQsIDAsIGVyYXMubGVuZ3RoIC0gMSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKTtcclxuICAgICAgICAgICAgICAgIG11dGFibGUuZXJhID0gZXJhc1tlcmFJbmRleF07XHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW4gdGhlIHllYXIgYW5kIG90aGVyIGZpZWxkcyB3aXRoaW4gdGhlIGVyYSwgc28gdGhlIGVyYSBkb2Vzbid0IGNoYW5nZSB3aGVuIHdlIGJhbGFuY2UgYmVsb3cuXHJcbiAgICAgICAgICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICAgICAgdmFyIF9tdXRhYmxlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSwgX211dGFibGVfY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIGlmICgoX211dGFibGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID0gKF9tdXRhYmxlX2NhbGVuZGFyID0gbXV0YWJsZS5jYWxlbmRhcikuaXNJbnZlcnNlRXJhKSA9PT0gbnVsbCB8fCBfbXV0YWJsZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tdXRhYmxlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYS5jYWxsKF9tdXRhYmxlX2NhbGVuZGFyLCBtdXRhYmxlKSkgYW1vdW50ID0gLWFtb3VudDtcclxuICAgICAgICAgICAgLy8gVGhlIHllYXIgZmllbGQgc2hvdWxkIG5vdCBjeWNsZSB3aXRoaW4gdGhlIGVyYSBhcyB0aGF0IGNhbiBjYXVzZSB3ZWlyZCBiZWhhdmlvciBhZmZlY3Rpbmcgb3RoZXIgZmllbGRzLlxyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFsc28gYWxsb3cgdmFsdWVzIDwgMSBzbyB0aGF0IGRlY3JlbWVudGluZyBnb2VzIHRvIHRoZSBwcmV2aW91cyBlcmEuIElmIHdlIGdldCAtSW5maW5pdHkgYmFja1xyXG4gICAgICAgICAgICAvLyB3ZSBrbm93IHdlIHdyYXBwZWQgYXJvdW5kIGFmdGVyIHJlYWNoaW5nIDk5OTkgKHRoZSBtYXhpbXVtKSwgc28gc2V0IHRoZSB5ZWFyIGJhY2sgdG8gMS5cclxuICAgICAgICAgICAgbXV0YWJsZS55ZWFyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUueWVhciwgYW1vdW50LCAtSW5maW5pdHksIDk5OTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XHJcbiAgICAgICAgICAgIGlmIChtdXRhYmxlLnllYXIgPT09IC1JbmZpbml0eSkgbXV0YWJsZS55ZWFyID0gMTtcclxuICAgICAgICAgICAgaWYgKG11dGFibGUuY2FsZW5kYXIuYmFsYW5jZVllYXJNb250aCkgbXV0YWJsZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKG11dGFibGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgIG11dGFibGUubW9udGggPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5tb250aCwgYW1vdW50LCAxLCB2YWx1ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIodmFsdWUpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZGF5XCI6XHJcbiAgICAgICAgICAgIG11dGFibGUuZGF5ID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUuZGF5LCBhbW91bnQsIDEsIHZhbHVlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKHZhbHVlKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZmllbGQgXCIgKyBmaWVsZCk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUuY2FsZW5kYXIuYmFsYW5jZURhdGUpIHZhbHVlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKG11dGFibGUpO1xyXG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIobXV0YWJsZSk7XHJcbiAgICByZXR1cm4gbXV0YWJsZTtcclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZGQwMmIzZTAwMDdkZmUyOCh2YWx1ZSwgZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xyXG4gICAgbGV0IG11dGFibGUgPSB2YWx1ZS5jb3B5KCk7XHJcbiAgICBzd2l0Y2goZmllbGQpe1xyXG4gICAgICAgIGNhc2UgXCJob3VyXCI6XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBob3VycyA9IHZhbHVlLmhvdXI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gMDtcclxuICAgICAgICAgICAgICAgIGxldCBtYXggPSAyMztcclxuICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhvdXJDeWNsZSkgPT09IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUE0gPSBob3VycyA+PSAxMjtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBpc1BNID8gMTIgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGlzUE0gPyAyMyA6IDExO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbXV0YWJsZS5ob3VyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUoaG91cnMsIGFtb3VudCwgbWluLCBtYXgsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcclxuICAgICAgICAgICAgbXV0YWJsZS5taW51dGUgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5taW51dGUsIGFtb3VudCwgMCwgNTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcclxuICAgICAgICAgICAgbXV0YWJsZS5zZWNvbmQgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5zZWNvbmQsIGFtb3VudCwgMCwgNTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxyXG4gICAgICAgICAgICBtdXRhYmxlLm1pbGxpc2Vjb25kID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUubWlsbGlzZWNvbmQsIGFtb3VudCwgMCwgOTk5LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWVsZCBcIiArIGZpZWxkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtdXRhYmxlO1xyXG59XHJcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKHZhbHVlLCBhbW91bnQsIG1pbiwgbWF4LCByb3VuZCA9IGZhbHNlKSB7XHJcbiAgICBpZiAocm91bmQpIHtcclxuICAgICAgICB2YWx1ZSArPSBNYXRoLnNpZ24oYW1vdW50KTtcclxuICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHZhbHVlID0gbWF4O1xyXG4gICAgICAgIGxldCBkaXYgPSBNYXRoLmFicyhhbW91bnQpO1xyXG4gICAgICAgIGlmIChhbW91bnQgPiAwKSB2YWx1ZSA9IE1hdGguY2VpbCh2YWx1ZSAvIGRpdikgKiBkaXY7XHJcbiAgICAgICAgZWxzZSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyBkaXYpICogZGl2O1xyXG4gICAgICAgIGlmICh2YWx1ZSA+IG1heCkgdmFsdWUgPSBtaW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlICs9IGFtb3VudDtcclxuICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHZhbHVlID0gbWF4IC0gKG1pbiAtIHZhbHVlIC0gMSk7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHZhbHVlID0gbWluICsgKHZhbHVlIC0gbWF4IC0gMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDk2YjFkMjgzNDkyNzQ2MzcoZGF0ZVRpbWUsIGR1cmF0aW9uKSB7XHJcbiAgICBsZXQgbXM7XHJcbiAgICBpZiAoZHVyYXRpb24ueWVhcnMgIT0gbnVsbCAmJiBkdXJhdGlvbi55ZWFycyAhPT0gMCB8fCBkdXJhdGlvbi5tb250aHMgIT0gbnVsbCAmJiBkdXJhdGlvbi5tb250aHMgIT09IDAgfHwgZHVyYXRpb24ud2Vla3MgIT0gbnVsbCAmJiBkdXJhdGlvbi53ZWVrcyAhPT0gMCB8fCBkdXJhdGlvbi5kYXlzICE9IG51bGwgJiYgZHVyYXRpb24uZGF5cyAhPT0gMCkge1xyXG4gICAgICAgIGxldCByZXMgPSAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NigoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGRhdGVUaW1lKSwge1xyXG4gICAgICAgICAgICB5ZWFyczogZHVyYXRpb24ueWVhcnMsXHJcbiAgICAgICAgICAgIG1vbnRoczogZHVyYXRpb24ubW9udGhzLFxyXG4gICAgICAgICAgICB3ZWVrczogZHVyYXRpb24ud2Vla3MsXHJcbiAgICAgICAgICAgIGRheXM6IGR1cmF0aW9uLmRheXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDaGFuZ2luZyB0aGUgZGF0ZSBtYXkgY2hhbmdlIHRoZSB0aW1lem9uZSBvZmZzZXQsIHNvIHdlIG5lZWQgdG8gcmVjb21wdXRlXHJcbiAgICAgICAgLy8gdXNpbmcgdGhlICdjb21wYXRpYmxlJyBkaXNhbWJpZ3VhdGlvbi5cclxuICAgICAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykocmVzLCBkYXRlVGltZS50aW1lWm9uZSk7XHJcbiAgICB9IGVsc2UgLy8gT3RoZXJ3aXNlLCBwcmVzZXJ2ZSB0aGUgb2Zmc2V0IG9mIHRoZSBvcmlnaW5hbCBkYXRlLlxyXG4gICAgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYikoZGF0ZVRpbWUpIC0gZGF0ZVRpbWUub2Zmc2V0O1xyXG4gICAgLy8gUGVyZm9ybSB0aW1lIG1hbmlwdWxhdGlvbiBpbiBtaWxsaXNlY29uZHMgcmF0aGVyIHRoYW4gb24gdGhlIG9yaWdpbmFsIHRpbWUgZmllbGRzIHRvIGFjY291bnQgZm9yIERTVC5cclxuICAgIC8vIEZvciBleGFtcGxlLCBhZGRpbmcgb25lIGhvdXIgZHVyaW5nIGEgRFNUIHRyYW5zaXRpb24gbWF5IHJlc3VsdCBpbiB0aGUgaG91ciBmaWVsZCBzdGF5aW5nIHRoZSBzYW1lIG9yXHJcbiAgICAvLyBza2lwcGluZyBhbiBob3VyLiBUaGlzIHJlc3VsdHMgaW4gdGhlIG9mZnNldCBmaWVsZCBjaGFuZ2luZyB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICBtcyArPSBkdXJhdGlvbi5taWxsaXNlY29uZHMgfHwgMDtcclxuICAgIG1zICs9IChkdXJhdGlvbi5zZWNvbmRzIHx8IDApICogMTAwMDtcclxuICAgIG1zICs9IChkdXJhdGlvbi5taW51dGVzIHx8IDApICogNjAwMDA7XHJcbiAgICBtcyArPSAoZHVyYXRpb24uaG91cnMgfHwgMCkgKiAzNjAwMDAwO1xyXG4gICAgbGV0IHJlcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGVUaW1lLnRpbWVab25lKTtcclxuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKHJlcywgZGF0ZVRpbWUuY2FsZW5kYXIpO1xyXG59XHJcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ2ODE0Y2FhYzM0Y2EwM2M3KGRhdGVUaW1lLCBkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5NmIxZDI4MzQ5Mjc0NjM3KGRhdGVUaW1lLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xyXG59XHJcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5YTI5N2QxMTFmYzg2Yjc5KGRhdGVUaW1lLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XHJcbiAgICAvLyBGb3IgZGF0ZSBmaWVsZHMsIHdlIHdhbnQgdGhlIHRpbWUgdG8gcmVtYWluIGNvbnNpc3RlbnQgYW5kIHRoZSBVVEMgb2Zmc2V0IHRvIHBvdGVudGlhbGx5IGNoYW5nZSB0byBhY2NvdW50IGZvciBEU1QgY2hhbmdlcy5cclxuICAgIC8vIEZvciB0aW1lIGZpZWxkcywgd2Ugd2FudCB0aGUgdGltZSB0byBjaGFuZ2UgYnkgdGhlIGFtb3VudCBnaXZlbi4gVGhpcyBtYXkgcmVzdWx0IGluIHRoZSBob3VyIGZpZWxkIHN0YXlpbmcgdGhlIHNhbWUsIGJ1dCB0aGUgVVRDXHJcbiAgICAvLyBvZmZzZXQgY2hhbmdpbmcgaW4gdGhlIGNhc2Ugb2YgYSBiYWNrd2FyZCBEU1QgdHJhbnNpdGlvbiwgb3Igc2tpcHBpbmcgYW4gaG91ciBpbiB0aGUgY2FzZSBvZiBhIGZvcndhcmQgRFNUIHRyYW5zaXRpb24uXHJcbiAgICBzd2l0Y2goZmllbGQpe1xyXG4gICAgICAgIGNhc2UgXCJob3VyXCI6XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1heCA9IDIzO1xyXG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaG91ckN5Y2xlKSA9PT0gMTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNQTSA9IGRhdGVUaW1lLmhvdXIgPj0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gaXNQTSA/IDEyIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBpc1BNID8gMjMgOiAxMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGhvdXIgbWF5IGJlIGFmZmVjdGVkIGJ5IGRheWxpZ2h0IHNhdmluZyB0aW1lLlxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGl0IG1pZ2h0IGp1bXAgZm9yd2FyZCBhdCBtaWRuaWdodCwgYW5kIHNraXAgMWFtLlxyXG4gICAgICAgICAgICAgICAgLy8gT3IgaXQgbWlnaHQgZW5kIGF0IG1pZG5pZ2h0IGFuZCByZXBlYXQgdGhlIDExcG0gaG91ci4gVG8gaGFuZGxlIHRoaXMsIHdlIGdldFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvc3NpYmxlIGFic29sdXRlIHRpbWVzIGZvciB0aGUgbWluIGFuZCBtYXgsIGFuZCBmaW5kIHRoZSBtYXhpbXVtIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGlzIHdpdGhpbiB0aGUgY3VycmVudCBkYXkuXHJcbiAgICAgICAgICAgICAgICBsZXQgcGxhaW5EYXRlVGltZSA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1pbkRhdGUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKCQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlNWQ1ZTFjMTgyMmI2ZTU2KHBsYWluRGF0ZVRpbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICBob3VyOiBtaW5cclxuICAgICAgICAgICAgICAgIH0pLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5BYnNvbHV0ZSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKG1pbkRhdGUsIGRhdGVUaW1lLnRpbWVab25lLCBcImVhcmxpZXJcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShtaW5EYXRlLCBkYXRlVGltZS50aW1lWm9uZSwgXCJsYXRlclwiKVxyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKG1zKT0+KDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLmRheSA9PT0gbWluRGF0ZS5kYXkpWzBdO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1heERhdGUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKCQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlNWQ1ZTFjMTgyMmI2ZTU2KHBsYWluRGF0ZVRpbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICBob3VyOiBtYXhcclxuICAgICAgICAgICAgICAgIH0pLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBtYXhBYnNvbHV0ZSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKG1heERhdGUsIGRhdGVUaW1lLnRpbWVab25lLCBcImVhcmxpZXJcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShtYXhEYXRlLCBkYXRlVGltZS50aW1lWm9uZSwgXCJsYXRlclwiKVxyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKG1zKT0+KDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLmRheSA9PT0gbWF4RGF0ZS5kYXkpLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgaG91cnMgbWF5IHJlcGVhdCwgd2UgbmVlZCB0byBvcGVyYXRlIG9uIHRoZSBhYnNvbHV0ZSB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSBpbiBob3VycyBmcm9tIHRoZSBVbml4IGVwb2NoIHNvIHRoYXQgY3ljbGVWYWx1ZSB3b3JrcyBjb3JyZWN0bHksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBjb252ZXJ0ZWQgYmFjayB0byBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgICAgICAgICBsZXQgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYikoZGF0ZVRpbWUpIC0gZGF0ZVRpbWUub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihtcyAvICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRPTkVfSE9VUik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gbXMgJSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVI7XHJcbiAgICAgICAgICAgICAgICBtcyA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKGhvdXJzLCBhbW91bnQsIE1hdGguZmxvb3IobWluQWJzb2x1dGUgLyAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVIpLCBNYXRoLmZsb29yKG1heEFic29sdXRlIC8gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKSAqICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRPTkVfSE9VUiArIHJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgIC8vIE5vdyBjb21wdXRlIHRoZSBuZXcgdGltZXpvbmUgb2Zmc2V0LCBhbmQgY29udmVydCB0aGUgYWJzb2x1dGUgdGltZSBiYWNrIHRvIGxvY2FsIHRpbWUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlVGltZS50aW1lWm9uZSksIGRhdGVUaW1lLmNhbGVuZGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcclxuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XHJcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4KGRhdGVUaW1lLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFwiZXJhXCI6XHJcbiAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICBjYXNlIFwiZGF5XCI6XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YygoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGRhdGVUaW1lKSwgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKHJlcywgZGF0ZVRpbWUudGltZVpvbmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLCBkYXRlVGltZS5jYWxlbmRhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWVsZCBcIiArIGZpZWxkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkMzFiNTQzMGViMThiZTRmOChkYXRlVGltZSwgZmllbGRzLCBkaXNhbWJpZ3VhdGlvbikge1xyXG4gICAgLy8gU2V0IHRoZSBkYXRlL3RpbWUgZmllbGRzLCBhbmQgcmVjb21wdXRlIHRoZSBVVEMgb2Zmc2V0IHRvIGFjY291bnQgZm9yIERTVCBjaGFuZ2VzLlxyXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHZhbGlkYXRlIGJ5IGNvbnZlcnRpbmcgYmFjayB0byBhIGxvY2FsIHRpbWUgaW4gY2FzZSBob3VycyBhcmUgc2tpcHBlZCBkdXJpbmcgZm9yd2FyZCBEU1QgdHJhbnNpdGlvbnMuXHJcbiAgICBsZXQgcGxhaW5EYXRlVGltZSA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpO1xyXG4gICAgbGV0IHJlcyA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlNWQ1ZTFjMTgyMmI2ZTU2KCQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRhZGFhNGNmN2VmMWI2NWJlKHBsYWluRGF0ZVRpbWUsIGZpZWxkcyksIGZpZWxkcyk7XHJcbiAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHBsYWluIGRhdGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsLCByZXR1cm4gdGhlIG9yaWdpbmFsIHRpbWUuXHJcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb2Zmc2V0IHdoZW4gc2V0dGluZyB0aGUgdGltZSB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICAgIGlmIChyZXMuY29tcGFyZShwbGFpbkRhdGVUaW1lKSA9PT0gMCkgcmV0dXJuIGRhdGVUaW1lO1xyXG4gICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShyZXMsIGRhdGVUaW1lLnRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XHJcbiAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlVGltZS50aW1lWm9uZSksIGRhdGVUaW1lLmNhbGVuZGFyKTtcclxufVxyXG5cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBcclxuXHJcblxyXG5cclxuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJFRJTUVfUkUgPSAvXihcXGR7Mn0pKD86OihcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyhcXC5cXGQrKT8kLztcclxuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfUkUgPSAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pJC87XHJcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciREQVRFX1RJTUVfUkUgPSAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pKD86VChcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KFxcLlxcZCspPyQvO1xyXG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkWk9ORURfREFURV9USU1FX1JFID0gL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KSg/OlQoXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyhcXC5cXGQrKT8oPzooWystXVxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pP1xcWyguKj8pXFxdJC87XHJcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRBQlNPTFVURV9SRSA9IC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkoPzpUKFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oXFwuXFxkKyk/KD86KD86KFsrLV1cXGR7Mn0pKD86Oj8oXFxkezJ9KSk/KXxaKSQvO1xyXG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9USU1FX0RVUkFUSU9OX1JFID0gL14oKD88bmVnYXRpdmU+LSl8XFwrKT9QKCg/PHllYXJzPlxcZCopWSk/KCg/PG1vbnRocz5cXGQqKU0pPygoPzx3ZWVrcz5cXGQqKVcpPygoPzxkYXlzPlxcZCopRCk/KCg/PHRpbWU+VCkoKD88aG91cnM+XFxkKlsuLF0/XFxkezEsOX0pSCk/KCg/PG1pbnV0ZXM+XFxkKlsuLF0/XFxkezEsOX0pTSk/KCg/PHNlY29uZHM+XFxkKlsuLF0/XFxkezEsOX0pUyk/KT8kLztcclxuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHJlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzID0gW1xyXG4gICAgXCJob3Vyc1wiLFxyXG4gICAgXCJtaW51dGVzXCIsXHJcbiAgICBcInNlY29uZHNcIlxyXG5dO1xyXG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcmVxdWlyZWREdXJhdGlvbkdyb3VwcyA9IFtcclxuICAgIFwieWVhcnNcIixcclxuICAgIFwibW9udGhzXCIsXHJcbiAgICBcIndlZWtzXCIsXHJcbiAgICBcImRheXNcIixcclxuICAgIC4uLiRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uVGltZUdyb3Vwc1xyXG5dO1xyXG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYzk2OThlYzdmMDVhMDdlMSh2YWx1ZSkge1xyXG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkVElNRV9SRSk7XHJcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVNPIDg2MDEgdGltZSBzdHJpbmc6IFwiICsgdmFsdWUpO1xyXG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZikoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDAsIDIzKSwgbVsyXSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzJdLCAwLCA1OSkgOiAwLCBtWzNdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bM10sIDAsIDU5KSA6IDAsIG1bNF0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs0XSwgMCwgSW5maW5pdHkpICogMTAwMCA6IDApO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2Yjg2MjE2MGQyOTVjOGUodmFsdWUpIHtcclxuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfUkUpO1xyXG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIGRhdGUgc3RyaW5nOiBcIiArIHZhbHVlKTtcclxuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDAsIDk5OTkpLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxKTtcclxuICAgIGRhdGUuZGF5ID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bM10sIDAsIGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSkpO1xyXG4gICAgcmV0dXJuIGRhdGU7XHJcbn1cclxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDU4ODkzN2JjZDYwYWRlNTUodmFsdWUpIHtcclxuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfVElNRV9SRSk7XHJcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZzogXCIgKyB2YWx1ZSk7XHJcbiAgICBsZXQgZGF0ZSA9IG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYpKCRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzFdLCAxLCA5OTk5KSwgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMl0sIDEsIDEyKSwgMSwgbVs0XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzRdLCAwLCAyMykgOiAwLCBtWzVdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNV0sIDAsIDU5KSA6IDAsIG1bNl0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs2XSwgMCwgNTkpIDogMCwgbVs3XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzddLCAwLCBJbmZpbml0eSkgKiAxMDAwIDogMCk7XHJcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcclxuICAgIHJldHVybiBkYXRlO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmZDc4OTNmMDZlOTJhNmE0KHZhbHVlLCBkaXNhbWJpZ3VhdGlvbikge1xyXG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkWk9ORURfREFURV9USU1FX1JFKTtcclxuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nOiBcIiArIHZhbHVlKTtcclxuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSkoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDEsIDk5OTkpLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxLCBtWzEwXSwgMCwgbVs0XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzRdLCAwLCAyMykgOiAwLCBtWzVdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNV0sIDAsIDU5KSA6IDAsIG1bNl0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs2XSwgMCwgNTkpIDogMCwgbVs3XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzddLCAwLCBJbmZpbml0eSkgKiAxMDAwIDogMCk7XHJcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcclxuICAgIGxldCBwbGFpbkRhdGVUaW1lID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShkYXRlKTtcclxuICAgIGxldCBtcztcclxuICAgIGlmIChtWzhdKSB7XHJcbiAgICAgICAgdmFyIF9tXztcclxuICAgICAgICBkYXRlLm9mZnNldCA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzhdLCAtMjMsIDIzKSAqIDM2MDAwMDAgKyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoKF9tXyA9IG1bOV0pICE9PSBudWxsICYmIF9tXyAhPT0gdm9pZCAwID8gX21fIDogXCIwXCIsIDAsIDU5KSAqIDYwMDAwO1xyXG4gICAgICAgIG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIpKGRhdGUpIC0gZGF0ZS5vZmZzZXQ7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgb2Zmc2V0IGFnYWluc3QgcGFyc2VkIGRhdGUuXHJcbiAgICAgICAgbGV0IGFic29sdXRlcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMTM2ZjM4ZWZlN2NhZjU0OSkocGxhaW5EYXRlVGltZSwgZGF0ZS50aW1lWm9uZSk7XHJcbiAgICAgICAgaWYgKCFhYnNvbHV0ZXMuaW5jbHVkZXMobXMpKSB0aHJvdyBuZXcgRXJyb3IoYE9mZnNldCAkeyRmYWU5NzdhYWZjMzkzYzVjJHZhciRvZmZzZXRUb1N0cmluZyhkYXRlLm9mZnNldCl9IGlzIGludmFsaWQgZm9yICR7JGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDQyMjNkZTE0NzA4YWRjNjMoZGF0ZSl9IGluICR7ZGF0ZS50aW1lWm9uZX1gKTtcclxuICAgIH0gZWxzZSAvLyBDb252ZXJ0IHRvIGFic29sdXRlIGFuZCBiYWNrIHRvIGZpeCBpbnZhbGlkIHRpbWVzIGR1ZSB0byBEU1QuXHJcbiAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShwbGFpbkRhdGVUaW1lKSwgZGF0ZS50aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pO1xyXG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGUudGltZVpvbmUpO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1YWRmZGFiMDUxNjhjMjE5KHZhbHVlLCB0aW1lWm9uZSkge1xyXG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkQUJTT0xVVEVfUkUpO1xyXG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmc6IFwiICsgdmFsdWUpO1xyXG4gICAgbGV0IGRhdGUgPSBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKSgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsxXSwgMSwgOTk5OSksICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzJdLCAxLCAxMiksIDEsIHRpbWVab25lLCAwLCBtWzRdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNF0sIDAsIDIzKSA6IDAsIG1bNV0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs1XSwgMCwgNTkpIDogMCwgbVs2XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzZdLCAwLCA1OSkgOiAwLCBtWzddID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bN10sIDAsIEluZmluaXR5KSAqIDEwMDAgOiAwKTtcclxuICAgIGRhdGUuZGF5ID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bM10sIDAsIGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSkpO1xyXG4gICAgdmFyIF9tXztcclxuICAgIGlmIChtWzhdKSBkYXRlLm9mZnNldCA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzhdLCAtMjMsIDIzKSAqIDM2MDAwMDAgKyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoKF9tXyA9IG1bOV0pICE9PSBudWxsICYmIF9tXyAhPT0gdm9pZCAwID8gX21fIDogXCIwXCIsIDAsIDU5KSAqIDYwMDAwO1xyXG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NSkoZGF0ZSwgdGltZVpvbmUpO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ4ZTM4NDQzMjM2MmVkMGYwKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDVhZGZkYWIwNTE2OGMyMTkodmFsdWUsICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSk7XHJcbn1cclxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKHZhbHVlLCBtaW4sIG1heCkge1xyXG4gICAgbGV0IHZhbCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICBpZiAodmFsIDwgbWluIHx8IHZhbCA+IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIG91dCBvZiByYW5nZTogJHttaW59IDw9ICR7dmFsfSA8PSAke21heH1gKTtcclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGY1OWRlZTgyMjQ4ZjVhZDQodGltZSkge1xyXG4gICAgcmV0dXJuIGAke1N0cmluZyh0aW1lLmhvdXIpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcodGltZS5taW51dGUpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcodGltZS5zZWNvbmQpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke3RpbWUubWlsbGlzZWNvbmQgPyBTdHJpbmcodGltZS5taWxsaXNlY29uZCAvIDEwMDApLnNsaWNlKDEpIDogXCJcIn1gO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2MGRmZDc0YWE5Njc5MWJkKGRhdGUpIHtcclxuICAgIGxldCBncmVnb3JpYW5EYXRlID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShkYXRlLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcclxuICAgIHJldHVybiBgJHtTdHJpbmcoZ3JlZ29yaWFuRGF0ZS55ZWFyKS5wYWRTdGFydCg0LCBcIjBcIil9LSR7U3RyaW5nKGdyZWdvcmlhbkRhdGUubW9udGgpLnBhZFN0YXJ0KDIsIFwiMFwiKX0tJHtTdHJpbmcoZ3JlZ29yaWFuRGF0ZS5kYXkpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKGRhdGUpIHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBgJHskZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNjBkZmQ3NGFhOTY3OTFiZChkYXRlKX1UJHskZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkZjU5ZGVlODIyNDhmNWFkNChkYXRlKX1gO1xyXG59XHJcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJHZhciRvZmZzZXRUb1N0cmluZyhvZmZzZXQpIHtcclxuICAgIGxldCBzaWduID0gTWF0aC5zaWduKG9mZnNldCkgPCAwID8gXCItXCIgOiBcIitcIjtcclxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XHJcbiAgICBsZXQgb2Zmc2V0SG91cnMgPSBNYXRoLmZsb29yKG9mZnNldCAvIDM2MDAwMDApO1xyXG4gICAgbGV0IG9mZnNldE1pbnV0ZXMgPSBvZmZzZXQgJSAzNjAwMDAwIC8gNjAwMDA7XHJcbiAgICByZXR1cm4gYCR7c2lnbn0ke1N0cmluZyhvZmZzZXRIb3VycykucGFkU3RhcnQoMiwgXCIwXCIpfToke1N0cmluZyhvZmZzZXRNaW51dGVzKS5wYWRTdGFydCgyLCBcIjBcIil9YDtcclxufVxyXG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYmY3OWYxZWJmNGIxODc5MihkYXRlKSB7XHJcbiAgICByZXR1cm4gYCR7JGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDQyMjNkZTE0NzA4YWRjNjMoZGF0ZSl9JHskZmFlOTc3YWFmYzM5M2M1YyR2YXIkb2Zmc2V0VG9TdHJpbmcoZGF0ZS5vZmZzZXQpfVske2RhdGUudGltZVpvbmV9XWA7XHJcbn1cclxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGVjYWU4MjliYjM3NDdlYTYodmFsdWUpIHtcclxuICAgIHZhciBfbWF0Y2hfZ3JvdXBzLCBfbWF0Y2hfZ3JvdXBzMSwgX21hdGNoX2dyb3VwczIsIF9tYXRjaF9ncm91cHMzLCBfbWF0Y2hfZ3JvdXBzNCwgX21hdGNoX2dyb3VwczUsIF9tYXRjaF9ncm91cHM2LCBfbWF0Y2hfZ3JvdXBzNywgX21hdGNoX2dyb3Vwczg7XHJcbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKCRmYWU5NzdhYWZjMzkzYzVjJHZhciREQVRFX1RJTUVfRFVSQVRJT05fUkUpO1xyXG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcclxuICAgIGNvbnN0IHBhcnNlRHVyYXRpb25Hcm91cCA9IChncm91cCwgaXNOZWdhdGl2ZSwgbWluLCBtYXgpPT57XHJcbiAgICAgICAgaWYgKCFncm91cCkgcmV0dXJuIDA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IGlzTmVnYXRpdmUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWduICogJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKGdyb3VwLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSwgbWluLCBtYXgpO1xyXG4gICAgICAgIH0gY2F0Y2ggIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICEhKChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzLm5lZ2F0aXZlKTtcclxuICAgIGNvbnN0IGhhc1JlcXVpcmVkR3JvdXBzID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHJlcXVpcmVkRHVyYXRpb25Hcm91cHMuc29tZSgoZ3JvdXApPT57XHJcbiAgICAgICAgdmFyIF9tYXRjaF9ncm91cHM7XHJcbiAgICAgICAgcmV0dXJuIChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzW2dyb3VwXTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFoYXNSZXF1aXJlZEdyb3VwcykgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcclxuICAgIGNvbnN0IGR1cmF0aW9uU3RyaW5nSW5jbHVkZXNUaW1lID0gKF9tYXRjaF9ncm91cHMxID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczEudGltZTtcclxuICAgIGlmIChkdXJhdGlvblN0cmluZ0luY2x1ZGVzVGltZSkge1xyXG4gICAgICAgIGNvbnN0IGhhc1JlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHJlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzLnNvbWUoKGdyb3VwKT0+e1xyXG4gICAgICAgICAgICB2YXIgX21hdGNoX2dyb3VwcztcclxuICAgICAgICAgICAgcmV0dXJuIChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzW2dyb3VwXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWhhc1JlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZHVyYXRpb24gPSB7XHJcbiAgICAgICAgeWVhcnM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczIgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzMi55ZWFycywgaXNOZWdhdGl2ZSwgMCwgOTk5OSksXHJcbiAgICAgICAgbW9udGhzOiBwYXJzZUR1cmF0aW9uR3JvdXAoKF9tYXRjaF9ncm91cHMzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczMubW9udGhzLCBpc05lZ2F0aXZlLCAwLCAxMiksXHJcbiAgICAgICAgd2Vla3M6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczQgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNC53ZWVrcywgaXNOZWdhdGl2ZSwgMCwgSW5maW5pdHkpLFxyXG4gICAgICAgIGRheXM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczUgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNS5kYXlzLCBpc05lZ2F0aXZlLCAwLCAzMSksXHJcbiAgICAgICAgaG91cnM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczYgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNi5ob3VycywgaXNOZWdhdGl2ZSwgMCwgMjMpLFxyXG4gICAgICAgIG1pbnV0ZXM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczcgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNy5taW51dGVzLCBpc05lZ2F0aXZlLCAwLCA1OSksXHJcbiAgICAgICAgc2Vjb25kczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzOCA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM4LnNlY29uZHMsIGlzTmVnYXRpdmUsIDAsIDU5KVxyXG4gICAgfTtcclxuICAgIGlmIChkdXJhdGlvbi5ob3VycyAhPT0gdW5kZWZpbmVkICYmIGR1cmF0aW9uLmhvdXJzICUgMSAhPT0gMCAmJiAoZHVyYXRpb24ubWludXRlcyB8fCBkdXJhdGlvbi5zZWNvbmRzKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX0gLSBvbmx5IHRoZSBzbWFsbGVzdCB1bml0IGNhbiBiZSBmcmFjdGlvbmFsYCk7XHJcbiAgICBpZiAoZHVyYXRpb24ubWludXRlcyAhPT0gdW5kZWZpbmVkICYmIGR1cmF0aW9uLm1pbnV0ZXMgJSAxICE9PSAwICYmIGR1cmF0aW9uLnNlY29uZHMpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJU08gODYwMSBEdXJhdGlvbiBzdHJpbmc6ICR7dmFsdWV9IC0gb25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbGApO1xyXG4gICAgcmV0dXJuIGR1cmF0aW9uO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiAkMzVlYThkYjljYjJjY2I5MCR2YXIkc2hpZnRBcmdzKGFyZ3MpIHtcclxuICAgIGxldCBjYWxlbmRhciA9IHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiID8gYXJncy5zaGlmdCgpIDogbmV3ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykoKTtcclxuICAgIGxldCBlcmE7XHJcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIGVyYSA9IGFyZ3Muc2hpZnQoKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBlcmFzID0gY2FsZW5kYXIuZ2V0RXJhcygpO1xyXG4gICAgICAgIGVyYSA9IGVyYXNbZXJhcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIGxldCB5ZWFyID0gYXJncy5zaGlmdCgpO1xyXG4gICAgbGV0IG1vbnRoID0gYXJncy5zaGlmdCgpO1xyXG4gICAgbGV0IGRheSA9IGFyZ3Muc2hpZnQoKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgY2FsZW5kYXIsXHJcbiAgICAgICAgZXJhLFxyXG4gICAgICAgIHllYXIsXHJcbiAgICAgICAgbW9udGgsXHJcbiAgICAgICAgZGF5XHJcbiAgICBdO1xyXG59XHJcbnZhciAvLyBUaGlzIHByZXZlbnRzIFR5cGVTY3JpcHQgZnJvbSBhbGxvd2luZyBvdGhlciB0eXBlcyB3aXRoIHRoZSBzYW1lIGZpZWxkcyB0byBtYXRjaC5cclxuLy8gaS5lLiBhIFpvbmVkRGF0ZVRpbWUgc2hvdWxkIG5vdCBiZSBiZSBwYXNzYWJsZSB0byBhIHBhcmFtZXRlciB0aGF0IGV4cGVjdHMgQ2FsZW5kYXJEYXRlLlxyXG4vLyBJZiB0aGF0IGJlaGF2aW9yIGlzIGRlc2lyZWQsIHVzZSB0aGUgQW55Q2FsZW5kYXJEYXRlIGludGVyZmFjZSBpbnN0ZWFkLlxyXG4vLyBAdHMtaWdub3JlXHJcbiQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZSA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcclxuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYge1xyXG4gICAgLyoqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgZGF0ZS4gKi8gY29weSgpIHtcclxuICAgICAgICBpZiAodGhpcy5lcmEpIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYodGhpcy5jYWxlbmRhciwgdGhpcy5lcmEsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xyXG4gICAgICAgIGVsc2UgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0Zih0aGlzLmNhbGVuZGFyLCB0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIGFkZGVkIHRvIGl0LiAqLyBhZGQoZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlMTZkODUyMGFmNDRhMDk2KSh0aGlzLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBzdWJ0cmFjdGVkIGZyb20gaXQuICovIHN1YnRyYWN0KGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMykodGhpcywgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcykge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUpKHRoaXMsIGZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVgIHdpdGggdGhlIGdpdmVuIGZpZWxkIGFkanVzdGVkIGJ5IGEgc3BlY2lmaWVkIGFtb3VudC5cclxuICAgKiBXaGVuIHRoZSByZXN1bHRpbmcgdmFsdWUgcmVhY2hlcyB0aGUgbGltaXRzIG9mIHRoZSBmaWVsZCwgaXQgd3JhcHMgYXJvdW5kLlxyXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YykodGhpcywgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCwgd2l0aCB0aGUgdGltZSBzZXQgdG8gbWlkbmlnaHQgaW4gdGhlIGdpdmVuIHRpbWUgem9uZS4gKi8gdG9EYXRlKHRpbWVab25lKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZSkodGhpcywgdGltZVpvbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDYwZGZkNzRhYTk2NzkxYmQpKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbXBhcmVzIHRoaXMgZGF0ZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgZGF0ZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgZGF0ZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjg3ODFkZGYzMWMwMDkwZikodGhpcywgYik7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcclxuICAgICAgICAoMCwgJGNVVnVOJF8pKHRoaXMsICQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZSwge1xyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBbY2FsZW5kYXIsIGVyYSwgeWVhciwgbW9udGgsIGRheV0gPSAkMzVlYThkYjljYjJjY2I5MCR2YXIkc2hpZnRBcmdzKGFyZ3MpO1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICB0aGlzLmVyYSA9IGVyYTtcclxuICAgICAgICB0aGlzLnllYXIgPSB5ZWFyO1xyXG4gICAgICAgIHRoaXMubW9udGggPSBtb250aDtcclxuICAgICAgICB0aGlzLmRheSA9IGRheTtcclxuICAgICAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIpKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbnZhciAvLyBUaGlzIHByZXZlbnRzIFR5cGVTY3JpcHQgZnJvbSBhbGxvd2luZyBvdGhlciB0eXBlcyB3aXRoIHRoZSBzYW1lIGZpZWxkcyB0byBtYXRjaC5cclxuLy8gQHRzLWlnbm9yZVxyXG4kMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUxID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xyXG5jbGFzcyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkNjgwZWExOTZlZmZjZTVmIHtcclxuICAgIC8qKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHRpbWUuICovIGNvcHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkNjgwZWExOTZlZmZjZTVmKHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBhZGRlZCB0byBpdC4gKi8gYWRkKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkN2VkODdiNmJjMjUwNjQ3MCkodGhpcywgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRmZTM0ZDNhMzgxY2Q3NTAxKSh0aGlzLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIG5ldyBgVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcykge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYpKHRoaXMsIGZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGBUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXHJcbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIHZhbHVlIHJlYWNoZXMgdGhlIGxpbWl0cyBvZiB0aGUgZmllbGQsIGl0IHdyYXBzIGFyb3VuZC5cclxuICAgKi8gY3ljbGUoZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGRkMDJiM2UwMDA3ZGZlMjgpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSB0aW1lIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGY1OWRlZTgyMjQ4ZjVhZDQpKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbXBhcmVzIHRoaXMgdGltZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgdGltZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgdGltZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYzE5YTgwYTk3MjFiODBmNikodGhpcywgYik7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcihob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCwgbWlsbGlzZWNvbmQgPSAwKXtcclxuICAgICAgICAoMCwgJGNVVnVOJF8pKHRoaXMsICQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZTEsIHtcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmhvdXIgPSBob3VyO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gbWludXRlO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xyXG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcclxuICAgICAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IpKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbnZhciAvLyBUaGlzIHByZXZlbnRzIFR5cGVTY3JpcHQgZnJvbSBhbGxvd2luZyBvdGhlciB0eXBlcyB3aXRoIHRoZSBzYW1lIGZpZWxkcyB0byBtYXRjaC5cclxuLy8gQHRzLWlnbm9yZVxyXG4kMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUyID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xyXG5jbGFzcyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZiB7XHJcbiAgICAvKiogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBkYXRlLiAqLyBjb3B5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVyYSkgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2Zih0aGlzLmNhbGVuZGFyLCB0aGlzLmVyYSwgdGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubWlsbGlzZWNvbmQpO1xyXG4gICAgICAgIGVsc2UgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2Zih0aGlzLmNhbGVuZGFyLCB0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZHVyYXRpb24gYWRkZWQgdG8gaXQuICovIGFkZChkdXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYpKHRoaXMsIGR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBzdWJ0cmFjdGVkIGZyb20gaXQuICovIHN1YnRyYWN0KGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMykodGhpcywgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGZpZWxkcyBzZXQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy4gT3RoZXIgZmllbGRzIHdpbGwgYmUgY29uc3RyYWluZWQgYWNjb3JkaW5nbHkuICovIHNldChmaWVsZHMpIHtcclxuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRhZGFhNGNmN2VmMWI2NWJlKSgoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYpKHRoaXMsIGZpZWxkcyksIGZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXHJcbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIHZhbHVlIHJlYWNoZXMgdGhlIGxpbWl0cyBvZiB0aGUgZmllbGQsIGl0IHdyYXBzIGFyb3VuZC5cclxuICAgKi8gY3ljbGUoZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHN3aXRjaChmaWVsZCl7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlcmFcIjpcclxuICAgICAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGMpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZGQwMmIzZTAwMDdkZmUyOCkodGhpcywgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGEgbmF0aXZlIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QgaW4gdGhlIGdpdmVuIHRpbWUgem9uZS4gKi8gdG9EYXRlKHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbikge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU2N2EwOTVjNjIwYjg2ZmUpKHRoaXMsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZy4gKi8gdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNDIyM2RlMTQ3MDhhZGM2MykodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ29tcGFyZXMgdGhpcyBkYXRlIHdpdGggYW5vdGhlci4gQSBuZWdhdGl2ZSByZXN1bHQgaW5kaWNhdGVzIHRoYXQgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgZ2l2ZW4gb25lLCBhbmQgYSBwb3NpdGl2ZSBkYXRlIGluZGljYXRlcyB0aGF0IGl0IGlzIGFmdGVyLiAqLyBjb21wYXJlKGIpIHtcclxuICAgICAgICBsZXQgcmVzID0gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2ODc4MWRkZjMxYzAwOTBmKSh0aGlzLCBiKTtcclxuICAgICAgICBpZiAocmVzID09PSAwKSByZXR1cm4gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRjMTlhODBhOTcyMWI4MGY2KSh0aGlzLCAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGIpKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgKDAsICRjVVZ1TiRfKSh0aGlzLCAkMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUyLCB7XHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IFtjYWxlbmRhciwgZXJhLCB5ZWFyLCBtb250aCwgZGF5XSA9ICQzNWVhOGRiOWNiMmNjYjkwJHZhciRzaGlmdEFyZ3MoYXJncyk7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuZXJhID0gZXJhO1xyXG4gICAgICAgIHRoaXMueWVhciA9IHllYXI7XHJcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xyXG4gICAgICAgIHRoaXMuZGF5ID0gZGF5O1xyXG4gICAgICAgIHRoaXMuaG91ciA9IGFyZ3Muc2hpZnQoKSB8fCAwO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gYXJncy5zaGlmdCgpIHx8IDA7XHJcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcclxuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gYXJncy5zaGlmdCgpIHx8IDA7XHJcbiAgICAgICAgKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKSh0aGlzKTtcclxuICAgIH1cclxufVxyXG52YXIgLy8gVGhpcyBwcmV2ZW50cyBUeXBlU2NyaXB0IGZyb20gYWxsb3dpbmcgb3RoZXIgdHlwZXMgd2l0aCB0aGUgc2FtZSBmaWVsZHMgdG8gbWF0Y2guXHJcbi8vIEB0cy1pZ25vcmVcclxuJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMyA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcclxuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEge1xyXG4gICAgLyoqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgZGF0ZS4gKi8gY29weSgpIHtcclxuICAgICAgICBpZiAodGhpcy5lcmEpIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEodGhpcy5jYWxlbmRhciwgdGhpcy5lcmEsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMudGltZVpvbmUsIHRoaXMub2Zmc2V0LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3ICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKHRoaXMuY2FsZW5kYXIsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMudGltZVpvbmUsIHRoaXMub2Zmc2V0LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIG5ldyBgWm9uZWREYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZHVyYXRpb24gYWRkZWQgdG8gaXQuICovIGFkZChkdXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDk2YjFkMjgzNDkyNzQ2MzcpKHRoaXMsIGR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBzdWJ0cmFjdGVkIGZyb20gaXQuICovIHN1YnRyYWN0KGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNjgxNGNhYWMzNGNhMDNjNykodGhpcywgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFpvbmVkRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGZpZWxkcyBzZXQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy4gT3RoZXIgZmllbGRzIHdpbGwgYmUgY29uc3RyYWluZWQgYWNjb3JkaW5nbHkuICovIHNldChmaWVsZHMsIGRpc2FtYmlndWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkMzFiNTQzMGViMThiZTRmOCkodGhpcywgZmllbGRzLCBkaXNhbWJpZ3VhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXHJcbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIHZhbHVlIHJlYWNoZXMgdGhlIGxpbWl0cyBvZiB0aGUgZmllbGQsIGl0IHdyYXBzIGFyb3VuZC5cclxuICAgKi8gY3ljbGUoZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDlhMjk3ZDExMWZjODZiNzkpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGEgbmF0aXZlIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuICovIHRvRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ4M2FhYzA3YjRjMzdiMjUpKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcsIGluY2x1ZGluZyB0aGUgVVRDIG9mZnNldCBhbmQgdGltZSB6b25lIGlkZW50aWZpZXIuICovIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGJmNzlmMWViZjRiMTg3OTIpKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcgaW4gVVRDLiAqLyB0b0Fic29sdXRlU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKiogQ29tcGFyZXMgdGhpcyBkYXRlIHdpdGggYW5vdGhlci4gQSBuZWdhdGl2ZSByZXN1bHQgaW5kaWNhdGVzIHRoYXQgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgZ2l2ZW4gb25lLCBhbmQgYSBwb3NpdGl2ZSBkYXRlIGluZGljYXRlcyB0aGF0IGl0IGlzIGFmdGVyLiAqLyBjb21wYXJlKGIpIHtcclxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGEgYmFkIGlkZWE/P1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLmdldFRpbWUoKSAtICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkODRjOTVhODNjNzk5ZTA3NCkoYiwgdGhpcy50aW1lWm9uZSkudG9EYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgKDAsICRjVVZ1TiRfKSh0aGlzLCAkMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUzLCB7XHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IFtjYWxlbmRhciwgZXJhLCB5ZWFyLCBtb250aCwgZGF5XSA9ICQzNWVhOGRiOWNiMmNjYjkwJHZhciRzaGlmdEFyZ3MoYXJncyk7XHJcbiAgICAgICAgbGV0IHRpbWVab25lID0gYXJncy5zaGlmdCgpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBhcmdzLnNoaWZ0KCk7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuZXJhID0gZXJhO1xyXG4gICAgICAgIHRoaXMueWVhciA9IHllYXI7XHJcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xyXG4gICAgICAgIHRoaXMuZGF5ID0gZGF5O1xyXG4gICAgICAgIHRoaXMudGltZVpvbmUgPSB0aW1lWm9uZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICB0aGlzLmhvdXIgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcclxuICAgICAgICB0aGlzLm1pbnV0ZSA9IGFyZ3Muc2hpZnQoKSB8fCAwO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kID0gYXJncy5zaGlmdCgpIHx8IDA7XHJcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGFyZ3Muc2hpZnQoKSB8fCAwO1xyXG4gICAgICAgICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMikodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gdGhlIFRDMzkgVGVtcG9yYWwgcHJvcG9zYWwuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuXHJcbmNvbnN0ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVMgPSBbXHJcbiAgICBbXHJcbiAgICAgICAgMTg2OCxcclxuICAgICAgICA5LFxyXG4gICAgICAgIDhcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTkxMixcclxuICAgICAgICA3LFxyXG4gICAgICAgIDMwXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDE5MjYsXHJcbiAgICAgICAgMTIsXHJcbiAgICAgICAgMjVcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTk4OSxcclxuICAgICAgICAxLFxyXG4gICAgICAgIDhcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMjAxOSxcclxuICAgICAgICA1LFxyXG4gICAgICAgIDFcclxuICAgIF1cclxuXTtcclxuY29uc3QgJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9FTkRfREFURVMgPSBbXHJcbiAgICBbXHJcbiAgICAgICAgMTkxMixcclxuICAgICAgICA3LFxyXG4gICAgICAgIDI5XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDE5MjYsXHJcbiAgICAgICAgMTIsXHJcbiAgICAgICAgMjRcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTk4OSxcclxuICAgICAgICAxLFxyXG4gICAgICAgIDdcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMjAxOSxcclxuICAgICAgICA0LFxyXG4gICAgICAgIDMwXHJcbiAgICBdXHJcbl07XHJcbmNvbnN0ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EUyA9IFtcclxuICAgIDE4NjcsXHJcbiAgICAxOTExLFxyXG4gICAgMTkyNSxcclxuICAgIDE5ODgsXHJcbiAgICAyMDE4XHJcbl07XHJcbmNvbnN0ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVMgPSBbXHJcbiAgICBcIm1laWppXCIsXHJcbiAgICBcInRhaXNob1wiLFxyXG4gICAgXCJzaG93YVwiLFxyXG4gICAgXCJoZWlzZWlcIixcclxuICAgIFwicmVpd2FcIlxyXG5dO1xyXG5mdW5jdGlvbiAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZmluZEVyYUZyb21HcmVnb3JpYW5EYXRlKGRhdGUpIHtcclxuICAgIGNvbnN0IGlkeCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVMuZmluZEluZGV4KChbeWVhciwgbW9udGgsIGRheV0pPT57XHJcbiAgICAgICAgaWYgKGRhdGUueWVhciA8IHllYXIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChkYXRlLnllYXIgPT09IHllYXIgJiYgZGF0ZS5tb250aCA8IG1vbnRoKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoZGF0ZS55ZWFyID09PSB5ZWFyICYmIGRhdGUubW9udGggPT09IG1vbnRoICYmIGRhdGUuZGF5IDwgZGF5KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuICAgIGlmIChpZHggPT09IC0xKSByZXR1cm4gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9TVEFSVF9EQVRFUy5sZW5ndGggLSAxO1xyXG4gICAgaWYgKGlkeCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gaWR4IC0gMTtcclxufVxyXG5mdW5jdGlvbiAkNjIyMjUwMDgwMjBmMGExMyR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkge1xyXG4gICAgbGV0IGVyYUFkZGVuZCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EU1skNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTLmluZGV4T2YoZGF0ZS5lcmEpXTtcclxuICAgIGlmICghZXJhQWRkZW5kKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVyYTogXCIgKyBkYXRlLmVyYSk7XHJcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZGF0ZS55ZWFyICsgZXJhQWRkZW5kLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XHJcbn1cclxuY2xhc3MgJDYyMjI1MDA4MDIwZjBhMTMkZXhwb3J0JGI3NDZhYjJiNjBjZGZmYmYgZXh0ZW5kcyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xyXG4gICAgICAgIGxldCBlcmEgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZmluZEVyYUZyb21HcmVnb3JpYW5EYXRlKGRhdGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTW2VyYV0sIGRhdGUueWVhciAtICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EU1tlcmFdLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XHJcbiAgICB9XHJcbiAgICB0b0p1bGlhbkRheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvSnVsaWFuRGF5KCQ2MjIyNTAwODAyMGYwYTEzJHZhciR0b0dyZWdvcmlhbihkYXRlKSk7XHJcbiAgICB9XHJcbiAgICBiYWxhbmNlRGF0ZShkYXRlKSB7XHJcbiAgICAgICAgbGV0IGdyZWdvcmlhbkRhdGUgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkdG9HcmVnb3JpYW4oZGF0ZSk7XHJcbiAgICAgICAgbGV0IGVyYSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRmaW5kRXJhRnJvbUdyZWdvcmlhbkRhdGUoZ3JlZ29yaWFuRGF0ZSk7XHJcbiAgICAgICAgaWYgKCQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVNbZXJhXSAhPT0gZGF0ZS5lcmEpIHtcclxuICAgICAgICAgICAgZGF0ZS5lcmEgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTW2VyYV07XHJcbiAgICAgICAgICAgIGRhdGUueWVhciA9IGdyZWdvcmlhbkRhdGUueWVhciAtICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EU1tlcmFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb25zdHJhaW4gaW4gY2FzZSB3ZSB3ZW50IGJlZm9yZSB0aGUgZmlyc3Qgc3VwcG9ydGVkIGVyYS5cclxuICAgICAgICB0aGlzLmNvbnN0cmFpbkRhdGUoZGF0ZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJhaW5EYXRlKGRhdGUpIHtcclxuICAgICAgICBsZXQgaWR4ID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9OQU1FUy5pbmRleE9mKGRhdGUuZXJhKTtcclxuICAgICAgICBsZXQgZW5kID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9FTkRfREFURVNbaWR4XTtcclxuICAgICAgICBpZiAoZW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IFtlbmRZZWFyLCBlbmRNb250aCwgZW5kRGF5XSA9IGVuZDtcclxuICAgICAgICAgICAgLy8gQ29uc3RyYWluIHRoZSB5ZWFyIHRvIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIGluIHRoZSBlcmEuXHJcbiAgICAgICAgICAgIC8vIFRoZW4gY29uc3RyYWluIHRoZSBtb250aCBhbmQgZGF5IGZpZWxkcyB3aXRoaW4gdGhhdC5cclxuICAgICAgICAgICAgbGV0IG1heFllYXIgPSBlbmRZZWFyIC0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9BRERFTkRTW2lkeF07XHJcbiAgICAgICAgICAgIGRhdGUueWVhciA9IE1hdGgubWF4KDEsIE1hdGgubWluKG1heFllYXIsIGRhdGUueWVhcikpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS55ZWFyID09PSBtYXhZZWFyKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlLm1vbnRoID0gTWF0aC5taW4oZW5kTW9udGgsIGRhdGUubW9udGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUubW9udGggPT09IGVuZE1vbnRoKSBkYXRlLmRheSA9IE1hdGgubWluKGVuZERheSwgZGF0ZS5kYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlLnllYXIgPT09IDEgJiYgaWR4ID49IDApIHtcclxuICAgICAgICAgICAgbGV0IFssIHN0YXJ0TW9udGgsIHN0YXJ0RGF5XSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVNbaWR4XTtcclxuICAgICAgICAgICAgZGF0ZS5tb250aCA9IE1hdGgubWF4KHN0YXJ0TW9udGgsIGRhdGUubW9udGgpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS5tb250aCA9PT0gc3RhcnRNb250aCkgZGF0ZS5kYXkgPSBNYXRoLm1heChzdGFydERheSwgZGF0ZS5kYXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVM7XHJcbiAgICB9XHJcbiAgICBnZXRZZWFyc0luRXJhKGRhdGUpIHtcclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiB5ZWFycyBpbiB0aGUgZXJhLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBkYXRlJ3MgbW9udGggYW5kIGRheSBmaWVsZHMuXHJcbiAgICAgICAgbGV0IGVyYSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVMuaW5kZXhPZihkYXRlLmVyYSk7XHJcbiAgICAgICAgbGV0IGN1ciA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVNbZXJhXTtcclxuICAgICAgICBsZXQgbmV4dCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVNbZXJhICsgMV07XHJcbiAgICAgICAgaWYgKG5leHQgPT0gbnVsbCkgLy8gOTk5OSBncmVnb3JpYW4gaXMgdGhlIG1heGltdW0geWVhciBhbGxvd2VkLlxyXG4gICAgICAgIHJldHVybiA5OTk5IC0gY3VyWzBdICsgMTtcclxuICAgICAgICBsZXQgeWVhcnMgPSBuZXh0WzBdIC0gY3VyWzBdO1xyXG4gICAgICAgIGlmIChkYXRlLm1vbnRoIDwgbmV4dFsxXSB8fCBkYXRlLm1vbnRoID09PSBuZXh0WzFdICYmIGRhdGUuZGF5IDwgbmV4dFsyXSkgeWVhcnMrKztcclxuICAgICAgICByZXR1cm4geWVhcnM7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldERheXNJbk1vbnRoKCQ2MjIyNTAwODAyMGYwYTEzJHZhciR0b0dyZWdvcmlhbihkYXRlKSk7XHJcbiAgICB9XHJcbiAgICBnZXRNaW5pbXVtTW9udGhJblllYXIoZGF0ZSkge1xyXG4gICAgICAgIGxldCBzdGFydCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRnZXRNaW5pbXVtcyhkYXRlKTtcclxuICAgICAgICByZXR1cm4gc3RhcnQgPyBzdGFydFsxXSA6IDE7XHJcbiAgICB9XHJcbiAgICBnZXRNaW5pbXVtRGF5SW5Nb250aChkYXRlKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJGdldE1pbmltdW1zKGRhdGUpO1xyXG4gICAgICAgIHJldHVybiBzdGFydCAmJiBkYXRlLm1vbnRoID09PSBzdGFydFsxXSA/IHN0YXJ0WzJdIDogMTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiamFwYW5lc2VcIjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZ2V0TWluaW11bXMoZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUueWVhciA9PT0gMSkge1xyXG4gICAgICAgIGxldCBpZHggPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTLmluZGV4T2YoZGF0ZS5lcmEpO1xyXG4gICAgICAgIHJldHVybiAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX1NUQVJUX0RBVEVTW2lkeF07XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSBJQ1UuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuXHJcbmNvbnN0ICQ4ZDczZDQ3NDIyY2E3MzAyJHZhciRCVURESElTVF9FUkFfU1RBUlQgPSAtNTQzO1xyXG5jbGFzcyAkOGQ3M2Q0NzQyMmNhNzMwMiRleHBvcnQkNDJkMjBhNzgzMDFkZWU0NCBleHRlbmRzICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykge1xyXG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xyXG4gICAgICAgIGxldCBncmVnb3JpYW5EYXRlID0gc3VwZXIuZnJvbUp1bGlhbkRheShqZCk7XHJcbiAgICAgICAgbGV0IHllYXIgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQpKGdyZWdvcmlhbkRhdGUuZXJhLCBncmVnb3JpYW5EYXRlLnllYXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCB5ZWFyIC0gJDhkNzNkNDc0MjJjYTczMDIkdmFyJEJVRERISVNUX0VSQV9TVEFSVCwgZ3JlZ29yaWFuRGF0ZS5tb250aCwgZ3JlZ29yaWFuRGF0ZS5kYXkpO1xyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci50b0p1bGlhbkRheSgkOGQ3M2Q0NzQyMmNhNzMwMiR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXJhcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBcIkJFXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZ2V0RGF5c0luTW9udGgoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5nZXREYXlzSW5Nb250aCgkOGQ3M2Q0NzQyMmNhNzMwMiR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgYmFsYW5jZURhdGUoKSB7fVxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJidWRkaGlzdFwiO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uICQ4ZDczZDQ3NDIyY2E3MzAyJHZhciR0b0dyZWdvcmlhbihkYXRlKSB7XHJcbiAgICBsZXQgW2VyYSwgeWVhcl0gPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDQ0NzViN2U2MTdlYjEyM2MpKGRhdGUueWVhciArICQ4ZDczZDQ3NDIyY2E3MzAyJHZhciRCVURESElTVF9FUkFfU1RBUlQpO1xyXG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKGVyYSwgeWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxyXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgY2FuIGJlIGZvdW5kIGluIHRoZSBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuXHJcblxyXG5jb25zdCAkNWYzMWJkNmYwYzg5NDBiMiR2YXIkVEFJV0FOX0VSQV9TVEFSVCA9IDE5MTE7XHJcbmZ1bmN0aW9uICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5ZZWFyKGRhdGUpIHtcclxuICAgIHJldHVybiBkYXRlLmVyYSA9PT0gXCJtaW5ndW9cIiA/IGRhdGUueWVhciArICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRUQUlXQU5fRVJBX1NUQVJUIDogMSAtIGRhdGUueWVhciArICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRUQUlXQU5fRVJBX1NUQVJUO1xyXG59XHJcbmZ1bmN0aW9uICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5Ub1RhaXdhbih5ZWFyKSB7XHJcbiAgICBsZXQgeSA9IHllYXIgLSAkNWYzMWJkNmYwYzg5NDBiMiR2YXIkVEFJV0FOX0VSQV9TVEFSVDtcclxuICAgIGlmICh5ID4gMCkgcmV0dXJuIFtcclxuICAgICAgICBcIm1pbmd1b1wiLFxyXG4gICAgICAgIHlcclxuICAgIF07XHJcbiAgICBlbHNlIHJldHVybiBbXHJcbiAgICAgICAgXCJiZWZvcmVfbWluZ3VvXCIsXHJcbiAgICAgICAgMSAtIHlcclxuICAgIF07XHJcbn1cclxuY2xhc3MgJDVmMzFiZDZmMGM4OTQwYjIkZXhwb3J0JDY1ZTAxMDgwYWZjYjA3OTkgZXh0ZW5kcyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xyXG4gICAgICAgIGxldCBleHRlbmRlZFllYXIgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQpKGRhdGUuZXJhLCBkYXRlLnllYXIpO1xyXG4gICAgICAgIGxldCBbZXJhLCB5ZWFyXSA9ICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5Ub1RhaXdhbihleHRlbmRlZFllYXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBlcmEsIHllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcclxuICAgIH1cclxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIudG9KdWxpYW5EYXkoJDVmMzFiZDZmMGM4OTQwYjIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpKTtcclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgXCJiZWZvcmVfbWluZ3VvXCIsXHJcbiAgICAgICAgICAgIFwibWluZ3VvXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYmFsYW5jZURhdGUoZGF0ZSkge1xyXG4gICAgICAgIGxldCBbZXJhLCB5ZWFyXSA9ICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5Ub1RhaXdhbigkNWYzMWJkNmYwYzg5NDBiMiR2YXIkZ3JlZ29yaWFuWWVhcihkYXRlKSk7XHJcbiAgICAgICAgZGF0ZS5lcmEgPSBlcmE7XHJcbiAgICAgICAgZGF0ZS55ZWFyID0geWVhcjtcclxuICAgIH1cclxuICAgIGlzSW52ZXJzZUVyYShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcImJlZm9yZV9taW5ndW9cIjtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0RGF5c0luTW9udGgoJDVmMzFiZDZmMGM4OTQwYjIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpKTtcclxuICAgIH1cclxuICAgIGdldFllYXJzSW5FcmEoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRlLmVyYSA9PT0gXCJiZWZvcmVfbWluZ3VvXCIgPyA5OTk5IDogOTk5OSAtICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRUQUlXQU5fRVJBX1NUQVJUO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJyb2NcIiAvLyBSZXB1YmxpYyBvZiBDaGluYVxyXG4gICAgICAgIDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNWYzMWJkNmYwYzg5NDBiMiR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkge1xyXG4gICAgbGV0IFtlcmEsIHllYXJdID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjKSgkNWYzMWJkNmYwYzg5NDBiMiR2YXIkZ3JlZ29yaWFuWWVhcihkYXRlKSk7XHJcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZXJhLCB5ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSBJQ1UuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuXHJcbmNvbnN0ICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRQRVJTSUFOX0VQT0NIID0gMTk0ODMyMTsgLy8gNjIyLzAzLzE5IEp1bGlhbiBDLkUuXHJcbmZ1bmN0aW9uICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRpc0xlYXBZZWFyKHllYXIpIHtcclxuICAgIGxldCB5MCA9IHllYXIgPiAwID8geWVhciAtIDQ3NCA6IHllYXIgLSA0NzM7XHJcbiAgICBsZXQgeTEgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKHkwLCAyODIwKSArIDQ3NDtcclxuICAgIHJldHVybiAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKCh5MSArIDM4KSAqIDMxLCAxMjgpIDwgMzE7XHJcbn1cclxuZnVuY3Rpb24gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJHBlcnNpYW5Ub0p1bGlhbkRheSh5ZWFyLCBtb250aCwgZGF5KSB7XHJcbiAgICBsZXQgeTAgPSB5ZWFyID4gMCA/IHllYXIgLSA0NzQgOiB5ZWFyIC0gNDczO1xyXG4gICAgbGV0IHkxID0gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKSh5MCwgMjgyMCkgKyA0NzQ7XHJcbiAgICBsZXQgb2Zmc2V0ID0gbW9udGggPD0gNyA/IDMxICogKG1vbnRoIC0gMSkgOiAzMCAqIChtb250aCAtIDEpICsgNjtcclxuICAgIHJldHVybiAkZjNlZDJlNDQ3MmFlN2UyNSR2YXIkUEVSU0lBTl9FUE9DSCAtIDEgKyAxMDI5OTgzICogTWF0aC5mbG9vcih5MCAvIDI4MjApICsgMzY1ICogKHkxIC0gMSkgKyBNYXRoLmZsb29yKCgzMSAqIHkxIC0gNSkgLyAxMjgpICsgb2Zmc2V0ICsgZGF5O1xyXG59XHJcbmNsYXNzICRmM2VkMmU0NDcyYWU3ZTI1JGV4cG9ydCQzN2ZjY2RiZmQxNGM1OTM5IHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgZDAgPSBqZCAtICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRwZXJzaWFuVG9KdWxpYW5EYXkoNDc1LCAxLCAxKTtcclxuICAgICAgICBsZXQgbjI4MjAgPSBNYXRoLmZsb29yKGQwIC8gMTAyOTk4Myk7XHJcbiAgICAgICAgbGV0IGQxID0gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKShkMCwgMTAyOTk4Myk7XHJcbiAgICAgICAgbGV0IHkyODIwID0gZDEgPT09IDEwMjk5ODIgPyAyODIwIDogTWF0aC5mbG9vcigoMTI4ICogZDEgKyA0Njg3OCkgLyA0Njc1MSk7XHJcbiAgICAgICAgbGV0IHllYXIgPSA0NzQgKyAyODIwICogbjI4MjAgKyB5MjgyMDtcclxuICAgICAgICBpZiAoeWVhciA8PSAwKSB5ZWFyLS07XHJcbiAgICAgICAgbGV0IHlEYXkgPSBqZCAtICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRwZXJzaWFuVG9KdWxpYW5EYXkoeWVhciwgMSwgMSkgKyAxO1xyXG4gICAgICAgIGxldCBtb250aCA9IHlEYXkgPD0gMTg2ID8gTWF0aC5jZWlsKHlEYXkgLyAzMSkgOiBNYXRoLmNlaWwoKHlEYXkgLSA2KSAvIDMxKTtcclxuICAgICAgICBsZXQgZGF5ID0gamQgLSAkZjNlZDJlNDQ3MmFlN2UyNSR2YXIkcGVyc2lhblRvSnVsaWFuRGF5KHllYXIsIG1vbnRoLCAxKSArIDE7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKHRoaXMsIHllYXIsIG1vbnRoLCBkYXkpO1xyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiAkZjNlZDJlNDQ3MmFlN2UyNSR2YXIkcGVyc2lhblRvSnVsaWFuRGF5KGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TW9udGhzSW5ZZWFyKCkge1xyXG4gICAgICAgIHJldHVybiAxMjtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICBpZiAoZGF0ZS5tb250aCA8PSA2KSByZXR1cm4gMzE7XHJcbiAgICAgICAgaWYgKGRhdGUubW9udGggPD0gMTEpIHJldHVybiAzMDtcclxuICAgICAgICByZXR1cm4gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSA/IDMwIDogMjk7XHJcbiAgICB9XHJcbiAgICBnZXRFcmFzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFwiQVBcIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBnZXRZZWFyc0luRXJhKCkge1xyXG4gICAgICAgIC8vIDkzNzgtMTAtMTAgcGVyc2lhbiBpcyA5OTk5LTEyLTMxIGdyZWdvcmlhbi5cclxuICAgICAgICAvLyBSb3VuZCBkb3duIHRvIDkzNzcgdG8gc2V0IHRoZSBtYXhpbXVtIGZ1bGwgeWVhci5cclxuICAgICAgICByZXR1cm4gOTM3NztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJwZXJzaWFuXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSBJQ1UuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuXHJcbi8vIFN0YXJ0cyBpbiA3OCBBRCxcclxuY29uc3QgJDgyYzM1ODAwM2JkZGEwYTgkdmFyJElORElBTl9FUkFfU1RBUlQgPSA3ODtcclxuLy8gVGhlIEluZGlhbiB5ZWFyIHN0YXJ0cyA4MCBkYXlzIGxhdGVyIHRoYW4gdGhlIEdyZWdvcmlhbiB5ZWFyLlxyXG5jb25zdCAkODJjMzU4MDAzYmRkYTBhOCR2YXIkSU5ESUFOX1lFQVJfU1RBUlQgPSA4MDtcclxuY2xhc3MgJDgyYzM1ODAwM2JkZGEwYTgkZXhwb3J0JDM5ZjMxYzYzOWZhMTU3MjYgZXh0ZW5kcyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICAvLyBHcmVnb3JpYW4gZGF0ZSBmb3IgSnVsaWFuIGRheVxyXG4gICAgICAgIGxldCBkYXRlID0gc3VwZXIuZnJvbUp1bGlhbkRheShqZCk7XHJcbiAgICAgICAgLy8gWWVhciBpbiBTYWthIGVyYVxyXG4gICAgICAgIGxldCBpbmRpYW5ZZWFyID0gZGF0ZS55ZWFyIC0gJDgyYzM1ODAwM2JkZGEwYTgkdmFyJElORElBTl9FUkFfU1RBUlQ7XHJcbiAgICAgICAgLy8gRGF5IG51bWJlciBpbiBHcmVnb3JpYW4geWVhciAoc3RhcnRpbmcgZnJvbSAwKVxyXG4gICAgICAgIGxldCB5RGF5ID0gamQgLSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkpKGRhdGUuZXJhLCBkYXRlLnllYXIsIDEsIDEpO1xyXG4gICAgICAgIGxldCBsZWFwTW9udGg7XHJcbiAgICAgICAgaWYgKHlEYXkgPCAkODJjMzU4MDAzYmRkYTBhOCR2YXIkSU5ESUFOX1lFQVJfU1RBUlQpIHtcclxuICAgICAgICAgICAgLy8gIERheSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBwcmVjZWRpbmcgU2FrYSB5ZWFyXHJcbiAgICAgICAgICAgIGluZGlhblllYXItLTtcclxuICAgICAgICAgICAgLy8gRGF5cyBpbiBsZWFwTW9udGggdGhpcyB5ZWFyLCBwcmV2aW91cyBHcmVnb3JpYW4geWVhclxyXG4gICAgICAgICAgICBsZWFwTW9udGggPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzApKGRhdGUueWVhciAtIDEpID8gMzEgOiAzMDtcclxuICAgICAgICAgICAgeURheSArPSBsZWFwTW9udGggKyAxNTUgKyA5MCArIDEwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERheXMgaW4gbGVhcE1vbnRoIHRoaXMgeWVhclxyXG4gICAgICAgICAgICBsZWFwTW9udGggPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzApKGRhdGUueWVhcikgPyAzMSA6IDMwO1xyXG4gICAgICAgICAgICB5RGF5IC09ICQ4MmMzNTgwMDNiZGRhMGE4JHZhciRJTkRJQU5fWUVBUl9TVEFSVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGluZGlhbk1vbnRoO1xyXG4gICAgICAgIGxldCBpbmRpYW5EYXk7XHJcbiAgICAgICAgaWYgKHlEYXkgPCBsZWFwTW9udGgpIHtcclxuICAgICAgICAgICAgaW5kaWFuTW9udGggPSAxO1xyXG4gICAgICAgICAgICBpbmRpYW5EYXkgPSB5RGF5ICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbURheSA9IHlEYXkgLSBsZWFwTW9udGg7XHJcbiAgICAgICAgICAgIGlmIChtRGF5IDwgMTU1KSB7XHJcbiAgICAgICAgICAgICAgICBpbmRpYW5Nb250aCA9IE1hdGguZmxvb3IobURheSAvIDMxKSArIDI7XHJcbiAgICAgICAgICAgICAgICBpbmRpYW5EYXkgPSBtRGF5ICUgMzEgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbURheSAtPSAxNTU7XHJcbiAgICAgICAgICAgICAgICBpbmRpYW5Nb250aCA9IE1hdGguZmxvb3IobURheSAvIDMwKSArIDc7XHJcbiAgICAgICAgICAgICAgICBpbmRpYW5EYXkgPSBtRGF5ICUgMzAgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBpbmRpYW5ZZWFyLCBpbmRpYW5Nb250aCwgaW5kaWFuRGF5KTtcclxuICAgIH1cclxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcclxuICAgICAgICBsZXQgZXh0ZW5kZWRZZWFyID0gZGF0ZS55ZWFyICsgJDgyYzM1ODAwM2JkZGEwYTgkdmFyJElORElBTl9FUkFfU1RBUlQ7XHJcbiAgICAgICAgbGV0IFtlcmEsIHllYXJdID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjKShleHRlbmRlZFllYXIpO1xyXG4gICAgICAgIGxldCBsZWFwTW9udGg7XHJcbiAgICAgICAgbGV0IGpkO1xyXG4gICAgICAgIGlmICgoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzApKHllYXIpKSB7XHJcbiAgICAgICAgICAgIGxlYXBNb250aCA9IDMxO1xyXG4gICAgICAgICAgICBqZCA9ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOSkoZXJhLCB5ZWFyLCAzLCAyMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVhcE1vbnRoID0gMzA7XHJcbiAgICAgICAgICAgIGpkID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KShlcmEsIHllYXIsIDMsIDIyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUubW9udGggPT09IDEpIHJldHVybiBqZCArIGRhdGUuZGF5IC0gMTtcclxuICAgICAgICBqZCArPSBsZWFwTW9udGggKyBNYXRoLm1pbihkYXRlLm1vbnRoIC0gMiwgNSkgKiAzMTtcclxuICAgICAgICBpZiAoZGF0ZS5tb250aCA+PSA4KSBqZCArPSAoZGF0ZS5tb250aCAtIDcpICogMzA7XHJcbiAgICAgICAgamQgKz0gZGF0ZS5kYXkgLSAxO1xyXG4gICAgICAgIHJldHVybiBqZDtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICBpZiAoZGF0ZS5tb250aCA9PT0gMSAmJiAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzApKGRhdGUueWVhciArICQ4MmMzNTgwMDNiZGRhMGE4JHZhciRJTkRJQU5fRVJBX1NUQVJUKSkgcmV0dXJuIDMxO1xyXG4gICAgICAgIGlmIChkYXRlLm1vbnRoID49IDIgJiYgZGF0ZS5tb250aCA8PSA2KSByZXR1cm4gMzE7XHJcbiAgICAgICAgcmV0dXJuIDMwO1xyXG4gICAgfVxyXG4gICAgZ2V0WWVhcnNJbkVyYSgpIHtcclxuICAgICAgICAvLyA5OTk5LTEyLTMxIGdyZWdvcmlhbiBpcyA5OTIwLTEwLTEwIGluZGlhbi5cclxuICAgICAgICAvLyBSb3VuZCBkb3duIHRvIDk5MTkgZm9yIHRoZSBsYXN0IGZ1bGwgeWVhci5cclxuICAgICAgICByZXR1cm4gOTkxOTtcclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgXCJzYWthXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYmFsYW5jZURhdGUoKSB7fVxyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJpbmRpYW5cIjtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cclxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcblxyXG5jb25zdCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQ0lWSUxfRVBPQyA9IDE5NDg0NDA7IC8vIENFIDYyMiBKdWx5IDE2IEZyaWRheSAoSnVsaWFuIGNhbGVuZGFyKSAvIENFIDYyMiBKdWx5IDE5IChHcmVnb3JpYW4gY2FsZW5kYXIpXHJcbmNvbnN0ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRBU1RST05PTUlDQUxfRVBPQyA9IDE5NDg0Mzk7IC8vIENFIDYyMiBKdWx5IDE1IFRodXJzZGF5IChKdWxpYW4gY2FsZW5kYXIpXHJcbmNvbnN0ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUID0gMTMwMDtcclxuY29uc3QgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EID0gMTYwMDtcclxuY29uc3QgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1NUQVJUX0RBWVMgPSA0NjAzMjI7XHJcbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciRpc2xhbWljVG9KdWxpYW5EYXkoZXBvY2gsIHllYXIsIG1vbnRoLCBkYXkpIHtcclxuICAgIHJldHVybiBkYXkgKyBNYXRoLmNlaWwoMjkuNSAqIChtb250aCAtIDEpKSArICh5ZWFyIC0gMSkgKiAzNTQgKyBNYXRoLmZsb29yKCgzICsgMTEgKiB5ZWFyKSAvIDMwKSArIGVwb2NoIC0gMTtcclxufVxyXG5mdW5jdGlvbiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkanVsaWFuRGF5VG9Jc2xhbWljKGNhbGVuZGFyLCBlcG9jaCwgamQpIHtcclxuICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcigoMzAgKiAoamQgLSBlcG9jaCkgKyAxMDY0NikgLyAxMDYzMSk7XHJcbiAgICBsZXQgbW9udGggPSBNYXRoLm1pbigxMiwgTWF0aC5jZWlsKChqZCAtICgyOSArICRmMmYzZTBlM2E4MTdlZGJkJHZhciRpc2xhbWljVG9KdWxpYW5EYXkoZXBvY2gsIHllYXIsIDEsIDEpKSkgLyAyOS41KSArIDEpO1xyXG4gICAgbGV0IGRheSA9IGpkIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzbGFtaWNUb0p1bGlhbkRheShlcG9jaCwgeWVhciwgbW9udGgsIDEpICsgMTtcclxuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShjYWxlbmRhciwgeWVhciwgbW9udGgsIGRheSk7XHJcbn1cclxuZnVuY3Rpb24gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzTGVhcFllYXIoeWVhcikge1xyXG4gICAgcmV0dXJuICgxNCArIDExICogeWVhcikgJSAzMCA8IDExO1xyXG59XHJcbmNsYXNzICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQyMDY2Nzk1YWFkZDM3YmZjIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGp1bGlhbkRheVRvSXNsYW1pYyh0aGlzLCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQ0lWSUxfRVBPQywgamQpO1xyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkaXNsYW1pY1RvSnVsaWFuRGF5KCRmMmYzZTBlM2E4MTdlZGJkJHZhciRDSVZJTF9FUE9DLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gMjkgKyBkYXRlLm1vbnRoICUgMjtcclxuICAgICAgICBpZiAoZGF0ZS5tb250aCA9PT0gMTIgJiYgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSkgbGVuZ3RoKys7XHJcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldE1vbnRoc0luWWVhcigpIHtcclxuICAgICAgICByZXR1cm4gMTI7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSA/IDM1NSA6IDM1NDtcclxuICAgIH1cclxuICAgIGdldFllYXJzSW5FcmEoKSB7XHJcbiAgICAgICAgLy8gOTk5OSBncmVnb3JpYW5cclxuICAgICAgICByZXR1cm4gOTY2NTtcclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgXCJBSFwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJpc2xhbWljLWNpdmlsXCI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDM3ZjA4ODdmMmY5ZDIyZjcgZXh0ZW5kcyAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkMjA2Njc5NWFhZGQzN2JmYyB7XHJcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XHJcbiAgICAgICAgcmV0dXJuICRmMmYzZTBlM2E4MTdlZGJkJHZhciRqdWxpYW5EYXlUb0lzbGFtaWModGhpcywgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJEFTVFJPTk9NSUNBTF9FUE9DLCBqZCk7XHJcbiAgICB9XHJcbiAgICB0b0p1bGlhbkRheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuICRmMmYzZTBlM2E4MTdlZGJkJHZhciRpc2xhbWljVG9KdWxpYW5EYXkoJGYyZjNlMGUzYTgxN2VkYmQkdmFyJEFTVFJPTk9NSUNBTF9FUE9DLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiaXNsYW1pYy10YmxhXCI7XHJcbiAgICB9XHJcbn1cclxuLy8gR2VuZXJhdGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGUtdW1hbHF1cmEuanNcclxuY29uc3QgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX0RBVEEgPSBcInFncFVEY2tPMUFicUJtd0RyUXBWQmFrR2tnZXBDOVFGMmdwY0JTME5sUVpLQjFRTGFndXRCYTRFVHdvWEJZc0dwUWJWQ3RZQ1d3bWRCRTBLSmcyVkRhd0Z0Z202QWxzS0t3V1ZDc29HNlFyMEFuWUp0Z0pXQ2NvS3BBdlNDOWtGM0FKdENVMEZwUXBTQzZVTHRBVzJDVmNGbHdKTEJhTUdVZ2RsQzJvRnF3b3JCWlVNU2cybERjb0YxZ3BYQ2FzRVN3bWxDbElMYWd0MUJYWUN0d2hiQkZVRnFRVzBCZG9KM1FSdUFqWUpxZ3BVRGJJTjFRWGFBbHNKcXdSVkNra0xaQXR4QzdRRnRRcFZDaVVOa2c3SkR0UUc2UXByQ2FzRWt3cEpEYVFOc2cyNUNyb0VXd29yQlpVS0tndFZDMXdGdlFROUFoMEpsUXBLQzFvTGJRVzJBanNKbXdSVkJxa0dWQWRxQzJ3RnJRcFZCU2tMa2d1cEM5UUYyZ3BhQmFzS2xRVkpCMlFIcWd1MUJiWUNWZ3BORGlVTFVndHFDNjBGcmdJdkNaY0VTd2FsQnF3RzFncGRCWjBFVFFvV0RaVU5xZ1cxQmRvQ1d3bXRCSlVGeWdia0J1b0s5UVMyQWxZSnFncFVDOUlMMlFYcUFtMEpyUVNWQ2tvTHBRdXlCYlVKMWdTWENrY0Zrd1pKQjFVTGFnVnJDaXNGaXdwR0RhTU55Z1hXQ3RzRWF3SkxDYVVLVWd0cEMzVUZkZ0czQ0ZzQ0t3VmxCYlFGMmdudEJHMEJ0Z2ltQ2xJTnFRM1VCZG9LV3dtckJGTUdLUWRpQjZrTHNnVzFDbFVGSlF1U0Rja08wZ2JwQ21zRnF3UlZDaWtOVkEycURiVUp1Z1E3Q3BzRVRRcXFDdFVLMmdKZENWNEVMZ3FhREZVTnNnYTVCcm9FWFFvdEJaVUtVZ3VvQzdRTHVRWGFBbG9KU2d1a0RkRU82QVpxQzIwRk5RV1ZCa29OcUEzVURkb0dXd1dkQWlzR0ZRdEtDNVVMcWdXdUNpNEpqd3duQlpVR3FnYldDbDBGblFJPVwiO1xyXG5sZXQgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX01PTlRITEVOR1RIO1xyXG5sZXQgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRfVEFCTEU7XHJcbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJTdGFydCh5ZWFyKSB7XHJcbiAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1NUQVJUX0RBWVMgKyAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF9UQUJMRVt5ZWFyIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRdO1xyXG59XHJcbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoTGVuZ3RoKHllYXIsIG1vbnRoKSB7XHJcbiAgICBsZXQgaWR4ID0geWVhciAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUO1xyXG4gICAgbGV0IG1hc2sgPSAweDAxIDw8IDExIC0gKG1vbnRoIC0gMSk7XHJcbiAgICBpZiAoKCRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9NT05USExFTkdUSFtpZHhdICYgbWFzaykgPT09IDApIHJldHVybiAyOTtcclxuICAgIGVsc2UgcmV0dXJuIDMwO1xyXG59XHJcbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoU3RhcnQoeWVhciwgbW9udGgpIHtcclxuICAgIGxldCBkYXkgPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFZZWFyU3RhcnQoeWVhcik7XHJcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgbW9udGg7IGkrKylkYXkgKz0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhTW9udGhMZW5ndGgoeWVhciwgaSk7XHJcbiAgICByZXR1cm4gZGF5O1xyXG59XHJcbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJMZW5ndGgoeWVhcikge1xyXG4gICAgcmV0dXJuICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFW3llYXIgKyAxIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRdIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRfVEFCTEVbeWVhciAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUXTtcclxufVxyXG5jbGFzcyAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkNWJhYWI0NzU4YzIzMTA3NiBleHRlbmRzICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQyMDY2Nzk1YWFkZDM3YmZjIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgZGF5cyA9IGpkIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJENJVklMX0VQT0M7XHJcbiAgICAgICAgbGV0IHN0YXJ0RGF5cyA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJTdGFydCgkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVCk7XHJcbiAgICAgICAgbGV0IGVuZERheXMgPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFZZWFyU3RhcnQoJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EKTtcclxuICAgICAgICBpZiAoZGF5cyA8IHN0YXJ0RGF5cyB8fCBkYXlzID4gZW5kRGF5cykgcmV0dXJuIHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgeSA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUIC0gMTtcclxuICAgICAgICAgICAgbGV0IG0gPSAxO1xyXG4gICAgICAgICAgICBsZXQgZCA9IDE7XHJcbiAgICAgICAgICAgIHdoaWxlKGQgPiAwKXtcclxuICAgICAgICAgICAgICAgIHkrKztcclxuICAgICAgICAgICAgICAgIGQgPSBkYXlzIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhWWVhclN0YXJ0KHkpICsgMTtcclxuICAgICAgICAgICAgICAgIGxldCB5ZWFyTGVuZ3RoID0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhWWVhckxlbmd0aCh5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkID09PSB5ZWFyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkIDwgeWVhckxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtb250aExlbmd0aCA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoTGVuZ3RoKHksIG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGQgPiBtb250aExlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgLT0gbW9udGhMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhMZW5ndGggPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aExlbmd0aCh5LCBtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKHRoaXMsIHksIG0sIGRheXMgLSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aFN0YXJ0KHksIG0pICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIGlmIChkYXRlLnllYXIgPCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVCB8fCBkYXRlLnllYXIgPiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9FTkQpIHJldHVybiBzdXBlci50b0p1bGlhbkRheShkYXRlKTtcclxuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJENJVklMX0VQT0MgKyAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aFN0YXJ0KGRhdGUueWVhciwgZGF0ZS5tb250aCkgKyAoZGF0ZS5kYXkgLSAxKTtcclxuICAgIH1cclxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcclxuICAgICAgICBpZiAoZGF0ZS55ZWFyIDwgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlQgfHwgZGF0ZS55ZWFyID4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EKSByZXR1cm4gc3VwZXIuZ2V0RGF5c0luTW9udGgoZGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoTGVuZ3RoKGRhdGUueWVhciwgZGF0ZS5tb250aCk7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcclxuICAgICAgICBpZiAoZGF0ZS55ZWFyIDwgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlQgfHwgZGF0ZS55ZWFyID4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EKSByZXR1cm4gc3VwZXIuZ2V0RGF5c0luWWVhcihkYXRlKTtcclxuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhWWVhckxlbmd0aChkYXRlLnllYXIpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiaXNsYW1pYy11bWFscXVyYVwiO1xyXG4gICAgICAgIGlmICghJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX01PTlRITEVOR1RIKSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfTU9OVEhMRU5HVEggPSBuZXcgVWludDE2QXJyYXkoVWludDhBcnJheS5mcm9tKGF0b2IoJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX0RBVEEpLCAoYyk9PmMuY2hhckNvZGVBdCgwKSkuYnVmZmVyKTtcclxuICAgICAgICBpZiAoISRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFKSB7XHJcbiAgICAgICAgICAgICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFID0gbmV3IFVpbnQzMkFycmF5KCRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORCAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUICsgMSk7XHJcbiAgICAgICAgICAgIGxldCB5ZWFyU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IobGV0IHllYXIgPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVDsgeWVhciA8PSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9FTkQ7IHllYXIrKyl7XHJcbiAgICAgICAgICAgICAgICAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF9UQUJMRVt5ZWFyIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRdID0geWVhclN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKXllYXJTdGFydCArPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aExlbmd0aCh5ZWFyLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XHJcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXHJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xyXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcclxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cclxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcblxyXG5cclxuY29uc3QgJDdjNWY2ZmJmNDIzODk3ODckdmFyJEhFQlJFV19FUE9DSCA9IDM0Nzk5NztcclxuLy8gSGVicmV3IGRhdGUgY2FsY3VsYXRpb25zIGFyZSBwZXJmb3JtZWQgaW4gdGVybXMgb2YgZGF5cywgaG91cnMsIGFuZFxyXG4vLyBcInBhcnRzXCIgKG9yIGhhbGFraW0pLCB3aGljaCBhcmUgMS8xMDgwIG9mIGFuIGhvdXIsIG9yIDMgMS8zIHNlY29uZHMuXHJcbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRIT1VSX1BBUlRTID0gMTA4MDtcclxuY29uc3QgJDdjNWY2ZmJmNDIzODk3ODckdmFyJERBWV9QQVJUUyA9IDI0ICogJDdjNWY2ZmJmNDIzODk3ODckdmFyJEhPVVJfUEFSVFM7XHJcbi8vIEFuIGFwcHJveGltYXRlIHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIGEgbHVuYXIgbW9udGguXHJcbi8vIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSB5ZWFyIGFuZCBtb250aCBvZiBhIGdpdmVuXHJcbi8vIGFic29sdXRlIGRhdGUuXHJcbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9EQVlTID0gMjk7XHJcbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9GUkFDVCA9IDEyICogJDdjNWY2ZmJmNDIzODk3ODckdmFyJEhPVVJfUEFSVFMgKyA3OTM7XHJcbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9QQVJUUyA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9EQVlTICogJDdjNWY2ZmJmNDIzODk3ODckdmFyJERBWV9QQVJUUyArICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9GUkFDVDtcclxuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIoeWVhcikge1xyXG4gICAgcmV0dXJuICgwLCAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSkoeWVhciAqIDcgKyAxLCAxOSkgPCA3O1xyXG59XHJcbi8vIFRlc3QgZm9yIGRlbGF5IG9mIHN0YXJ0IG9mIG5ldyB5ZWFyIGFuZCB0byBhdm9pZFxyXG4vLyBTdW5kYXksIFdlZG5lc2RheSwgYW5kIEZyaWRheSBhcyBzdGFydCBvZiB0aGUgbmV3IHllYXIuXHJcbmZ1bmN0aW9uICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRoZWJyZXdEZWxheTEoeWVhcikge1xyXG4gICAgbGV0IG1vbnRocyA9IE1hdGguZmxvb3IoKDIzNSAqIHllYXIgLSAyMzQpIC8gMTkpO1xyXG4gICAgbGV0IHBhcnRzID0gMTIwODQgKyAxMzc1MyAqIG1vbnRocztcclxuICAgIGxldCBkYXkgPSBtb250aHMgKiAyOSArIE1hdGguZmxvb3IocGFydHMgLyAyNTkyMCk7XHJcbiAgICBpZiAoKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKSgzICogKGRheSArIDEpLCA3KSA8IDMpIGRheSArPSAxO1xyXG4gICAgcmV0dXJuIGRheTtcclxufVxyXG4vLyBDaGVjayBmb3IgZGVsYXkgaW4gc3RhcnQgb2YgbmV3IHllYXIgZHVlIHRvIGxlbmd0aCBvZiBhZGphY2VudCB5ZWFyc1xyXG5mdW5jdGlvbiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaGVicmV3RGVsYXkyKHllYXIpIHtcclxuICAgIGxldCBsYXN0ID0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGhlYnJld0RlbGF5MSh5ZWFyIC0gMSk7XHJcbiAgICBsZXQgcHJlc2VudCA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRoZWJyZXdEZWxheTEoeWVhcik7XHJcbiAgICBsZXQgbmV4dCA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRoZWJyZXdEZWxheTEoeWVhciArIDEpO1xyXG4gICAgaWYgKG5leHQgLSBwcmVzZW50ID09PSAzNTYpIHJldHVybiAyO1xyXG4gICAgaWYgKHByZXNlbnQgLSBsYXN0ID09PSAzODIpIHJldHVybiAxO1xyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJHN0YXJ0T2ZZZWFyKHllYXIpIHtcclxuICAgIHJldHVybiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaGVicmV3RGVsYXkxKHllYXIpICsgJDdjNWY2ZmJmNDIzODk3ODckdmFyJGhlYnJld0RlbGF5Mih5ZWFyKTtcclxufVxyXG5mdW5jdGlvbiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0RGF5c0luWWVhcih5ZWFyKSB7XHJcbiAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJHN0YXJ0T2ZZZWFyKHllYXIgKyAxKSAtICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRzdGFydE9mWWVhcih5ZWFyKTtcclxufVxyXG5mdW5jdGlvbiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0WWVhclR5cGUoeWVhcikge1xyXG4gICAgbGV0IHllYXJMZW5ndGggPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0RGF5c0luWWVhcih5ZWFyKTtcclxuICAgIGlmICh5ZWFyTGVuZ3RoID4gMzgwKSB5ZWFyTGVuZ3RoIC09IDMwOyAvLyBTdWJ0cmFjdCBsZW5ndGggb2YgbGVhcCBtb250aC5cclxuICAgIHN3aXRjaCh5ZWFyTGVuZ3RoKXtcclxuICAgICAgICBjYXNlIDM1MzpcclxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGRlZmljaWVudFxyXG4gICAgICAgIGNhc2UgMzU0OlxyXG4gICAgICAgICAgICByZXR1cm4gMTsgLy8gbm9ybWFsXHJcbiAgICAgICAgY2FzZSAzNTU6XHJcbiAgICAgICAgICAgIHJldHVybiAyOyAvLyBjb21wbGV0ZVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xyXG4gICAgLy8gTm9ybWFsaXplIG1vbnRoIG51bWJlcnMgZnJvbSAxIC0gMTMsIGV2ZW4gb24gbm9uLWxlYXAgeWVhcnNcclxuICAgIGlmIChtb250aCA+PSA2ICYmICEkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaXNMZWFwWWVhcih5ZWFyKSkgbW9udGgrKztcclxuICAgIC8vIEZpcnN0IG9mIGFsbCwgZGlzcG9zZSBvZiBmaXhlZC1sZW5ndGggMjkgZGF5IG1vbnRoc1xyXG4gICAgaWYgKG1vbnRoID09PSA0IHx8IG1vbnRoID09PSA3IHx8IG1vbnRoID09PSA5IHx8IG1vbnRoID09PSAxMSB8fCBtb250aCA9PT0gMTMpIHJldHVybiAyOTtcclxuICAgIGxldCB5ZWFyVHlwZSA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXRZZWFyVHlwZSh5ZWFyKTtcclxuICAgIC8vIElmIGl0J3MgSGVzaHZhbiwgZGF5cyBkZXBlbmQgb24gbGVuZ3RoIG9mIHllYXJcclxuICAgIGlmIChtb250aCA9PT0gMikgcmV0dXJuIHllYXJUeXBlID09PSAyID8gMzAgOiAyOTtcclxuICAgIC8vIFNpbWlsYXJseSwgS2lzbGV2IHZhcmllcyB3aXRoIHRoZSBsZW5ndGggb2YgeWVhclxyXG4gICAgaWYgKG1vbnRoID09PSAzKSByZXR1cm4geWVhclR5cGUgPT09IDAgPyAyOSA6IDMwO1xyXG4gICAgLy8gQWRhciBJIG9ubHkgZXhpc3RzIGluIGxlYXAgeWVhcnNcclxuICAgIGlmIChtb250aCA9PT0gNikgcmV0dXJuICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRpc0xlYXBZZWFyKHllYXIpID8gMzAgOiAwO1xyXG4gICAgcmV0dXJuIDMwO1xyXG59XHJcbmNsYXNzICQ3YzVmNmZiZjQyMzg5Nzg3JGV4cG9ydCRjYTQwNTA0OGI4ZmI1YWYge1xyXG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xyXG4gICAgICAgIGxldCBkID0gamQgLSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkSEVCUkVXX0VQT0NIO1xyXG4gICAgICAgIGxldCBtID0gZCAqICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciREQVlfUEFSVFMgLyAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkTU9OVEhfUEFSVFM7IC8vIE1vbnRocyAoYXBwcm94KVxyXG4gICAgICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcigoMTkgKiBtICsgMjM0KSAvIDIzNSkgKyAxOyAvLyBZZWFycyAoYXBwcm94KVxyXG4gICAgICAgIGxldCB5cyA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRzdGFydE9mWWVhcih5ZWFyKTsgLy8gMXN0IGRheSBvZiB5ZWFyXHJcbiAgICAgICAgbGV0IGRheU9mWWVhciA9IE1hdGguZmxvb3IoZCAtIHlzKTtcclxuICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBwb3N0cG9uZW1lbnQgcnVsZXMsIGl0J3MgcG9zc2libGUgdG8gZ3Vlc3Mgd3JvbmcuICBGaXggaXQuXHJcbiAgICAgICAgd2hpbGUoZGF5T2ZZZWFyIDwgMSl7XHJcbiAgICAgICAgICAgIHllYXItLTtcclxuICAgICAgICAgICAgeXMgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkc3RhcnRPZlllYXIoeWVhcik7XHJcbiAgICAgICAgICAgIGRheU9mWWVhciA9IE1hdGguZmxvb3IoZCAtIHlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGZpZ3VyZSBvdXQgd2hpY2ggbW9udGggd2UncmUgaW4sIGFuZCB0aGUgZGF0ZSB3aXRoaW4gdGhhdCBtb250aFxyXG4gICAgICAgIGxldCBtb250aCA9IDE7XHJcbiAgICAgICAgbGV0IG1vbnRoU3RhcnQgPSAwO1xyXG4gICAgICAgIHdoaWxlKG1vbnRoU3RhcnQgPCBkYXlPZlllYXIpe1xyXG4gICAgICAgICAgICBtb250aFN0YXJ0ICs9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7XHJcbiAgICAgICAgICAgIG1vbnRoKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vbnRoLS07XHJcbiAgICAgICAgbW9udGhTdGFydCAtPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xyXG4gICAgICAgIGxldCBkYXkgPSBkYXlPZlllYXIgLSBtb250aFN0YXJ0O1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCB5ZWFyLCBtb250aCwgZGF5KTtcclxuICAgIH1cclxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcclxuICAgICAgICBsZXQgamQgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkc3RhcnRPZlllYXIoZGF0ZS55ZWFyKTtcclxuICAgICAgICBmb3IobGV0IG1vbnRoID0gMTsgbW9udGggPCBkYXRlLm1vbnRoOyBtb250aCsrKWpkICs9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aChkYXRlLnllYXIsIG1vbnRoKTtcclxuICAgICAgICByZXR1cm4gamQgKyBkYXRlLmRheSArICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRIRUJSRVdfRVBPQ0g7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aChkYXRlLnllYXIsIGRhdGUubW9udGgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TW9udGhzSW5ZZWFyKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSA/IDEzIDogMTI7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGdldERheXNJblllYXIoZGF0ZS55ZWFyKTtcclxuICAgIH1cclxuICAgIGdldFllYXJzSW5FcmEoKSB7XHJcbiAgICAgICAgLy8gNjIzOSBncmVnb3JpYW5cclxuICAgICAgICByZXR1cm4gOTk5OTtcclxuICAgIH1cclxuICAgIGdldEVyYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgXCJBTVwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGJhbGFuY2VZZWFyTW9udGgoZGF0ZSwgcHJldmlvdXNEYXRlKSB7XHJcbiAgICAgICAgLy8gS2VlcCBkYXRlIGluIHRoZSBzYW1lIG1vbnRoIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gbGVhcCB5ZWFycyBhbmQgbm9uIGxlYXAgeWVhcnNcclxuICAgICAgICBpZiAocHJldmlvdXNEYXRlLnllYXIgIT09IGRhdGUueWVhcikge1xyXG4gICAgICAgICAgICBpZiAoJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIocHJldmlvdXNEYXRlLnllYXIpICYmICEkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaXNMZWFwWWVhcihkYXRlLnllYXIpICYmIHByZXZpb3VzRGF0ZS5tb250aCA+IDYpIGRhdGUubW9udGgtLTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoISQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRpc0xlYXBZZWFyKHByZXZpb3VzRGF0ZS55ZWFyKSAmJiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaXNMZWFwWWVhcihkYXRlLnllYXIpICYmIHByZXZpb3VzRGF0ZS5tb250aCA+IDYpIGRhdGUubW9udGgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiaGVicmV3XCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSBJQ1UuXHJcbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG5cclxuY29uc3QgJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEVUSElPUElDX0VQT0NIID0gMTcyMzg1NjtcclxuY29uc3QgJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJENPUFRJQ19FUE9DSCA9IDE4MjQ2NjU7XHJcbi8vIFRoZSBkZWx0YSBiZXR3ZWVuIEFtZXRlIEFsZW0gMSBhbmQgQW1ldGUgTWlocmV0IDFcclxuLy8gQUEgNTUwMSA9IEFNIDFcclxuY29uc3QgJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEFNRVRFX01JSFJFVF9ERUxUQSA9IDU1MDA7XHJcbmZ1bmN0aW9uICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRjZVRvSnVsaWFuRGF5KGVwb2NoLCB5ZWFyLCBtb250aCwgZGF5KSB7XHJcbiAgICByZXR1cm4gZXBvY2ggLy8gZGlmZmVyZW5jZSBmcm9tIEp1bGlhbiBlcG9jaCB0byAxLDEsMVxyXG4gICAgICsgMzY1ICogeWVhciAvLyBudW1iZXIgb2YgZGF5cyBmcm9tIHllYXJzXHJcbiAgICAgKyBNYXRoLmZsb29yKHllYXIgLyA0KSAvLyBleHRyYSBkYXkgb2YgbGVhcCB5ZWFyXHJcbiAgICAgKyAzMCAqIChtb250aCAtIDEgLy8gbnVtYmVyIG9mIGRheXMgZnJvbSBtb250aHMgKDEgYmFzZWQpXHJcbiAgICApICsgZGF5IC0gMSAvLyBudW1iZXIgb2YgZGF5cyBmb3IgcHJlc2VudCBtb250aCAoMSBiYXNlZClcclxuICAgIDtcclxufVxyXG5mdW5jdGlvbiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkanVsaWFuRGF5VG9DRShlcG9jaCwgamQpIHtcclxuICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcig0ICogKGpkIC0gZXBvY2gpIC8gMTQ2MSk7XHJcbiAgICBsZXQgbW9udGggPSAxICsgTWF0aC5mbG9vcigoamQgLSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkY2VUb0p1bGlhbkRheShlcG9jaCwgeWVhciwgMSwgMSkpIC8gMzApO1xyXG4gICAgbGV0IGRheSA9IGpkICsgMSAtICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRjZVRvSnVsaWFuRGF5KGVwb2NoLCB5ZWFyLCBtb250aCwgMSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHllYXIsXHJcbiAgICAgICAgbW9udGgsXHJcbiAgICAgICAgZGF5XHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRnZXRMZWFwRGF5KHllYXIpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKHllYXIgJSA0IC8gMyk7XHJcbn1cclxuZnVuY3Rpb24gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XHJcbiAgICAvLyBUaGUgRXRoaW9waWFuIGFuZCBDb3B0aWMgY2FsZW5kYXJzIGhhdmUgMTMgbW9udGhzLCAxMiBvZiAzMCBkYXlzIGVhY2ggYW5kXHJcbiAgICAvLyBhbiBpbnRlcmNhbGFyeSBtb250aCBhdCB0aGUgZW5kIG9mIHRoZSB5ZWFyIG9mIDUgb3IgNiBkYXlzLCBkZXBlbmRpbmcgd2hldGhlclxyXG4gICAgLy8gdGhlIHllYXIgaXMgYSBsZWFwIHllYXIgb3Igbm90LiBUaGUgTGVhcCBZZWFyIGZvbGxvd3MgdGhlIHNhbWUgcnVsZXMgYXMgdGhlXHJcbiAgICAvLyBKdWxpYW4gQ2FsZW5kYXIgc28gdGhhdCB0aGUgZXh0cmEgbW9udGggYWx3YXlzIGhhcyBzaXggZGF5cyBpbiB0aGUgeWVhciBiZWZvcmVcclxuICAgIC8vIGEgSnVsaWFuIExlYXAgWWVhci5cclxuICAgIGlmIChtb250aCAlIDEzICE9PSAwKSAvLyBub3QgaW50ZXJjYWxhcnkgbW9udGhcclxuICAgIHJldHVybiAzMDtcclxuICAgIGVsc2UgLy8gaW50ZXJjYWxhcnkgbW9udGggNSBkYXlzICsgcG9zc2libGUgbGVhcCBkYXlcclxuICAgIHJldHVybiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkZ2V0TGVhcERheSh5ZWFyKSArIDU7XHJcbn1cclxuY2xhc3MgJGI5NTZiMmQ3YTZjZjQ1MWYkZXhwb3J0JDI2YmE2ZWFiNWUyMGNkN2Qge1xyXG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xyXG4gICAgICAgIGxldCBbeWVhciwgbW9udGgsIGRheV0gPSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkanVsaWFuRGF5VG9DRSgkYjk1NmIyZDdhNmNmNDUxZiR2YXIkRVRISU9QSUNfRVBPQ0gsIGpkKTtcclxuICAgICAgICBsZXQgZXJhID0gXCJBTVwiO1xyXG4gICAgICAgIGlmICh5ZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgZXJhID0gXCJBQVwiO1xyXG4gICAgICAgICAgICB5ZWFyICs9ICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRBTUVURV9NSUhSRVRfREVMVEE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBlcmEsIHllYXIsIG1vbnRoLCBkYXkpO1xyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS55ZWFyO1xyXG4gICAgICAgIGlmIChkYXRlLmVyYSA9PT0gXCJBQVwiKSB5ZWFyIC09ICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRBTUVURV9NSUhSRVRfREVMVEE7XHJcbiAgICAgICAgcmV0dXJuICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRjZVRvSnVsaWFuRGF5KCRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRFVEhJT1BJQ19FUE9DSCwgeWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGF5c0luTW9udGgoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkZ2V0RGF5c0luTW9udGgoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoKTtcclxuICAgIH1cclxuICAgIGdldE1vbnRoc0luWWVhcigpIHtcclxuICAgICAgICByZXR1cm4gMTM7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gMzY1ICsgJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGdldExlYXBEYXkoZGF0ZS55ZWFyKTtcclxuICAgIH1cclxuICAgIGdldFllYXJzSW5FcmEoZGF0ZSkge1xyXG4gICAgICAgIC8vIDk5OTktMTItMzEgZ3JlZ29yaWFuIGlzIDk5OTItMjAtMDIgZXRoaW9waWMuXHJcbiAgICAgICAgLy8gUm91bmQgZG93biB0byA5OTkxIGZvciB0aGUgbGFzdCBmdWxsIHllYXIuXHJcbiAgICAgICAgLy8gQUEgOTk5OS0wMS0wMSBldGhpb3BpYyBpcyA0NTA2LTA5LTMwIGdyZWdvcmlhbi5cclxuICAgICAgICByZXR1cm4gZGF0ZS5lcmEgPT09IFwiQUFcIiA/IDk5OTkgOiA5OTkxO1xyXG4gICAgfVxyXG4gICAgZ2V0RXJhcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBcIkFBXCIsXHJcbiAgICAgICAgICAgIFwiQU1cIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiZXRoaW9waWNcIjtcclxuICAgIH1cclxufVxyXG5jbGFzcyAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZDcyZTBjMzcwMDVhNDkxNCBleHRlbmRzICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXldID0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGp1bGlhbkRheVRvQ0UoJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEVUSElPUElDX0VQT0NILCBqZCk7XHJcbiAgICAgICAgeWVhciArPSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQU1FVEVfTUlIUkVUX0RFTFRBO1xyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBcIkFBXCIsIHllYXIsIG1vbnRoLCBkYXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXJhcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBcIkFBXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZ2V0WWVhcnNJbkVyYSgpIHtcclxuICAgICAgICAvLyA5OTk5LTEzLTA0IGV0aGlvYWEgaXMgdGhlIG1heGltdW0gZGF0ZSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byA0NTA2LTA5LTI5IGdyZWdvcmlhbi5cclxuICAgICAgICByZXR1cm4gOTk5OTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiZXRoaW9hYVwiIC8vIGFsc28ga25vd24gYXMgJ2V0aGlvcGljLWFtZXRlLWFsZW0nIGluIElDVVxyXG4gICAgICAgIDtcclxuICAgIH1cclxufVxyXG5jbGFzcyAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZmU2MjQzY2JlMWE0YjdjMSBleHRlbmRzICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIHtcclxuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcclxuICAgICAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXldID0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGp1bGlhbkRheVRvQ0UoJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJENPUFRJQ19FUE9DSCwgamQpO1xyXG4gICAgICAgIGxldCBlcmEgPSBcIkNFXCI7XHJcbiAgICAgICAgaWYgKHllYXIgPD0gMCkge1xyXG4gICAgICAgICAgICBlcmEgPSBcIkJDRVwiO1xyXG4gICAgICAgICAgICB5ZWFyID0gMSAtIHllYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBlcmEsIHllYXIsIG1vbnRoLCBkYXkpO1xyXG4gICAgfVxyXG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xyXG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS55ZWFyO1xyXG4gICAgICAgIGlmIChkYXRlLmVyYSA9PT0gXCJCQ0VcIikgeWVhciA9IDEgLSB5ZWFyO1xyXG4gICAgICAgIHJldHVybiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkY2VUb0p1bGlhbkRheSgkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQ09QVElDX0VQT0NILCB5ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XHJcbiAgICB9XHJcbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XHJcbiAgICAgICAgbGV0IHllYXIgPSBkYXRlLnllYXI7XHJcbiAgICAgICAgaWYgKGRhdGUuZXJhID09PSBcIkJDRVwiKSB5ZWFyID0gMSAtIHllYXI7XHJcbiAgICAgICAgcmV0dXJuICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBkYXRlLm1vbnRoKTtcclxuICAgIH1cclxuICAgIGlzSW52ZXJzZUVyYShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcIkJDRVwiO1xyXG4gICAgfVxyXG4gICAgYmFsYW5jZURhdGUoZGF0ZSkge1xyXG4gICAgICAgIGlmIChkYXRlLnllYXIgPD0gMCkge1xyXG4gICAgICAgICAgICBkYXRlLmVyYSA9IGRhdGUuZXJhID09PSBcIkJDRVwiID8gXCJDRVwiIDogXCJCQ0VcIjtcclxuICAgICAgICAgICAgZGF0ZS55ZWFyID0gMSAtIGRhdGUueWVhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFcmFzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFwiQkNFXCIsXHJcbiAgICAgICAgICAgIFwiQ0VcIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBnZXRZZWFyc0luRXJhKGRhdGUpIHtcclxuICAgICAgICAvLyA5OTk5LTEyLTMwIGdyZWdvcmlhbiBpcyA5NzE2LTAyLTIwIGNvcHRpYy5cclxuICAgICAgICAvLyBSb3VuZCBkb3duIHRvIDk3MTUgZm9yIHRoZSBsYXN0IGZ1bGwgeWVhci5cclxuICAgICAgICAvLyBCQ0UgOTk5OS0wMS0wMSBjb3B0aWMgaXMgQkMgOTcxNi0wNi0xNSBncmVnb3JpYW4uXHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcIkJDRVwiID8gOTk5OSA6IDk3MTU7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcclxuICAgICAgICBzdXBlciguLi5hcmdzKTtcclxuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBcImNvcHRpY1wiO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gJDY0MjQ0MzAyYzMwMTMyOTkkZXhwb3J0JGRkMGJiYzliMjZkZWZlMzcobmFtZSkge1xyXG4gICAgc3dpdGNoKG5hbWUpe1xyXG4gICAgICAgIGNhc2UgXCJidWRkaGlzdFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkOGQ3M2Q0NzQyMmNhNzMwMiRleHBvcnQkNDJkMjBhNzgzMDFkZWU0NCkoKTtcclxuICAgICAgICBjYXNlIFwiZXRoaW9waWNcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGI5NTZiMmQ3YTZjZjQ1MWYkZXhwb3J0JDI2YmE2ZWFiNWUyMGNkN2QpKCk7XHJcbiAgICAgICAgY2FzZSBcImV0aGlvYWFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGI5NTZiMmQ3YTZjZjQ1MWYkZXhwb3J0JGQ3MmUwYzM3MDA1YTQ5MTQpKCk7XHJcbiAgICAgICAgY2FzZSBcImNvcHRpY1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZmU2MjQzY2JlMWE0YjdjMSkoKTtcclxuICAgICAgICBjYXNlIFwiaGVicmV3XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICQ3YzVmNmZiZjQyMzg5Nzg3JGV4cG9ydCRjYTQwNTA0OGI4ZmI1YWYpKCk7XHJcbiAgICAgICAgY2FzZSBcImluZGlhblwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkODJjMzU4MDAzYmRkYTBhOCRleHBvcnQkMzlmMzFjNjM5ZmExNTcyNikoKTtcclxuICAgICAgICBjYXNlIFwiaXNsYW1pYy1jaXZpbFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkMjA2Njc5NWFhZGQzN2JmYykoKTtcclxuICAgICAgICBjYXNlIFwiaXNsYW1pYy10YmxhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQzN2YwODg3ZjJmOWQyMmY3KSgpO1xyXG4gICAgICAgIGNhc2UgXCJpc2xhbWljLXVtYWxxdXJhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQ1YmFhYjQ3NThjMjMxMDc2KSgpO1xyXG4gICAgICAgIGNhc2UgXCJqYXBhbmVzZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkNjIyMjUwMDgwMjBmMGExMyRleHBvcnQkYjc0NmFiMmI2MGNkZmZiZikoKTtcclxuICAgICAgICBjYXNlIFwicGVyc2lhblwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkZjNlZDJlNDQ3MmFlN2UyNSRleHBvcnQkMzdmY2NkYmZkMTRjNTkzOSkoKTtcclxuICAgICAgICBjYXNlIFwicm9jXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICQ1ZjMxYmQ2ZjBjODk0MGIyJGV4cG9ydCQ2NWUwMTA4MGFmY2IwNzk5KSgpO1xyXG4gICAgICAgIGNhc2UgXCJncmVnb3J5XCI6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBsZXQgJGZiMThkNTQxZWExYWQ3MTckdmFyJGZvcm1hdHRlckNhY2hlID0gbmV3IE1hcCgpO1xyXG5jbGFzcyAkZmIxOGQ1NDFlYTFhZDcxNyRleHBvcnQkYWQ5OTFiNjYxMzM4NTFjZiB7XHJcbiAgICAvKiogRm9ybWF0cyBhIGRhdGUgYXMgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kIGZvcm1hdCBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICovIGZvcm1hdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqIEZvcm1hdHMgYSBkYXRlIHRvIGFuIGFycmF5IG9mIHBhcnRzIHN1Y2ggYXMgc2VwYXJhdG9ycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZCBtb3JlLiAqLyBmb3JtYXRUb1BhcnRzKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZvcm1hdFRvUGFydHModmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqIEZvcm1hdHMgYSBkYXRlIHJhbmdlIGFzIGEgc3RyaW5nLiAqLyBmb3JtYXRSYW5nZShzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0UmFuZ2UgPT09IFwiZnVuY3Rpb25cIikgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW5kIGRhdGUgbXVzdCBiZSA+PSBzdGFydCBkYXRlXCIpO1xyXG4gICAgICAgIC8vIFZlcnkgYmFzaWMgZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vycy5cclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb3JtYXR0ZXIuZm9ybWF0KHN0YXJ0KX0gXFx1ezIwMTN9ICR7dGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGVuZCl9YDtcclxuICAgIH1cclxuICAgIC8qKiBGb3JtYXRzIGEgZGF0ZSByYW5nZSBhcyBhbiBhcnJheSBvZiBwYXJ0cy4gKi8gZm9ybWF0UmFuZ2VUb1BhcnRzKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMgPT09IFwiZnVuY3Rpb25cIikgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVuZCBkYXRlIG11c3QgYmUgPj0gc3RhcnQgZGF0ZVwiKTtcclxuICAgICAgICBsZXQgc3RhcnRQYXJ0cyA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoc3RhcnQpO1xyXG4gICAgICAgIGxldCBlbmRQYXJ0cyA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZW5kKTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAuLi5zdGFydFBhcnRzLm1hcCgocCk9Pih7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwic3RhcnRSYW5nZVwiXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiIFxcdTIwMTMgXCIsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwic2hhcmVkXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLi4uZW5kUGFydHMubWFwKChwKT0+KHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJlbmRSYW5nZVwiXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdGhlIHJlc29sdmVkIGZvcm1hdHRpbmcgb3B0aW9ucyBiYXNlZCBvbiB0aGUgdmFsdWVzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICovIHJlc29sdmVkT3B0aW9ucygpIHtcclxuICAgICAgICBsZXQgcmVzb2x2ZWRPcHRpb25zID0gdGhpcy5mb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XHJcbiAgICAgICAgaWYgKCRmYjE4ZDU0MWVhMWFkNzE3JHZhciRoYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlKCkpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkSG91ckN5Y2xlKSB0aGlzLnJlc29sdmVkSG91ckN5Y2xlID0gJGZiMThkNTQxZWExYWQ3MTckdmFyJGdldFJlc29sdmVkSG91ckN5Y2xlKHJlc29sdmVkT3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucy5ob3VyQ3ljbGUgPSB0aGlzLnJlc29sdmVkSG91ckN5Y2xlO1xyXG4gICAgICAgICAgICByZXNvbHZlZE9wdGlvbnMuaG91cjEyID0gdGhpcy5yZXNvbHZlZEhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCB0aGlzLnJlc29sdmVkSG91ckN5Y2xlID09PSBcImgxMlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTYWZhcmkgdXNlcyBhIGRpZmZlcmVudCBuYW1lIGZvciB0aGUgRXRoaW9waWMgKEFtZXRlIEFsZW0pIGNhbGVuZGFyLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNDE1NjRcclxuICAgICAgICBpZiAocmVzb2x2ZWRPcHRpb25zLmNhbGVuZGFyID09PSBcImV0aGlvcGljLWFtZXRlLWFsZW1cIikgcmVzb2x2ZWRPcHRpb25zLmNhbGVuZGFyID0gXCJldGhpb2FhXCI7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkT3B0aW9ucztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgb3B0aW9ucyA9IHt9KXtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlciA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRDYWNoZWREYXRlRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxufVxyXG4vLyBUaGVyZSBhcmUgbXVsdGlwbGUgYnVncyBpbnZvbHZpbmcgdGhlIGhvdXIxMiBhbmQgaG91ckN5Y2xlIG9wdGlvbnMgaW4gdmFyaW91cyBicm93c2VyIGVuZ2luZXMuXHJcbi8vICAgLSBDaHJvbWUgWzFdIChhbmQgdGhlIEVDTUEgNDAyIHNwZWMgWzJdKSByZXNvbHZlIGhvdXIxMjogZmFsc2UgaW4gRW5nbGlzaCBhbmQgb3RoZXIgbG9jYWxlcyB0byBoMjQgKDI0OjAwIC0gMjM6NTkpXHJcbi8vICAgICByYXRoZXIgdGhhbiBoMjMgKDAwOjAwIC0gMjM6NTkpLiBTYW1lIGNhbiBoYXBwZW4gd2l0aCBob3VyMTI6IHRydWUgaW4gRnJlbmNoLCB3aGljaCBDaHJvbWUgcmVzb2x2ZXMgdG8gaDExICgwMDowMCAtIDExOjU5KVxyXG4vLyAgICAgcmF0aGVyIHRoYW4gaDEyICgxMjowMCAtIDExOjU5KS5cclxuLy8gICAtIFdlYktpdCByZXR1cm5zIGFuIGluY29ycmVjdCBob3VyQ3ljbGUgcmVzb2x2ZWQgb3B0aW9uIGluIHRoZSBGcmVuY2ggbG9jYWxlIGR1ZSB0byBpbmNvcnJlY3QgcGFyc2luZyBvZiAnaCcgbGl0ZXJhbFxyXG4vLyAgICAgaW4gdGhlIHJlc29sdmVkIHBhdHRlcm4uIEl0IGFsc28gZm9ybWF0cyBpbmNvcnJlY3RseSB3aGVuIHNwZWNpZnlpbmcgdGhlIGhvdXJDeWNsZSBvcHRpb24gZm9yIHRoZSBzYW1lIHJlYXNvbi4gWzNdXHJcbi8vIFsxXSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ1NzkxXHJcbi8vIFsyXSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hNDAyL2lzc3Vlcy80MDJcclxuLy8gWzNdIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjkzMTNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2NsZHIvYmxvYi8wMThiNTVlZmY3Y2ViMzg5YzdlM2ZjNDRlMmY2NTdlYWUzYjEwYjM4L2NvbW1vbi9zdXBwbGVtZW50YWwvc3VwcGxlbWVudGFsRGF0YS54bWwjTDQ3NzQtTDQ4MDJcclxuY29uc3QgJGZiMThkNTQxZWExYWQ3MTckdmFyJGhvdXIxMlByZWZlcmVuY2VzID0ge1xyXG4gICAgdHJ1ZToge1xyXG4gICAgICAgIC8vIE9ubHkgSmFwYW5lc2UgdXNlcyB0aGUgaDExIHN0eWxlIGZvciAxMiBob3VyIHRpbWUuIEFsbCBvdGhlcnMgdXNlIGgxMi5cclxuICAgICAgICBqYTogXCJoMTFcIlxyXG4gICAgfSxcclxuICAgIGZhbHNlOiB7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRDYWNoZWREYXRlRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvLyBXb3JrIGFyb3VuZCBidWdneSBob3VyMTIgYmVoYXZpb3IgaW4gQ2hyb21lIC8gRUNNQSA0MDIgc3BlYyBieSB1c2luZyBob3VyQ3ljbGUgaW5zdGVhZC5cclxuICAgIC8vIE9ubHkgYXBwbHkgdGhlIHdvcmthcm91bmQgaWYgdGhlIGlzc3VlIGlzIGRldGVjdGVkLCBiZWNhdXNlIHRoZSBob3VyQ3ljbGUgb3B0aW9uIGlzIGJ1Z2d5IGluIFNhZmFyaS5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ob3VyMTIgPT09IFwiYm9vbGVhblwiICYmICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRoYXNCdWdneUhvdXIxMkJlaGF2aW9yKCkpIHtcclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAuLi5vcHRpb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcHJlZiA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRob3VyMTJQcmVmZXJlbmNlc1tTdHJpbmcob3B0aW9ucy5ob3VyMTIpXVtsb2NhbGUuc3BsaXQoXCItXCIpWzBdXTtcclxuICAgICAgICBsZXQgZGVmYXVsdEhvdXJDeWNsZSA9IG9wdGlvbnMuaG91cjEyID8gXCJoMTJcIiA6IFwiaDIzXCI7XHJcbiAgICAgICAgb3B0aW9ucy5ob3VyQ3ljbGUgPSBwcmVmICE9PSBudWxsICYmIHByZWYgIT09IHZvaWQgMCA/IHByZWYgOiBkZWZhdWx0SG91ckN5Y2xlO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmhvdXIxMjtcclxuICAgIH1cclxuICAgIGxldCBjYWNoZUtleSA9IGxvY2FsZSArIChvcHRpb25zID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucykuc29ydCgoYSwgYik9PmFbMF0gPCBiWzBdID8gLTEgOiAxKS5qb2luKCkgOiBcIlwiKTtcclxuICAgIGlmICgkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZm9ybWF0dGVyQ2FjaGUuaGFzKGNhY2hlS2V5KSkgcmV0dXJuICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRmb3JtYXR0ZXJDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgbGV0IG51bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XHJcbiAgICAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZm9ybWF0dGVyQ2FjaGUuc2V0KGNhY2hlS2V5LCBudW1iZXJGb3JtYXR0ZXIpO1xyXG4gICAgcmV0dXJuIG51bWJlckZvcm1hdHRlcjtcclxufVxyXG5sZXQgJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yID0gbnVsbDtcclxuZnVuY3Rpb24gJGZiMThkNTQxZWExYWQ3MTckdmFyJGhhc0J1Z2d5SG91cjEyQmVoYXZpb3IoKSB7XHJcbiAgICBpZiAoJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yID09IG51bGwpICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lIb3VyMTJCZWhhdmlvciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xyXG4gICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxyXG4gICAgICAgIGhvdXIxMjogZmFsc2VcclxuICAgIH0pLmZvcm1hdChuZXcgRGF0ZSgyMDIwLCAyLCAzLCAwKSkgPT09IFwiMjRcIjtcclxuICAgIHJldHVybiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5SG91cjEyQmVoYXZpb3I7XHJcbn1cclxubGV0ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSA9IG51bGw7XHJcbmZ1bmN0aW9uICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRoYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlKCkge1xyXG4gICAgaWYgKCRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSA9PSBudWxsKSAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5UmVzb2x2ZWRIb3VyQ3ljbGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImZyXCIsIHtcclxuICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcclxuICAgICAgICBob3VyMTI6IGZhbHNlXHJcbiAgICB9KS5yZXNvbHZlZE9wdGlvbnMoKS5ob3VyQ3ljbGUgPT09IFwiaDEyXCI7XHJcbiAgICByZXR1cm4gJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlO1xyXG59XHJcbmZ1bmN0aW9uICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRSZXNvbHZlZEhvdXJDeWNsZShsb2NhbGUsIG9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucy50aW1lU3R5bGUgJiYgIW9wdGlvbnMuaG91cikgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIC8vIFdvcmsgYXJvdW5kIGJ1Z2d5IHJlc3VsdHMgaW4gcmVzb2x2ZWQgaG91ckN5Y2xlIGFuZCBob3VyMTIgb3B0aW9ucyBpbiBXZWJLaXQuXHJcbiAgICAvLyBGb3JtYXQgdGhlIG1pbmltdW0gcG9zc2libGUgaG91ciBhbmQgbWF4aW11bSBwb3NzaWJsZSBob3VyIGluIGEgZGF5IGFuZCBwYXJzZSB0aGUgcmVzdWx0cy5cclxuICAgIGxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKC8oLXUtKT8tbnUtW2EtekEtWjAtOV0rLywgXCJcIik7XHJcbiAgICBsb2NhbGUgKz0gKGxvY2FsZS5pbmNsdWRlcyhcIi11LVwiKSA/IFwiXCIgOiBcIi11XCIpICsgXCItbnUtbGF0blwiO1xyXG4gICAgbGV0IGZvcm1hdHRlciA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRDYWNoZWREYXRlRm9ybWF0dGVyKGxvY2FsZSwge1xyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgdGltZVpvbmU6IHVuZGVmaW5lZCAvLyB1c2UgbG9jYWwgdGltZXpvbmVcclxuICAgIH0pO1xyXG4gICAgbGV0IG1pbiA9IHBhcnNlSW50KGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKDIwMjAsIDIsIDMsIDApKS5maW5kKChwKT0+cC50eXBlID09PSBcImhvdXJcIikudmFsdWUsIDEwKTtcclxuICAgIGxldCBtYXggPSBwYXJzZUludChmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgyMDIwLCAyLCAzLCAyMykpLmZpbmQoKHApPT5wLnR5cGUgPT09IFwiaG91clwiKS52YWx1ZSwgMTApO1xyXG4gICAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDIzKSByZXR1cm4gXCJoMjNcIjtcclxuICAgIGlmIChtaW4gPT09IDI0ICYmIG1heCA9PT0gMjMpIHJldHVybiBcImgyNFwiO1xyXG4gICAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDExKSByZXR1cm4gXCJoMTFcIjtcclxuICAgIGlmIChtaW4gPT09IDEyICYmIG1heCA9PT0gMTEpIHJldHVybiBcImgxMlwiO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBob3VyIGN5Y2xlIHJlc3VsdFwiKTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZiBhcyBDYWxlbmRhckRhdGUsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmIGFzIENhbGVuZGFyRGF0ZVRpbWUsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ2ODBlYTE5NmVmZmNlNWYgYXMgVGltZSwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEgYXMgWm9uZWREYXRlVGltZSwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMgYXMgR3JlZ29yaWFuQ2FsZW5kYXIsICQ2MjIyNTAwODAyMGYwYTEzJGV4cG9ydCRiNzQ2YWIyYjYwY2RmZmJmIGFzIEphcGFuZXNlQ2FsZW5kYXIsICQ4ZDczZDQ3NDIyY2E3MzAyJGV4cG9ydCQ0MmQyMGE3ODMwMWRlZTQ0IGFzIEJ1ZGRoaXN0Q2FsZW5kYXIsICQ1ZjMxYmQ2ZjBjODk0MGIyJGV4cG9ydCQ2NWUwMTA4MGFmY2IwNzk5IGFzIFRhaXdhbkNhbGVuZGFyLCAkZjNlZDJlNDQ3MmFlN2UyNSRleHBvcnQkMzdmY2NkYmZkMTRjNTkzOSBhcyBQZXJzaWFuQ2FsZW5kYXIsICQ4MmMzNTgwMDNiZGRhMGE4JGV4cG9ydCQzOWYzMWM2MzlmYTE1NzI2IGFzIEluZGlhbkNhbGVuZGFyLCAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkMjA2Njc5NWFhZGQzN2JmYyBhcyBJc2xhbWljQ2l2aWxDYWxlbmRhciwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDM3ZjA4ODdmMmY5ZDIyZjcgYXMgSXNsYW1pY1RhYnVsYXJDYWxlbmRhciwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDViYWFiNDc1OGMyMzEwNzYgYXMgSXNsYW1pY1VtYWxxdXJhQ2FsZW5kYXIsICQ3YzVmNmZiZjQyMzg5Nzg3JGV4cG9ydCRjYTQwNTA0OGI4ZmI1YWYgYXMgSGVicmV3Q2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIGFzIEV0aGlvcGljQ2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCRkNzJlMGMzNzAwNWE0OTE0IGFzIEV0aGlvcGljQW1ldGVBbGVtQ2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCRmZTYyNDNjYmUxYTRiN2MxIGFzIENvcHRpY0NhbGVuZGFyLCAkNjQyNDQzMDJjMzAxMzI5OSRleHBvcnQkZGQwYmJjOWIyNmRlZmUzNyBhcyBjcmVhdGVDYWxlbmRhciwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDkzNTIyZDFhNDM5ZjM2MTcgYXMgdG9DYWxlbmRhckRhdGUsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0IGFzIHRvQ2FsZW5kYXJEYXRlVGltZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQzM2Y3OWUzZmZjM2RjODMgYXMgdG9UaW1lLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMiBhcyB0b0NhbGVuZGFyLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkODRjOTVhODNjNzk5ZTA3NCBhcyB0b1pvbmVkLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NSBhcyB0b1RpbWVab25lLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDliNjdiYzkzYzA5NzQ5MSBhcyB0b0xvY2FsVGltZVpvbmUsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRlNTdmZjEwMGQ5MWJkNGI5IGFzIGZyb21EYXRlLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYyBhcyBmcm9tQWJzb2x1dGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwIGFzIGlzU2FtZURheSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGExOGM4OWNiZDI0MTcwZmYgYXMgaXNTYW1lTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1ODQxZjllYjk3NzNmMjVmIGFzIGlzU2FtZVllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ5MWI2MmViZjJiYTcwM2VlIGFzIGlzRXF1YWxEYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YThkYTBjNDRhM2FmZGYyIGFzIGlzRXF1YWxNb250aCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVhODQwZjVhNmRkYTgxNDcgYXMgaXNFcXVhbFllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MjliMGE0OTdhYTY1MjY3IGFzIGlzVG9kYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3IGFzIGdldERheU9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQ2MTkzOWRkNDQyMjE1MyBhcyBub3csICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzIGFzIHRvZGF5LCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkMTI2YzkxYzk0MWRlN2UgYXMgZ2V0SG91cnNJbkRheSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGFhOGI0MTczNWFmY2FiZDIgYXMgZ2V0TG9jYWxUaW1lWm9uZSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUgYXMgc3RhcnRPZk1vbnRoLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDJjODFhNDQ0ZmJmYjVkNCBhcyBzdGFydE9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIgYXMgc3RhcnRPZlllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMjI1OGQ5YzQxMTg4MjVjIGFzIGVuZE9mTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlZjhiNmQ5MTMzMDg0ZjRlIGFzIGVuZE9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDhiN2FhNTVjNjZkNTU2OWUgYXMgZW5kT2ZZZWFyLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNTQxMmFjMTE3MTNiNzJhZCBhcyBnZXRNaW5pbXVtTW9udGhJblllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRiMmY0OTUzZDMwMTk4MWQ1IGFzIGdldE1pbmltdW1EYXlJbk1vbnRoLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkY2NjMWIyNDc5ZTdkZDY1NCBhcyBnZXRXZWVrc0luTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YzMzM2ExMTZlOTQ5Y2RkIGFzIG1pbkRhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNzVmMmJmZjU3ODExMDU1IGFzIG1heERhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIgYXMgaXNXZWVrZW5kLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWU5ZDg3MjU4ZTFkMTllZCBhcyBpc1dlZWtkYXksICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2Yjg2MjE2MGQyOTVjOGUgYXMgcGFyc2VEYXRlLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNTg4OTM3YmNkNjBhZGU1NSBhcyBwYXJzZURhdGVUaW1lLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYzk2OThlYzdmMDVhMDdlMSBhcyBwYXJzZVRpbWUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1YWRmZGFiMDUxNjhjMjE5IGFzIHBhcnNlQWJzb2x1dGUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ4ZTM4NDQzMjM2MmVkMGYwIGFzIHBhcnNlQWJzb2x1dGVUb0xvY2FsLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkZmQ3ODkzZjA2ZTkyYTZhNCBhcyBwYXJzZVpvbmVkRGF0ZVRpbWUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRlY2FlODI5YmIzNzQ3ZWE2IGFzIHBhcnNlRHVyYXRpb24sICRmYjE4ZDU0MWVhMWFkNzE3JGV4cG9ydCRhZDk5MWI2NjEzMzg1MWNmIGFzIERhdGVGb3JtYXR0ZXJ9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/date/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@internationalized/number/dist/import.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@internationalized/number/dist/import.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFormatter: () => (/* binding */ $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5),\n/* harmony export */   NumberParser: () => (/* binding */ $6c7bd7858deea686$export$cd11ab140839f11d)\n/* harmony export */ });\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ let $488c6ddbf4ef74c2$var$formatterCache = new Map();\r\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\r\ntry {\r\n    // @ts-ignore\r\n    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat(\"de-DE\", {\r\n        signDisplay: \"exceptZero\"\r\n    }).resolvedOptions().signDisplay === \"exceptZero\";\r\n// eslint-disable-next-line no-empty\r\n} catch (e) {}\r\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\r\ntry {\r\n    // @ts-ignore\r\n    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat(\"de-DE\", {\r\n        style: \"unit\",\r\n        unit: \"degree\"\r\n    }).resolvedOptions().style === \"unit\";\r\n// eslint-disable-next-line no-empty\r\n} catch (e) {}\r\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\r\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\r\n// Values were determined by switching to each locale manually in Chrome.\r\nconst $488c6ddbf4ef74c2$var$UNITS = {\r\n    degree: {\r\n        narrow: {\r\n            default: \"\\xb0\",\r\n            \"ja-JP\": \" \\u5EA6\",\r\n            \"zh-TW\": \"\\u5EA6\",\r\n            \"sl-SI\": \" \\xb0\"\r\n        }\r\n    }\r\n};\r\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\r\n    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {\r\n        let res = \"\";\r\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);\r\n        else res = this.numberFormatter.format(value);\r\n        if (this.options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\r\n            var _UNITS_unit;\r\n            let { unit: unit, unitDisplay: unitDisplay = \"short\", locale: locale } = this.resolvedOptions();\r\n            if (!unit) return res;\r\n            let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];\r\n            res += values[locale] || values.default;\r\n        }\r\n        return res;\r\n    }\r\n    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {\r\n        // TODO: implement signDisplay for formatToParts\r\n        // @ts-ignore\r\n        return this.numberFormatter.formatToParts(value);\r\n    }\r\n    /** Formats a number range as a string. */ formatRange(start, end) {\r\n        // @ts-ignore\r\n        if (typeof this.numberFormatter.formatRange === \"function\") // @ts-ignore\r\n        return this.numberFormatter.formatRange(start, end);\r\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\r\n        // Very basic fallback for old browsers.\r\n        return `${this.format(start)} \\u{2013} ${this.format(end)}`;\r\n    }\r\n    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {\r\n        // @ts-ignore\r\n        if (typeof this.numberFormatter.formatRangeToParts === \"function\") // @ts-ignore\r\n        return this.numberFormatter.formatRangeToParts(start, end);\r\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\r\n        let startParts = this.numberFormatter.formatToParts(start);\r\n        let endParts = this.numberFormatter.formatToParts(end);\r\n        return [\r\n            ...startParts.map((p)=>({\r\n                    ...p,\r\n                    source: \"startRange\"\r\n                })),\r\n            {\r\n                type: \"literal\",\r\n                value: \" \\u2013 \",\r\n                source: \"shared\"\r\n            },\r\n            ...endParts.map((p)=>({\r\n                    ...p,\r\n                    source: \"endRange\"\r\n                }))\r\n        ];\r\n    }\r\n    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {\r\n        let options = this.numberFormatter.resolvedOptions();\r\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\r\n            ...options,\r\n            signDisplay: this.options.signDisplay\r\n        };\r\n        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === \"unit\") options = {\r\n            ...options,\r\n            style: \"unit\",\r\n            unit: this.options.unit,\r\n            unitDisplay: this.options.unitDisplay\r\n        };\r\n        return options;\r\n    }\r\n    constructor(locale, options = {}){\r\n        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\r\n        this.options = options;\r\n    }\r\n}\r\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {\r\n    let { numberingSystem: numberingSystem } = options;\r\n    if (numberingSystem && locale.includes(\"-nu-\")) {\r\n        if (!locale.includes(\"-u-\")) locale += \"-u-\";\r\n        locale += `-nu-${numberingSystem}`;\r\n    }\r\n    if (options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\r\n        var _UNITS_unit;\r\n        let { unit: unit, unitDisplay: unitDisplay = \"short\" } = options;\r\n        if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\r\n        if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\r\n        options = {\r\n            ...options,\r\n            style: \"decimal\"\r\n        };\r\n    }\r\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\r\n    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\r\n    let numberFormatter = new Intl.NumberFormat(locale, options);\r\n    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\r\n    return numberFormatter;\r\n}\r\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\r\n    if (signDisplay === \"auto\") return numberFormat.format(num);\r\n    else if (signDisplay === \"never\") return numberFormat.format(Math.abs(num));\r\n    else {\r\n        let needsPositiveSign = false;\r\n        if (signDisplay === \"always\") needsPositiveSign = num > 0 || Object.is(num, 0);\r\n        else if (signDisplay === \"exceptZero\") {\r\n            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);\r\n            else needsPositiveSign = num > 0;\r\n        }\r\n        if (needsPositiveSign) {\r\n            let negative = numberFormat.format(-num);\r\n            let noSign = numberFormat.format(num);\r\n            // ignore RTL/LTR marker character\r\n            let minus = negative.replace(noSign, \"\").replace(/\\u200e|\\u061C/, \"\");\r\n            if ([\r\n                ...minus\r\n            ].length !== 1) console.warn(\"@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case\");\r\n            let positive = negative.replace(noSign, \"!!!\").replace(minus, \"+\").replace(\"!!!\", noSign);\r\n            return positive;\r\n        } else return numberFormat.format(num);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ \r\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\r\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\r\n    \"latn\",\r\n    \"arab\",\r\n    \"hanidec\"\r\n];\r\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\r\n    /**\r\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\r\n   */ parse(value) {\r\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\r\n    }\r\n    /**\r\n   * Returns whether the given string could potentially be a valid number. This should be used to\r\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\r\n   * of the minus/plus sign characters can be checked.\r\n   */ isValidPartialNumber(value, minValue, maxValue) {\r\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\r\n    }\r\n    /**\r\n   * Returns a numbering system for which the given string is valid in the current locale.\r\n   * If no numbering system could be detected, the default numbering system for the current\r\n   * locale is returned.\r\n   */ getNumberingSystem(value) {\r\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\r\n    }\r\n    constructor(locale, options = {}){\r\n        this.locale = locale;\r\n        this.options = options;\r\n    }\r\n}\r\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\r\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\r\n    // First try the default numbering system for the provided locale\r\n    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\r\n    // If that doesn't match, and the locale doesn't include a hard coded numbering system,\r\n    // try each of the other supported numbering systems until we find one that matches.\r\n    if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\r\n        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {\r\n            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\r\n            if (parser.isValidPartialNumber(value)) return parser;\r\n        }\r\n    }\r\n    return defaultParser;\r\n}\r\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\r\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\r\n    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\r\n    if (!parser) {\r\n        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\r\n        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\r\n    }\r\n    return parser;\r\n}\r\n// The actual number parser implementation. Instances of this class are cached\r\n// based on the locale, options, and detected numbering system.\r\nclass $6c7bd7858deea686$var$NumberParserImpl {\r\n    parse(value) {\r\n        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\r\n        let fullySanitizedValue = this.sanitize(value);\r\n        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.\r\n        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\");\r\n        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, \".\");\r\n        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, \"-\");\r\n        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\r\n        if (this.options.style === \"percent\") {\r\n            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\r\n            let isNegative = fullySanitizedValue.indexOf(\"-\");\r\n            fullySanitizedValue = fullySanitizedValue.replace(\"-\", \"\");\r\n            let index = fullySanitizedValue.indexOf(\".\");\r\n            if (index === -1) index = fullySanitizedValue.length;\r\n            fullySanitizedValue = fullySanitizedValue.replace(\".\", \"\");\r\n            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;\r\n            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;\r\n            else if (index - 2 === -2) fullySanitizedValue = \"0.00\";\r\n            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\r\n            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;\r\n        }\r\n        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\r\n        if (isNaN(newValue)) return NaN;\r\n        if (this.options.style === \"percent\") {\r\n            // extra step for rounding percents to what our formatter would output\r\n            let options = {\r\n                ...this.options,\r\n                style: \"decimal\",\r\n                minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),\r\n                maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)\r\n            };\r\n            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));\r\n        }\r\n        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\r\n        if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\r\n        return newValue;\r\n    }\r\n    sanitize(value) {\r\n        // Remove literals and whitespace, which are allowed anywhere in the string\r\n        value = value.replace(this.symbols.literals, \"\");\r\n        // Replace the ASCII minus sign with the minus sign used in the current locale\r\n        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\r\n        if (this.symbols.minusSign) value = value.replace(\"-\", this.symbols.minusSign);\r\n        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\r\n        // instead they use the , (44) character or apparently the (1548) character.\r\n        if (this.options.numberingSystem === \"arab\") {\r\n            if (this.symbols.decimal) {\r\n                value = value.replace(\",\", this.symbols.decimal);\r\n                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\r\n            }\r\n            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\r\n        }\r\n        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\r\n        // so allow 'period' as a group char and replace it with a space\r\n        if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\r\n        return value;\r\n    }\r\n    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\r\n        value = this.sanitize(value);\r\n        // Remove minus or plus sign, which must be at the start of the string.\r\n        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);\r\n        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\r\n        // Numbers cannot start with a group separator\r\n        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;\r\n        // Numbers that can't have any decimal values fail if a decimal character is typed\r\n        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;\r\n        // Remove numerals, groups, and decimals\r\n        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\");\r\n        value = value.replace(this.symbols.numeral, \"\");\r\n        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, \"\");\r\n        // The number is valid if there are no remaining characters\r\n        return value.length === 0;\r\n    }\r\n    constructor(locale, options = {}){\r\n        this.locale = locale;\r\n        this.formatter = new Intl.NumberFormat(locale, options);\r\n        this.options = this.formatter.resolvedOptions();\r\n        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);\r\n        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\r\n        if (this.options.style === \"percent\" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn(\"NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.\");\r\n    }\r\n}\r\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\r\n    \"decimal\",\r\n    \"fraction\",\r\n    \"integer\",\r\n    \"minusSign\",\r\n    \"plusSign\",\r\n    \"group\"\r\n]);\r\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\r\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\r\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\r\nconst $6c7bd7858deea686$var$pluralNumbers = [\r\n    0,\r\n    4,\r\n    2,\r\n    1,\r\n    11,\r\n    20,\r\n    3,\r\n    7,\r\n    100,\r\n    21,\r\n    0.1,\r\n    1.1\r\n];\r\nfunction $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {\r\n    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;\r\n    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\r\n    let symbolFormatter = new Intl.NumberFormat(locale, {\r\n        ...intlOptions,\r\n        minimumSignificantDigits: 1,\r\n        maximumSignificantDigits: 21\r\n    });\r\n    // Note: some locale's don't add a group symbol until there is a ten thousands place\r\n    let allParts = symbolFormatter.formatToParts(-10000.111);\r\n    let posAllParts = symbolFormatter.formatToParts(10000.111);\r\n    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));\r\n    var _allParts_find_value;\r\n    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\r\n    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\r\n    // Safari does not support the signDisplay option, but our number parser polyfills it.\r\n    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\r\n    // @ts-ignore\r\n    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\r\n    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\r\n    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\r\n    let decimalParts = new Intl.NumberFormat(locale, {\r\n        ...intlOptions,\r\n        minimumFractionDigits: 2,\r\n        maximumFractionDigits: 2\r\n    }).formatToParts(0.001);\r\n    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === \"decimal\")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;\r\n    let group = (_allParts_find1 = allParts.find((p)=>p.type === \"group\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\r\n    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\r\n    // don't contribute to the numerical value\r\n    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));\r\n    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));\r\n    let sortedLiterals = [\r\n        ...new Set([\r\n            ...allPartsLiterals,\r\n            ...pluralPartsLiterals\r\n        ])\r\n    ].sort((a, b)=>b.length - a.length);\r\n    let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\r\n    // These are for replacing non-latn characters with the latn equivalent\r\n    let numerals = [\r\n        ...new Intl.NumberFormat(intlOptions.locale, {\r\n            useGrouping: false\r\n        }).format(9876543210)\r\n    ].reverse();\r\n    let indexes = new Map(numerals.map((d, i)=>[\r\n            d,\r\n            i\r\n        ]));\r\n    let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\r\n    let index = (d)=>String(indexes.get(d));\r\n    return {\r\n        minusSign: minusSign,\r\n        plusSign: plusSign,\r\n        decimal: decimal,\r\n        group: group,\r\n        literals: literals,\r\n        numeral: numeral,\r\n        index: index\r\n    };\r\n}\r\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\r\n    // @ts-ignore\r\n    if (str.replaceAll) // @ts-ignore\r\n    return str.replaceAll(find, replace);\r\n    return str.split(find).join(replace);\r\n}\r\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\r\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=module.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL251bWJlci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFpRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQixHQUFHLE1BQU0sRUFBRSxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLDZLQUE2SyxNQUFNLHFCQUFxQixZQUFZO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9CQUFvQjtBQUNoRixtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0EsMENBQTBDLHdDQUF3QyxHQUFHLHFDQUFxQztBQUMxSCwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWSwwQkFBMEIseUJBQXlCLE1BQU0sWUFBWTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpSTtBQUNqSSIsInNvdXJjZXMiOlsid2VicGFjazovL251dHJpLXNtYXJ0Ly4vbm9kZV9tb2R1bGVzL0BpbnRlcm5hdGlvbmFsaXplZC9udW1iZXIvZGlzdC9pbXBvcnQubWpzP2M0YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gbGV0ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRmb3JtYXR0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcclxubGV0ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1NpZ25EaXNwbGF5ID0gZmFsc2U7XHJcbnRyeSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNTaWduRGlzcGxheSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImRlLURFXCIsIHtcclxuICAgICAgICBzaWduRGlzcGxheTogXCJleGNlcHRaZXJvXCJcclxuICAgIH0pLnJlc29sdmVkT3B0aW9ucygpLnNpZ25EaXNwbGF5ID09PSBcImV4Y2VwdFplcm9cIjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XHJcbn0gY2F0Y2ggKGUpIHt9XHJcbmxldCAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNVbml0ID0gZmFsc2U7XHJcbnRyeSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNVbml0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZGUtREVcIiwge1xyXG4gICAgICAgIHN0eWxlOiBcInVuaXRcIixcclxuICAgICAgICB1bml0OiBcImRlZ3JlZVwiXHJcbiAgICB9KS5yZXNvbHZlZE9wdGlvbnMoKS5zdHlsZSA9PT0gXCJ1bml0XCI7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG59IGNhdGNoIChlKSB7fVxyXG4vLyBQb2x5ZmlsbCBmb3IgdW5pdHMgc2luY2UgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtIHlldC4gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTU0MzguXHJcbi8vIEN1cnJlbnRseSBvbmx5IHBvbHlmaWxsaW5nIHRoZSB1bml0IGRlZ3JlZSBpbiBuYXJyb3cgZm9ybWF0IGZvciBDb2xvclNsaWRlciBpbiBvdXIgc3VwcG9ydGVkIGxvY2FsZXMuXHJcbi8vIFZhbHVlcyB3ZXJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIHRvIGVhY2ggbG9jYWxlIG1hbnVhbGx5IGluIENocm9tZS5cclxuY29uc3QgJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJFVOSVRTID0ge1xyXG4gICAgZGVncmVlOiB7XHJcbiAgICAgICAgbmFycm93OiB7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiXFx4YjBcIixcclxuICAgICAgICAgICAgXCJqYS1KUFwiOiBcIiBcXHU1RUE2XCIsXHJcbiAgICAgICAgICAgIFwiemgtVFdcIjogXCJcXHU1RUE2XCIsXHJcbiAgICAgICAgICAgIFwic2wtU0lcIjogXCIgXFx4YjBcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY2xhc3MgJDQ4OGM2ZGRiZjRlZjc0YzIkZXhwb3J0JGNjNzdjNGZmN2U4NjczYzUge1xyXG4gICAgLyoqIEZvcm1hdHMgYSBudW1iZXIgdmFsdWUgYXMgYSBzdHJpbmcsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gKi8gZm9ybWF0KHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKCEkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNTaWduRGlzcGxheSAmJiB0aGlzLm9wdGlvbnMuc2lnbkRpc3BsYXkgIT0gbnVsbCkgcmVzID0gJDQ4OGM2ZGRiZjRlZjc0YzIkZXhwb3J0JDcxMWI1MGIzYzUyNWUwZjIodGhpcy5udW1iZXJGb3JtYXR0ZXIsIHRoaXMub3B0aW9ucy5zaWduRGlzcGxheSwgdmFsdWUpO1xyXG4gICAgICAgIGVsc2UgcmVzID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlID09PSBcInVuaXRcIiAmJiAhJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJHN1cHBvcnRzVW5pdCkge1xyXG4gICAgICAgICAgICB2YXIgX1VOSVRTX3VuaXQ7XHJcbiAgICAgICAgICAgIGxldCB7IHVuaXQ6IHVuaXQsIHVuaXREaXNwbGF5OiB1bml0RGlzcGxheSA9IFwic2hvcnRcIiwgbG9jYWxlOiBsb2NhbGUgfSA9IHRoaXMucmVzb2x2ZWRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIGlmICghdW5pdCkgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IChfVU5JVFNfdW5pdCA9ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRVTklUU1t1bml0XSkgPT09IG51bGwgfHwgX1VOSVRTX3VuaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9VTklUU191bml0W3VuaXREaXNwbGF5XTtcclxuICAgICAgICAgICAgcmVzICs9IHZhbHVlc1tsb2NhbGVdIHx8IHZhbHVlcy5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIEZvcm1hdHMgYSBudW1iZXIgdG8gYW4gYXJyYXkgb2YgcGFydHMgc3VjaCBhcyBzZXBhcmF0b3JzLCBkaWdpdHMsIHB1bmN0dWF0aW9uLCBhbmQgbW9yZS4gKi8gZm9ybWF0VG9QYXJ0cyh2YWx1ZSkge1xyXG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBzaWduRGlzcGxheSBmb3IgZm9ybWF0VG9QYXJ0c1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKiogRm9ybWF0cyBhIG51bWJlciByYW5nZSBhcyBhIHN0cmluZy4gKi8gZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubnVtYmVyRm9ybWF0dGVyLmZvcm1hdFJhbmdlID09PSBcImZ1bmN0aW9uXCIpIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVuZCBkYXRlIG11c3QgYmUgPj0gc3RhcnQgZGF0ZVwiKTtcclxuICAgICAgICAvLyBWZXJ5IGJhc2ljIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnMuXHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZm9ybWF0KHN0YXJ0KX0gXFx1ezIwMTN9ICR7dGhpcy5mb3JtYXQoZW5kKX1gO1xyXG4gICAgfVxyXG4gICAgLyoqIEZvcm1hdHMgYSBudW1iZXIgcmFuZ2UgYXMgYW4gYXJyYXkgb2YgcGFydHMuICovIGZvcm1hdFJhbmdlVG9QYXJ0cyhzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0UmFuZ2VUb1BhcnRzID09PSBcImZ1bmN0aW9uXCIpIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0UmFuZ2VUb1BhcnRzKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgZGF0ZSBtdXN0IGJlID49IHN0YXJ0IGRhdGVcIik7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydHMgPSB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKHN0YXJ0KTtcclxuICAgICAgICBsZXQgZW5kUGFydHMgPSB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLi4uc3RhcnRQYXJ0cy5tYXAoKHApPT4oe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInN0YXJ0UmFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIiBcXHUyMDEzIFwiLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBcInNoYXJlZFwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC4uLmVuZFBhcnRzLm1hcCgocCk9Pih7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZW5kUmFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBmb3JtYXR0aW5nIG9wdGlvbnMgYmFzZWQgb24gdGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAqLyByZXNvbHZlZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm51bWJlckZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcclxuICAgICAgICBpZiAoISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1NpZ25EaXNwbGF5ICYmIHRoaXMub3B0aW9ucy5zaWduRGlzcGxheSAhPSBudWxsKSBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICBzaWduRGlzcGxheTogdGhpcy5vcHRpb25zLnNpZ25EaXNwbGF5XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1VuaXQgJiYgdGhpcy5vcHRpb25zLnN0eWxlID09PSBcInVuaXRcIikgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3R5bGU6IFwidW5pdFwiLFxyXG4gICAgICAgICAgICB1bml0OiB0aGlzLm9wdGlvbnMudW5pdCxcclxuICAgICAgICAgICAgdW5pdERpc3BsYXk6IHRoaXMub3B0aW9ucy51bml0RGlzcGxheVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG9wdGlvbnMgPSB7fSl7XHJcbiAgICAgICAgdGhpcy5udW1iZXJGb3JtYXR0ZXIgPSAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkZ2V0Q2FjaGVkTnVtYmVyRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkZ2V0Q2FjaGVkTnVtYmVyRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgeyBudW1iZXJpbmdTeXN0ZW06IG51bWJlcmluZ1N5c3RlbSB9ID0gb3B0aW9ucztcclxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0gJiYgbG9jYWxlLmluY2x1ZGVzKFwiLW51LVwiKSkge1xyXG4gICAgICAgIGlmICghbG9jYWxlLmluY2x1ZGVzKFwiLXUtXCIpKSBsb2NhbGUgKz0gXCItdS1cIjtcclxuICAgICAgICBsb2NhbGUgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUgPT09IFwidW5pdFwiICYmICEkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNVbml0KSB7XHJcbiAgICAgICAgdmFyIF9VTklUU191bml0O1xyXG4gICAgICAgIGxldCB7IHVuaXQ6IHVuaXQsIHVuaXREaXNwbGF5OiB1bml0RGlzcGxheSA9IFwic2hvcnRcIiB9ID0gb3B0aW9ucztcclxuICAgICAgICBpZiAoIXVuaXQpIHRocm93IG5ldyBFcnJvcigndW5pdCBvcHRpb24gbXVzdCBiZSBwcm92aWRlZCB3aXRoIHN0eWxlOiBcInVuaXRcIicpO1xyXG4gICAgICAgIGlmICghKChfVU5JVFNfdW5pdCA9ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRVTklUU1t1bml0XSkgPT09IG51bGwgfHwgX1VOSVRTX3VuaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9VTklUU191bml0W3VuaXREaXNwbGF5XSkpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pdCAke3VuaXR9IHdpdGggdW5pdERpc3BsYXkgPSAke3VuaXREaXNwbGF5fWApO1xyXG4gICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHN0eWxlOiBcImRlY2ltYWxcIlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgY2FjaGVLZXkgPSBsb2NhbGUgKyAob3B0aW9ucyA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLnNvcnQoKGEsIGIpPT5hWzBdIDwgYlswXSA/IC0xIDogMSkuam9pbigpIDogXCJcIik7XHJcbiAgICBpZiAoJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJGZvcm1hdHRlckNhY2hlLmhhcyhjYWNoZUtleSkpIHJldHVybiAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkZm9ybWF0dGVyQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuICAgIGxldCBudW1iZXJGb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcclxuICAgICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRmb3JtYXR0ZXJDYWNoZS5zZXQoY2FjaGVLZXksIG51bWJlckZvcm1hdHRlcik7XHJcbiAgICByZXR1cm4gbnVtYmVyRm9ybWF0dGVyO1xyXG59XHJcbmZ1bmN0aW9uICQ0ODhjNmRkYmY0ZWY3NGMyJGV4cG9ydCQ3MTFiNTBiM2M1MjVlMGYyKG51bWJlckZvcm1hdCwgc2lnbkRpc3BsYXksIG51bSkge1xyXG4gICAgaWYgKHNpZ25EaXNwbGF5ID09PSBcImF1dG9cIikgcmV0dXJuIG51bWJlckZvcm1hdC5mb3JtYXQobnVtKTtcclxuICAgIGVsc2UgaWYgKHNpZ25EaXNwbGF5ID09PSBcIm5ldmVyXCIpIHJldHVybiBudW1iZXJGb3JtYXQuZm9ybWF0KE1hdGguYWJzKG51bSkpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5lZWRzUG9zaXRpdmVTaWduID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHNpZ25EaXNwbGF5ID09PSBcImFsd2F5c1wiKSBuZWVkc1Bvc2l0aXZlU2lnbiA9IG51bSA+IDAgfHwgT2JqZWN0LmlzKG51bSwgMCk7XHJcbiAgICAgICAgZWxzZSBpZiAoc2lnbkRpc3BsYXkgPT09IFwiZXhjZXB0WmVyb1wiKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuaXMobnVtLCAtMCkgfHwgT2JqZWN0LmlzKG51bSwgMCkpIG51bSA9IE1hdGguYWJzKG51bSk7XHJcbiAgICAgICAgICAgIGVsc2UgbmVlZHNQb3NpdGl2ZVNpZ24gPSBudW0gPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZHNQb3NpdGl2ZVNpZ24pIHtcclxuICAgICAgICAgICAgbGV0IG5lZ2F0aXZlID0gbnVtYmVyRm9ybWF0LmZvcm1hdCgtbnVtKTtcclxuICAgICAgICAgICAgbGV0IG5vU2lnbiA9IG51bWJlckZvcm1hdC5mb3JtYXQobnVtKTtcclxuICAgICAgICAgICAgLy8gaWdub3JlIFJUTC9MVFIgbWFya2VyIGNoYXJhY3RlclxyXG4gICAgICAgICAgICBsZXQgbWludXMgPSBuZWdhdGl2ZS5yZXBsYWNlKG5vU2lnbiwgXCJcIikucmVwbGFjZSgvXFx1MjAwZXxcXHUwNjFDLywgXCJcIik7XHJcbiAgICAgICAgICAgIGlmIChbXHJcbiAgICAgICAgICAgICAgICAuLi5taW51c1xyXG4gICAgICAgICAgICBdLmxlbmd0aCAhPT0gMSkgY29uc29sZS53YXJuKFwiQHJlYWN0LWFyaWEvaTE4biBwb2x5ZmlsbCBmb3IgTnVtYmVyRm9ybWF0IHNpZ25EaXNwbGF5OiBVbnN1cHBvcnRlZCBjYXNlXCIpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpdmUgPSBuZWdhdGl2ZS5yZXBsYWNlKG5vU2lnbiwgXCIhISFcIikucmVwbGFjZShtaW51cywgXCIrXCIpLnJlcGxhY2UoXCIhISFcIiwgbm9TaWduKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aXZlO1xyXG4gICAgICAgIH0gZWxzZSByZXR1cm4gbnVtYmVyRm9ybWF0LmZvcm1hdChudW0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gXHJcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRDVVJSRU5DWV9TSUdOX1JFR0VYID0gbmV3IFJlZ0V4cChcIl4uKlxcXFwoLipcXFxcKS4qJFwiKTtcclxuY29uc3QgJDZjN2JkNzg1OGRlZWE2ODYkdmFyJE5VTUJFUklOR19TWVNURU1TID0gW1xyXG4gICAgXCJsYXRuXCIsXHJcbiAgICBcImFyYWJcIixcclxuICAgIFwiaGFuaWRlY1wiXHJcbl07XHJcbmNsYXNzICQ2YzdiZDc4NThkZWVhNjg2JGV4cG9ydCRjZDExYWIxNDA4MzlmMTFkIHtcclxuICAgIC8qKlxyXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gc3RyaW5nIHRvIGEgbnVtYmVyLiBSZXR1cm5zIE5hTiBpZiBhIHZhbGlkIG51bWJlciBjb3VsZCBub3QgYmUgcGFyc2VkLlxyXG4gICAqLyBwYXJzZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZ2V0TnVtYmVyUGFyc2VySW1wbCh0aGlzLmxvY2FsZSwgdGhpcy5vcHRpb25zLCB2YWx1ZSkucGFyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY291bGQgcG90ZW50aWFsbHkgYmUgYSB2YWxpZCBudW1iZXIuIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG9cclxuICAgKiB2YWxpZGF0ZSB1c2VyIGlucHV0IGFzIHRoZSB1c2VyIHR5cGVzLiBJZiBhIGBtaW5WYWx1ZWAgb3IgYG1heFZhbHVlYCBpcyBwcm92aWRlZCwgdGhlIHZhbGlkaXR5XHJcbiAgICogb2YgdGhlIG1pbnVzL3BsdXMgc2lnbiBjaGFyYWN0ZXJzIGNhbiBiZSBjaGVja2VkLlxyXG4gICAqLyBpc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXROdW1iZXJQYXJzZXJJbXBsKHRoaXMubG9jYWxlLCB0aGlzLm9wdGlvbnMsIHZhbHVlKS5pc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFJldHVybnMgYSBudW1iZXJpbmcgc3lzdGVtIGZvciB3aGljaCB0aGUgZ2l2ZW4gc3RyaW5nIGlzIHZhbGlkIGluIHRoZSBjdXJyZW50IGxvY2FsZS5cclxuICAgKiBJZiBubyBudW1iZXJpbmcgc3lzdGVtIGNvdWxkIGJlIGRldGVjdGVkLCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIGZvciB0aGUgY3VycmVudFxyXG4gICAqIGxvY2FsZSBpcyByZXR1cm5lZC5cclxuICAgKi8gZ2V0TnVtYmVyaW5nU3lzdGVtKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXROdW1iZXJQYXJzZXJJbXBsKHRoaXMubG9jYWxlLCB0aGlzLm9wdGlvbnMsIHZhbHVlKS5vcHRpb25zLm51bWJlcmluZ1N5c3RlbTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgb3B0aW9ucyA9IHt9KXtcclxuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRudW1iZXJQYXJzZXJDYWNoZSA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJGdldE51bWJlclBhcnNlckltcGwobG9jYWxlLCBvcHRpb25zLCB2YWx1ZSkge1xyXG4gICAgLy8gRmlyc3QgdHJ5IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gZm9yIHRoZSBwcm92aWRlZCBsb2NhbGVcclxuICAgIGxldCBkZWZhdWx0UGFyc2VyID0gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJGdldENhY2hlZE51bWJlclBhcnNlcihsb2NhbGUsIG9wdGlvbnMpO1xyXG4gICAgLy8gSWYgdGhhdCBkb2Vzbid0IG1hdGNoLCBhbmQgdGhlIGxvY2FsZSBkb2Vzbid0IGluY2x1ZGUgYSBoYXJkIGNvZGVkIG51bWJlcmluZyBzeXN0ZW0sXHJcbiAgICAvLyB0cnkgZWFjaCBvZiB0aGUgb3RoZXIgc3VwcG9ydGVkIG51bWJlcmluZyBzeXN0ZW1zIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgbWF0Y2hlcy5cclxuICAgIGlmICghbG9jYWxlLmluY2x1ZGVzKFwiLW51LVwiKSAmJiAhZGVmYXVsdFBhcnNlci5pc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBudW1iZXJpbmdTeXN0ZW0gb2YgJDZjN2JkNzg1OGRlZWE2ODYkdmFyJE5VTUJFUklOR19TWVNURU1TKWlmIChudW1iZXJpbmdTeXN0ZW0gIT09IGRlZmF1bHRQYXJzZXIub3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0pIHtcclxuICAgICAgICAgICAgbGV0IHBhcnNlciA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXRDYWNoZWROdW1iZXJQYXJzZXIobG9jYWxlICsgKGxvY2FsZS5pbmNsdWRlcyhcIi11LVwiKSA/IFwiLW51LVwiIDogXCItdS1udS1cIikgKyBudW1iZXJpbmdTeXN0ZW0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VyLmlzVmFsaWRQYXJ0aWFsTnVtYmVyKHZhbHVlKSkgcmV0dXJuIHBhcnNlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmYXVsdFBhcnNlcjtcclxufVxyXG5mdW5jdGlvbiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZ2V0Q2FjaGVkTnVtYmVyUGFyc2VyKGxvY2FsZSwgb3B0aW9ucykge1xyXG4gICAgbGV0IGNhY2hlS2V5ID0gbG9jYWxlICsgKG9wdGlvbnMgPyBPYmplY3QuZW50cmllcyhvcHRpb25zKS5zb3J0KChhLCBiKT0+YVswXSA8IGJbMF0gPyAtMSA6IDEpLmpvaW4oKSA6IFwiXCIpO1xyXG4gICAgbGV0IHBhcnNlciA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRudW1iZXJQYXJzZXJDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgaWYgKCFwYXJzZXIpIHtcclxuICAgICAgICBwYXJzZXIgPSBuZXcgJDZjN2JkNzg1OGRlZWE2ODYkdmFyJE51bWJlclBhcnNlckltcGwobG9jYWxlLCBvcHRpb25zKTtcclxuICAgICAgICAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkbnVtYmVyUGFyc2VyQ2FjaGUuc2V0KGNhY2hlS2V5LCBwYXJzZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlcjtcclxufVxyXG4vLyBUaGUgYWN0dWFsIG51bWJlciBwYXJzZXIgaW1wbGVtZW50YXRpb24uIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjYWNoZWRcclxuLy8gYmFzZWQgb24gdGhlIGxvY2FsZSwgb3B0aW9ucywgYW5kIGRldGVjdGVkIG51bWJlcmluZyBzeXN0ZW0uXHJcbmNsYXNzICQ2YzdiZDc4NThkZWVhNjg2JHZhciROdW1iZXJQYXJzZXJJbXBsIHtcclxuICAgIHBhcnNlKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gdG8gcGFyc2UgdGhlIG51bWJlciwgd2UgbmVlZCB0byByZW1vdmUgYW55dGhpbmcgdGhhdCBpc24ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBudW1iZXIsIGZvciBleGFtcGxlIHdlIHdhbnQgJy0xMC40MCcgbm90ICctMTAuNDAgVVNEJ1xyXG4gICAgICAgIGxldCBmdWxseVNhbml0aXplZFZhbHVlID0gdGhpcy5zYW5pdGl6ZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCkgLy8gUmVtb3ZlIGdyb3VwIGNoYXJhY3RlcnMsIGFuZCByZXBsYWNlIGRlY2ltYWwgcG9pbnRzIGFuZCBudW1lcmFscyB3aXRoIEFTQ0lJIHZhbHVlcy5cclxuICAgICAgICBmdWxseVNhbml0aXplZFZhbHVlID0gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJHJlcGxhY2VBbGwoZnVsbHlTYW5pdGl6ZWRWYWx1ZSwgdGhpcy5zeW1ib2xzLmdyb3VwLCBcIlwiKTtcclxuICAgICAgICBpZiAodGhpcy5zeW1ib2xzLmRlY2ltYWwpIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBmdWxseVNhbml0aXplZFZhbHVlLnJlcGxhY2UodGhpcy5zeW1ib2xzLmRlY2ltYWwsIFwiLlwiKTtcclxuICAgICAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbikgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubWludXNTaWduLCBcIi1cIik7XHJcbiAgICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubnVtZXJhbCwgdGhpcy5zeW1ib2xzLmluZGV4KTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlID09PSBcInBlcmNlbnRcIikge1xyXG4gICAgICAgICAgICAvLyBqYXZhc2NyaXB0IGlzIGJhZCBhdCBkaXZpZGluZyBieSAxMDAgYW5kIG1haW50YWluaW5nIHRoZSBzYW1lIHNpZ25pZmljYW50IGZpZ3VyZXMsIHNvIHBlcmZvcm0gaXQgb24gdGhlIHN0cmluZyBiZWZvcmUgcGFyc2luZ1xyXG4gICAgICAgICAgICBsZXQgaXNOZWdhdGl2ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUuaW5kZXhPZihcIi1cIik7XHJcbiAgICAgICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBmdWxseVNhbml0aXplZFZhbHVlLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmdWxseVNhbml0aXplZFZhbHVlLmluZGV4T2YoXCIuXCIpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSBpbmRleCA9IGZ1bGx5U2FuaXRpemVkVmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBmdWxseVNhbml0aXplZFZhbHVlID0gZnVsbHlTYW5pdGl6ZWRWYWx1ZS5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4IC0gMiA9PT0gMCkgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAwLiR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCAtIDIgPT09IC0xKSBmdWxseVNhbml0aXplZFZhbHVlID0gYDAuMCR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCAtIDIgPT09IC0yKSBmdWxseVNhbml0aXplZFZhbHVlID0gXCIwLjAwXCI7XHJcbiAgICAgICAgICAgIGVsc2UgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAke2Z1bGx5U2FuaXRpemVkVmFsdWUuc2xpY2UoMCwgaW5kZXggLSAyKX0uJHtmdWxseVNhbml0aXplZFZhbHVlLnNsaWNlKGluZGV4IC0gMil9YDtcclxuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUgPiAtMSkgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAtJHtmdWxseVNhbml0aXplZFZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUgPyArZnVsbHlTYW5pdGl6ZWRWYWx1ZSA6IE5hTjtcclxuICAgICAgICBpZiAoaXNOYU4obmV3VmFsdWUpKSByZXR1cm4gTmFOO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUgPT09IFwicGVyY2VudFwiKSB7XHJcbiAgICAgICAgICAgIC8vIGV4dHJhIHN0ZXAgZm9yIHJvdW5kaW5nIHBlcmNlbnRzIHRvIHdoYXQgb3VyIGZvcm1hdHRlciB3b3VsZCBvdXRwdXRcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJkZWNpbWFsXCIsXHJcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IE1hdGgubWluKHRoaXMub3B0aW9ucy5taW5pbXVtRnJhY3Rpb25EaWdpdHMgKyAyLCAyMCksXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgKyAyLCAyMClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAkNmM3YmQ3ODU4ZGVlYTY4NiRleHBvcnQkY2QxMWFiMTQwODM5ZjExZCh0aGlzLmxvY2FsZSwgb3B0aW9ucykucGFyc2UobmV3ICgwLCAkNDg4YzZkZGJmNGVmNzRjMiRleHBvcnQkY2M3N2M0ZmY3ZTg2NzNjNSkodGhpcy5sb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChuZXdWYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY2NvdW50aW5nIHdpbGwgYWx3YXlzIGJlIHN0cmlwcGVkIHRvIGEgcG9zaXRpdmUgbnVtYmVyLCBzbyBpZiBpdCdzIGFjY291bnRpbmcgYW5kIGhhcyBhICgpIGFyb3VuZCBldmVyeXRoaW5nLCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBpdCBuZWdhdGl2ZSBhZ2FpblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVuY3lTaWduID09PSBcImFjY291bnRpbmdcIiAmJiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkQ1VSUkVOQ1lfU0lHTl9SRUdFWC50ZXN0KHZhbHVlKSkgbmV3VmFsdWUgPSAtMSAqIG5ld1ZhbHVlO1xyXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHNhbml0aXplKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpdGVyYWxzIGFuZCB3aGl0ZXNwYWNlLCB3aGljaCBhcmUgYWxsb3dlZCBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHRoaXMuc3ltYm9scy5saXRlcmFscywgXCJcIik7XHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgQVNDSUkgbWludXMgc2lnbiB3aXRoIHRoZSBtaW51cyBzaWduIHVzZWQgaW4gdGhlIGN1cnJlbnQgbG9jYWxlXHJcbiAgICAgICAgLy8gc28gdGhhdCBib3RoIGFyZSBhbGxvd2VkIGluIGNhc2UgdGhlIHVzZXIncyBrZXlib2FyZCBkb2Vzbid0IGhhdmUgdGhlIGxvY2FsZSdzIG1pbnVzIHNpZ24uXHJcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5taW51c1NpZ24pIHZhbHVlID0gdmFsdWUucmVwbGFjZShcIi1cIiwgdGhpcy5zeW1ib2xzLm1pbnVzU2lnbik7XHJcbiAgICAgICAgLy8gSW4gYXJhYiBudW1lcmFsIHN5c3RlbSwgdGhlaXIgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgMTY0MywgYnV0IG1vc3Qga2V5Ym9hcmRzIGRvbid0IHR5cGUgdGhhdFxyXG4gICAgICAgIC8vIGluc3RlYWQgdGhleSB1c2UgdGhlICwgKDQ0KSBjaGFyYWN0ZXIgb3IgYXBwYXJlbnRseSB0aGUgKDE1NDgpIGNoYXJhY3Rlci5cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJhcmFiXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5kZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCIsXCIsIHRoaXMuc3ltYm9scy5kZWNpbWFsKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShTdHJpbmcuZnJvbUNoYXJDb2RlKDE1NDgpLCB0aGlzLnN5bWJvbHMuZGVjaW1hbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCkgdmFsdWUgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkcmVwbGFjZUFsbCh2YWx1ZSwgXCIuXCIsIHRoaXMuc3ltYm9scy5ncm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZyLUZSIGdyb3VwIGNoYXJhY3RlciBpcyBjaGFyIGNvZGUgODIzOSwgYnV0IHRoYXQncyBub3QgYSBrZXkgb24gdGhlIGZyZW5jaCBrZXlib2FyZCxcclxuICAgICAgICAvLyBzbyBhbGxvdyAncGVyaW9kJyBhcyBhIGdyb3VwIGNoYXIgYW5kIHJlcGxhY2UgaXQgd2l0aCBhIHNwYWNlXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhbGUgPT09IFwiZnItRlJcIikgdmFsdWUgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkcmVwbGFjZUFsbCh2YWx1ZSwgXCIuXCIsIFN0cmluZy5mcm9tQ2hhckNvZGUoODIzOSkpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlzVmFsaWRQYXJ0aWFsTnVtYmVyKHZhbHVlLCBtaW5WYWx1ZSA9IC1JbmZpbml0eSwgbWF4VmFsdWUgPSBJbmZpbml0eSkge1xyXG4gICAgICAgIHZhbHVlID0gdGhpcy5zYW5pdGl6ZSh2YWx1ZSk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG1pbnVzIG9yIHBsdXMgc2lnbiwgd2hpY2ggbXVzdCBiZSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZy5cclxuICAgICAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbiAmJiB2YWx1ZS5zdGFydHNXaXRoKHRoaXMuc3ltYm9scy5taW51c1NpZ24pICYmIG1pblZhbHVlIDwgMCkgdmFsdWUgPSB2YWx1ZS5zbGljZSh0aGlzLnN5bWJvbHMubWludXNTaWduLmxlbmd0aCk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zeW1ib2xzLnBsdXNTaWduICYmIHZhbHVlLnN0YXJ0c1dpdGgodGhpcy5zeW1ib2xzLnBsdXNTaWduKSAmJiBtYXhWYWx1ZSA+IDApIHZhbHVlID0gdmFsdWUuc2xpY2UodGhpcy5zeW1ib2xzLnBsdXNTaWduLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gTnVtYmVycyBjYW5ub3Qgc3RhcnQgd2l0aCBhIGdyb3VwIHNlcGFyYXRvclxyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZ3JvdXAgJiYgdmFsdWUuc3RhcnRzV2l0aCh0aGlzLnN5bWJvbHMuZ3JvdXApKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gTnVtYmVycyB0aGF0IGNhbid0IGhhdmUgYW55IGRlY2ltYWwgdmFsdWVzIGZhaWwgaWYgYSBkZWNpbWFsIGNoYXJhY3RlciBpcyB0eXBlZFxyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCAmJiB2YWx1ZS5pbmRleE9mKHRoaXMuc3ltYm9scy5kZWNpbWFsKSA+IC0xICYmIHRoaXMub3B0aW9ucy5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICAvLyBSZW1vdmUgbnVtZXJhbHMsIGdyb3VwcywgYW5kIGRlY2ltYWxzXHJcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCkgdmFsdWUgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkcmVwbGFjZUFsbCh2YWx1ZSwgdGhpcy5zeW1ib2xzLmdyb3VwLCBcIlwiKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodGhpcy5zeW1ib2xzLm51bWVyYWwsIFwiXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHRoaXMuc3ltYm9scy5kZWNpbWFsLCBcIlwiKTtcclxuICAgICAgICAvLyBUaGUgbnVtYmVyIGlzIHZhbGlkIGlmIHRoZXJlIGFyZSBubyByZW1haW5pbmcgY2hhcmFjdGVyc1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG9wdGlvbnMgPSB7fSl7XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnN5bWJvbHMgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZ2V0U3ltYm9scyhsb2NhbGUsIHRoaXMuZm9ybWF0dGVyLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBfdGhpc19vcHRpb25zX21pbmltdW1GcmFjdGlvbkRpZ2l0cywgX3RoaXNfb3B0aW9uc19tYXhpbXVtRnJhY3Rpb25EaWdpdHM7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gXCJwZXJjZW50XCIgJiYgKCgoX3RoaXNfb3B0aW9uc19taW5pbXVtRnJhY3Rpb25EaWdpdHMgPSB0aGlzLm9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzKSAhPT0gbnVsbCAmJiBfdGhpc19vcHRpb25zX21pbmltdW1GcmFjdGlvbkRpZ2l0cyAhPT0gdm9pZCAwID8gX3RoaXNfb3B0aW9uc19taW5pbXVtRnJhY3Rpb25EaWdpdHMgOiAwKSA+IDE4IHx8ICgoX3RoaXNfb3B0aW9uc19tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSB0aGlzLm9wdGlvbnMubWF4aW11bUZyYWN0aW9uRGlnaXRzKSAhPT0gbnVsbCAmJiBfdGhpc19vcHRpb25zX21heGltdW1GcmFjdGlvbkRpZ2l0cyAhPT0gdm9pZCAwID8gX3RoaXNfb3B0aW9uc19tYXhpbXVtRnJhY3Rpb25EaWdpdHMgOiAwKSA+IDE4KSkgY29uc29sZS53YXJuKFwiTnVtYmVyUGFyc2VyIGNhbm5vdCBoYW5kbGUgcGVyY2VudGFnZXMgd2l0aCBncmVhdGVyIHRoYW4gMTggZGVjaW1hbCBwbGFjZXMsIHBsZWFzZSByZWR1Y2UgdGhlIG51bWJlciBpbiB5b3VyIG9wdGlvbnMuXCIpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRub25MaXRlcmFsUGFydHMgPSBuZXcgU2V0KFtcclxuICAgIFwiZGVjaW1hbFwiLFxyXG4gICAgXCJmcmFjdGlvblwiLFxyXG4gICAgXCJpbnRlZ2VyXCIsXHJcbiAgICBcIm1pbnVzU2lnblwiLFxyXG4gICAgXCJwbHVzU2lnblwiLFxyXG4gICAgXCJncm91cFwiXHJcbl0pO1xyXG4vLyBUaGlzIGxpc3QgaXMgZGVyaXZlZCBmcm9tIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzLzQzL3N1cHBsZW1lbnRhbC9sYW5ndWFnZV9wbHVyYWxfcnVsZXMuaHRtbCNjb21wYXJpc29uIGFuZCBpbmNsdWRlc1xyXG4vLyBhbGwgdW5pcXVlIG51bWJlcnMgd2hpY2ggd2UgbmVlZCB0byBjaGVjayBpbiBvcmRlciB0byBkZXRlcm1pbmUgYWxsIHRoZSBwbHVyYWwgZm9ybXMgZm9yIGEgZ2l2ZW4gbG9jYWxlLlxyXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9wdWxsLzUxMzQvZmlsZXMjcjEzMzcwMzc4NTUgZm9yIHVzZWQgc2NyaXB0XHJcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRwbHVyYWxOdW1iZXJzID0gW1xyXG4gICAgMCxcclxuICAgIDQsXHJcbiAgICAyLFxyXG4gICAgMSxcclxuICAgIDExLFxyXG4gICAgMjAsXHJcbiAgICAzLFxyXG4gICAgNyxcclxuICAgIDEwMCxcclxuICAgIDIxLFxyXG4gICAgMC4xLFxyXG4gICAgMS4xXHJcbl07XHJcbmZ1bmN0aW9uICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXRTeW1ib2xzKGxvY2FsZSwgZm9ybWF0dGVyLCBpbnRsT3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XHJcbiAgICB2YXIgX2FsbFBhcnRzX2ZpbmQsIF9wb3NBbGxQYXJ0c19maW5kLCBfZGVjaW1hbFBhcnRzX2ZpbmQsIF9hbGxQYXJ0c19maW5kMTtcclxuICAgIC8vIGZvcm1hdHRlciBuZWVkcyBhY2Nlc3MgdG8gYWxsIGRlY2ltYWwgcGxhY2VzIGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IGxpdGVyYWwgc3RyaW5ncyBmb3IgdGhlIHBsdXJhbCBzZXRcclxuICAgIGxldCBzeW1ib2xGb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XHJcbiAgICAgICAgLi4uaW50bE9wdGlvbnMsXHJcbiAgICAgICAgbWluaW11bVNpZ25pZmljYW50RGlnaXRzOiAxLFxyXG4gICAgICAgIG1heGltdW1TaWduaWZpY2FudERpZ2l0czogMjFcclxuICAgIH0pO1xyXG4gICAgLy8gTm90ZTogc29tZSBsb2NhbGUncyBkb24ndCBhZGQgYSBncm91cCBzeW1ib2wgdW50aWwgdGhlcmUgaXMgYSB0ZW4gdGhvdXNhbmRzIHBsYWNlXHJcbiAgICBsZXQgYWxsUGFydHMgPSBzeW1ib2xGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cygtMTAwMDAuMTExKTtcclxuICAgIGxldCBwb3NBbGxQYXJ0cyA9IHN5bWJvbEZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKDEwMDAwLjExMSk7XHJcbiAgICBsZXQgcGx1cmFsUGFydHMgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkcGx1cmFsTnVtYmVycy5tYXAoKG4pPT5zeW1ib2xGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuKSk7XHJcbiAgICB2YXIgX2FsbFBhcnRzX2ZpbmRfdmFsdWU7XHJcbiAgICBsZXQgbWludXNTaWduID0gKF9hbGxQYXJ0c19maW5kX3ZhbHVlID0gKF9hbGxQYXJ0c19maW5kID0gYWxsUGFydHMuZmluZCgocCk9PnAudHlwZSA9PT0gXCJtaW51c1NpZ25cIikpID09PSBudWxsIHx8IF9hbGxQYXJ0c19maW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWxsUGFydHNfZmluZC52YWx1ZSkgIT09IG51bGwgJiYgX2FsbFBhcnRzX2ZpbmRfdmFsdWUgIT09IHZvaWQgMCA/IF9hbGxQYXJ0c19maW5kX3ZhbHVlIDogXCItXCI7XHJcbiAgICBsZXQgcGx1c1NpZ24gPSAoX3Bvc0FsbFBhcnRzX2ZpbmQgPSBwb3NBbGxQYXJ0cy5maW5kKChwKT0+cC50eXBlID09PSBcInBsdXNTaWduXCIpKSA9PT0gbnVsbCB8fCBfcG9zQWxsUGFydHNfZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Bvc0FsbFBhcnRzX2ZpbmQudmFsdWU7XHJcbiAgICAvLyBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2lnbkRpc3BsYXkgb3B0aW9uLCBidXQgb3VyIG51bWJlciBwYXJzZXIgcG9seWZpbGxzIGl0LlxyXG4gICAgLy8gSWYgbm8gcGx1cyBzaWduIHdhcyByZXR1cm5lZCwgYnV0IHRoZSBvcmlnaW5hbCBvcHRpb25zIGNvbnRhaW5lZCBzaWduRGlzcGxheSwgZGVmYXVsdCB0byB0aGUgJysnIGNoYXJhY3Rlci5cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGlmICghcGx1c1NpZ24gJiYgKChvcmlnaW5hbE9wdGlvbnMgPT09IG51bGwgfHwgb3JpZ2luYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbE9wdGlvbnMuc2lnbkRpc3BsYXkpID09PSBcImV4Y2VwdFplcm9cIiB8fCAob3JpZ2luYWxPcHRpb25zID09PSBudWxsIHx8IG9yaWdpbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxPcHRpb25zLnNpZ25EaXNwbGF5KSA9PT0gXCJhbHdheXNcIikpIHBsdXNTaWduID0gXCIrXCI7XHJcbiAgICAvLyBJZiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgaXMgMSAodGhlIG1pbmltdW0pIHRoZW4gd2Ugd29uJ3QgZ2V0IGRlY2ltYWwgY2hhcmFjdGVycyBvdXQgb2YgdGhlIGFib3ZlIGZvcm1hdHRlcnNcclxuICAgIC8vIFBlcmNlbnQgYWxzbyBkZWZhdWx0cyB0byAwIGZyYWN0aW9uRGlnaXRzLCBzbyB3ZSBuZWVkIHRvIG1ha2UgYSBuZXcgb25lIHRoYXQgaXNuJ3QgcGVyY2VudCB0byBnZXQgYW4gYWNjdXJhdGUgZGVjaW1hbFxyXG4gICAgbGV0IGRlY2ltYWxQYXJ0cyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcclxuICAgICAgICAuLi5pbnRsT3B0aW9ucyxcclxuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXHJcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyXHJcbiAgICB9KS5mb3JtYXRUb1BhcnRzKDAuMDAxKTtcclxuICAgIGxldCBkZWNpbWFsID0gKF9kZWNpbWFsUGFydHNfZmluZCA9IGRlY2ltYWxQYXJ0cy5maW5kKChwKT0+cC50eXBlID09PSBcImRlY2ltYWxcIikpID09PSBudWxsIHx8IF9kZWNpbWFsUGFydHNfZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlY2ltYWxQYXJ0c19maW5kLnZhbHVlO1xyXG4gICAgbGV0IGdyb3VwID0gKF9hbGxQYXJ0c19maW5kMSA9IGFsbFBhcnRzLmZpbmQoKHApPT5wLnR5cGUgPT09IFwiZ3JvdXBcIikpID09PSBudWxsIHx8IF9hbGxQYXJ0c19maW5kMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FsbFBhcnRzX2ZpbmQxLnZhbHVlO1xyXG4gICAgLy8gdGhpcyBzZXQgaXMgYWxzbyBmb3IgYSByZWdleCwgaXQncyBhbGwgbGl0ZXJhbHMgdGhhdCBtaWdodCBiZSBpbiB0aGUgc3RyaW5nIHdlIHdhbnQgdG8gZXZlbnR1YWxseSBwYXJzZSB0aGF0XHJcbiAgICAvLyBkb24ndCBjb250cmlidXRlIHRvIHRoZSBudW1lcmljYWwgdmFsdWVcclxuICAgIGxldCBhbGxQYXJ0c0xpdGVyYWxzID0gYWxsUGFydHMuZmlsdGVyKChwKT0+ISQ2YzdiZDc4NThkZWVhNjg2JHZhciRub25MaXRlcmFsUGFydHMuaGFzKHAudHlwZSkpLm1hcCgocCk9PiQ2YzdiZDc4NThkZWVhNjg2JHZhciRlc2NhcGVSZWdleChwLnZhbHVlKSk7XHJcbiAgICBsZXQgcGx1cmFsUGFydHNMaXRlcmFscyA9IHBsdXJhbFBhcnRzLmZsYXRNYXAoKHApPT5wLmZpbHRlcigocCk9PiEkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkbm9uTGl0ZXJhbFBhcnRzLmhhcyhwLnR5cGUpKS5tYXAoKHApPT4kNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZXNjYXBlUmVnZXgocC52YWx1ZSkpKTtcclxuICAgIGxldCBzb3J0ZWRMaXRlcmFscyA9IFtcclxuICAgICAgICAuLi5uZXcgU2V0KFtcclxuICAgICAgICAgICAgLi4uYWxsUGFydHNMaXRlcmFscyxcclxuICAgICAgICAgICAgLi4ucGx1cmFsUGFydHNMaXRlcmFsc1xyXG4gICAgICAgIF0pXHJcbiAgICBdLnNvcnQoKGEsIGIpPT5iLmxlbmd0aCAtIGEubGVuZ3RoKTtcclxuICAgIGxldCBsaXRlcmFscyA9IHNvcnRlZExpdGVyYWxzLmxlbmd0aCA9PT0gMCA/IG5ldyBSZWdFeHAoXCJbXFxcXHB7V2hpdGVfU3BhY2V9XVwiLCBcImd1XCIpIDogbmV3IFJlZ0V4cChgJHtzb3J0ZWRMaXRlcmFscy5qb2luKFwifFwiKX18W1xcXFxwe1doaXRlX1NwYWNlfV1gLCBcImd1XCIpO1xyXG4gICAgLy8gVGhlc2UgYXJlIGZvciByZXBsYWNpbmcgbm9uLWxhdG4gY2hhcmFjdGVycyB3aXRoIHRoZSBsYXRuIGVxdWl2YWxlbnRcclxuICAgIGxldCBudW1lcmFscyA9IFtcclxuICAgICAgICAuLi5uZXcgSW50bC5OdW1iZXJGb3JtYXQoaW50bE9wdGlvbnMubG9jYWxlLCB7XHJcbiAgICAgICAgICAgIHVzZUdyb3VwaW5nOiBmYWxzZVxyXG4gICAgICAgIH0pLmZvcm1hdCg5ODc2NTQzMjEwKVxyXG4gICAgXS5yZXZlcnNlKCk7XHJcbiAgICBsZXQgaW5kZXhlcyA9IG5ldyBNYXAobnVtZXJhbHMubWFwKChkLCBpKT0+W1xyXG4gICAgICAgICAgICBkLFxyXG4gICAgICAgICAgICBpXHJcbiAgICAgICAgXSkpO1xyXG4gICAgbGV0IG51bWVyYWwgPSBuZXcgUmVnRXhwKGBbJHtudW1lcmFscy5qb2luKFwiXCIpfV1gLCBcImdcIik7XHJcbiAgICBsZXQgaW5kZXggPSAoZCk9PlN0cmluZyhpbmRleGVzLmdldChkKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pbnVzU2lnbjogbWludXNTaWduLFxyXG4gICAgICAgIHBsdXNTaWduOiBwbHVzU2lnbixcclxuICAgICAgICBkZWNpbWFsOiBkZWNpbWFsLFxyXG4gICAgICAgIGdyb3VwOiBncm91cCxcclxuICAgICAgICBsaXRlcmFsczogbGl0ZXJhbHMsXHJcbiAgICAgICAgbnVtZXJhbDogbnVtZXJhbCxcclxuICAgICAgICBpbmRleDogaW5kZXhcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAoc3RyLnJlcGxhY2VBbGwpIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBzdHIucmVwbGFjZUFsbChmaW5kLCByZXBsYWNlKTtcclxuICAgIHJldHVybiBzdHIuc3BsaXQoZmluZCkuam9pbihyZXBsYWNlKTtcclxufVxyXG5mdW5jdGlvbiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZXNjYXBlUmVnZXgoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHskNDg4YzZkZGJmNGVmNzRjMiRleHBvcnQkY2M3N2M0ZmY3ZTg2NzNjNSBhcyBOdW1iZXJGb3JtYXR0ZXIsICQ2YzdiZDc4NThkZWVhNjg2JGV4cG9ydCRjZDExYWIxNDA4MzlmMTFkIGFzIE51bWJlclBhcnNlcn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/number/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@internationalized/string/dist/import.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@internationalized/string/dist/import.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalizedStringDictionary: () => (/* binding */ $5b160d28a433310d$export$c17fa47878dc55b6),\n/* harmony export */   LocalizedStringFormatter: () => (/* binding */ $6db58dc88e78b024$export$2f817fcdc4b89ae0)\n/* harmony export */ });\n/*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ /*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $5b160d28a433310d$var$localeSymbol = Symbol.for(\"react-aria.i18n.locale\");\r\nconst $5b160d28a433310d$var$stringsSymbol = Symbol.for(\"react-aria.i18n.strings\");\r\nlet $5b160d28a433310d$var$cachedGlobalStrings = undefined;\r\nclass $5b160d28a433310d$export$c17fa47878dc55b6 {\r\n    /** Returns a localized string for the given key and locale. */ getStringForLocale(key, locale) {\r\n        let strings = this.getStringsForLocale(locale);\r\n        let string = strings[key];\r\n        if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);\r\n        return string;\r\n    }\r\n    /** Returns all localized strings for the given locale. */ getStringsForLocale(locale) {\r\n        let strings = this.strings[locale];\r\n        if (!strings) {\r\n            strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);\r\n            this.strings[locale] = strings;\r\n        }\r\n        return strings;\r\n    }\r\n    static getGlobalDictionaryForPackage(packageName) {\r\n        if (typeof window === \"undefined\") return null;\r\n        let locale = window[$5b160d28a433310d$var$localeSymbol];\r\n        if ($5b160d28a433310d$var$cachedGlobalStrings === undefined) {\r\n            let globalStrings = window[$5b160d28a433310d$var$stringsSymbol];\r\n            if (!globalStrings) return null;\r\n            $5b160d28a433310d$var$cachedGlobalStrings = {};\r\n            for(let pkg in globalStrings)$5b160d28a433310d$var$cachedGlobalStrings[pkg] = new $5b160d28a433310d$export$c17fa47878dc55b6({\r\n                [locale]: globalStrings[pkg]\r\n            }, locale);\r\n        }\r\n        let dictionary = $5b160d28a433310d$var$cachedGlobalStrings === null || $5b160d28a433310d$var$cachedGlobalStrings === void 0 ? void 0 : $5b160d28a433310d$var$cachedGlobalStrings[packageName];\r\n        if (!dictionary) throw new Error(`Strings for package \"${packageName}\" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);\r\n        return dictionary;\r\n    }\r\n    constructor(messages, defaultLocale = \"en-US\"){\r\n        // Clone messages so we don't modify the original object.\r\n        this.strings = {\r\n            ...messages\r\n        };\r\n        this.defaultLocale = defaultLocale;\r\n    }\r\n}\r\nfunction $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = \"en-US\") {\r\n    // If there is an exact match, use it.\r\n    if (strings[locale]) return strings[locale];\r\n    // Attempt to find the closest match by language.\r\n    // For example, if the locale is fr-CA (French Canadian), but there is only\r\n    // an fr-FR (France) set of strings, use that.\r\n    // This could be replaced with Intl.LocaleMatcher once it is supported.\r\n    // https://github.com/tc39/proposal-intl-localematcher\r\n    let language = $5b160d28a433310d$var$getLanguage(locale);\r\n    if (strings[language]) return strings[language];\r\n    for(let key in strings){\r\n        if (key.startsWith(language + \"-\")) return strings[key];\r\n    }\r\n    // Nothing close, use english.\r\n    return strings[defaultLocale];\r\n}\r\nfunction $5b160d28a433310d$var$getLanguage(locale) {\r\n    // @ts-ignore\r\n    if (Intl.Locale) // @ts-ignore\r\n    return new Intl.Locale(locale).language;\r\n    return locale.split(\"-\")[0];\r\n}\r\n\r\n\r\n/*\r\n * Copyright 2022 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ const $6db58dc88e78b024$var$pluralRulesCache = new Map();\r\nconst $6db58dc88e78b024$var$numberFormatCache = new Map();\r\nclass $6db58dc88e78b024$export$2f817fcdc4b89ae0 {\r\n    /** Formats a localized string for the given key with the provided variables. */ format(key, variables) {\r\n        let message = this.strings.getStringForLocale(key, this.locale);\r\n        return typeof message === \"function\" ? message(variables, this) : message;\r\n    }\r\n    plural(count, options, type = \"cardinal\") {\r\n        let opt = options[\"=\" + count];\r\n        if (opt) return typeof opt === \"function\" ? opt() : opt;\r\n        let key = this.locale + \":\" + type;\r\n        let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);\r\n        if (!pluralRules) {\r\n            pluralRules = new Intl.PluralRules(this.locale, {\r\n                type: type\r\n            });\r\n            $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);\r\n        }\r\n        let selected = pluralRules.select(count);\r\n        opt = options[selected] || options.other;\r\n        return typeof opt === \"function\" ? opt() : opt;\r\n    }\r\n    number(value) {\r\n        let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);\r\n        if (!numberFormat) {\r\n            numberFormat = new Intl.NumberFormat(this.locale);\r\n            $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);\r\n        }\r\n        return numberFormat.format(value);\r\n    }\r\n    select(options, value) {\r\n        let opt = options[value] || options.other;\r\n        return typeof opt === \"function\" ? opt() : opt;\r\n    }\r\n    constructor(locale, strings){\r\n        this.locale = locale;\r\n        this.strings = strings;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=module.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL3N0cmluZy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSyxLQUFLLFFBQVE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VKO0FBQ3ZKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnV0cmktc21hcnQvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL3N0cmluZy9kaXN0L2ltcG9ydC5tanM/ZjQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyAvKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxyXG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcclxuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqLyBjb25zdCAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkbG9jYWxlU3ltYm9sID0gU3ltYm9sLmZvcihcInJlYWN0LWFyaWEuaTE4bi5sb2NhbGVcIik7XHJcbmNvbnN0ICQ1YjE2MGQyOGE0MzMzMTBkJHZhciRzdHJpbmdzU3ltYm9sID0gU3ltYm9sLmZvcihcInJlYWN0LWFyaWEuaTE4bi5zdHJpbmdzXCIpO1xyXG5sZXQgJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPSB1bmRlZmluZWQ7XHJcbmNsYXNzICQ1YjE2MGQyOGE0MzMzMTBkJGV4cG9ydCRjMTdmYTQ3ODc4ZGM1NWI2IHtcclxuICAgIC8qKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyBmb3IgdGhlIGdpdmVuIGtleSBhbmQgbG9jYWxlLiAqLyBnZXRTdHJpbmdGb3JMb2NhbGUoa2V5LCBsb2NhbGUpIHtcclxuICAgICAgICBsZXQgc3RyaW5ncyA9IHRoaXMuZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUpO1xyXG4gICAgICAgIGxldCBzdHJpbmcgPSBzdHJpbmdzW2tleV07XHJcbiAgICAgICAgaWYgKCFzdHJpbmcpIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgaW50bCBtZXNzYWdlICR7a2V5fSBpbiAke2xvY2FsZX0gbG9jYWxlYCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGFsbCBsb2NhbGl6ZWQgc3RyaW5ncyBmb3IgdGhlIGdpdmVuIGxvY2FsZS4gKi8gZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUpIHtcclxuICAgICAgICBsZXQgc3RyaW5ncyA9IHRoaXMuc3RyaW5nc1tsb2NhbGVdO1xyXG4gICAgICAgIGlmICghc3RyaW5ncykge1xyXG4gICAgICAgICAgICBzdHJpbmdzID0gJDViMTYwZDI4YTQzMzMxMGQkdmFyJGdldFN0cmluZ3NGb3JMb2NhbGUobG9jYWxlLCB0aGlzLnN0cmluZ3MsIHRoaXMuZGVmYXVsdExvY2FsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nc1tsb2NhbGVdID0gc3RyaW5ncztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0R2xvYmFsRGljdGlvbmFyeUZvclBhY2thZ2UocGFja2FnZU5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgbGV0IGxvY2FsZSA9IHdpbmRvd1skNWIxNjBkMjhhNDMzMzEwZCR2YXIkbG9jYWxlU3ltYm9sXTtcclxuICAgICAgICBpZiAoJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXQgZ2xvYmFsU3RyaW5ncyA9IHdpbmRvd1skNWIxNjBkMjhhNDMzMzEwZCR2YXIkc3RyaW5nc1N5bWJvbF07XHJcbiAgICAgICAgICAgIGlmICghZ2xvYmFsU3RyaW5ncykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICQ1YjE2MGQyOGE0MzMzMTBkJHZhciRjYWNoZWRHbG9iYWxTdHJpbmdzID0ge307XHJcbiAgICAgICAgICAgIGZvcihsZXQgcGtnIGluIGdsb2JhbFN0cmluZ3MpJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3NbcGtnXSA9IG5ldyAkNWIxNjBkMjhhNDMzMzEwZCRleHBvcnQkYzE3ZmE0Nzg3OGRjNTViNih7XHJcbiAgICAgICAgICAgICAgICBbbG9jYWxlXTogZ2xvYmFsU3RyaW5nc1twa2ddXHJcbiAgICAgICAgICAgIH0sIGxvY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkaWN0aW9uYXJ5ID0gJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPT09IG51bGwgfHwgJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6ICQ1YjE2MGQyOGE0MzMzMTBkJHZhciRjYWNoZWRHbG9iYWxTdHJpbmdzW3BhY2thZ2VOYW1lXTtcclxuICAgICAgICBpZiAoIWRpY3Rpb25hcnkpIHRocm93IG5ldyBFcnJvcihgU3RyaW5ncyBmb3IgcGFja2FnZSBcIiR7cGFja2FnZU5hbWV9XCIgd2VyZSBub3QgaW5jbHVkZWQgYnkgTG9jYWxpemVkU3RyaW5nUHJvdmlkZXIuIFBsZWFzZSBhZGQgaXQgdG8gdGhlIGxpc3QgcGFzc2VkIHRvIGNyZWF0ZUxvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnkuYCk7XHJcbiAgICAgICAgcmV0dXJuIGRpY3Rpb25hcnk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlcywgZGVmYXVsdExvY2FsZSA9IFwiZW4tVVNcIil7XHJcbiAgICAgICAgLy8gQ2xvbmUgbWVzc2FnZXMgc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgICAgdGhpcy5zdHJpbmdzID0ge1xyXG4gICAgICAgICAgICAuLi5tZXNzYWdlc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUsIHN0cmluZ3MsIGRlZmF1bHRMb2NhbGUgPSBcImVuLVVTXCIpIHtcclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4YWN0IG1hdGNoLCB1c2UgaXQuXHJcbiAgICBpZiAoc3RyaW5nc1tsb2NhbGVdKSByZXR1cm4gc3RyaW5nc1tsb2NhbGVdO1xyXG4gICAgLy8gQXR0ZW1wdCB0byBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoIGJ5IGxhbmd1YWdlLlxyXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBsb2NhbGUgaXMgZnItQ0EgKEZyZW5jaCBDYW5hZGlhbiksIGJ1dCB0aGVyZSBpcyBvbmx5XHJcbiAgICAvLyBhbiBmci1GUiAoRnJhbmNlKSBzZXQgb2Ygc3RyaW5ncywgdXNlIHRoYXQuXHJcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHJlcGxhY2VkIHdpdGggSW50bC5Mb2NhbGVNYXRjaGVyIG9uY2UgaXQgaXMgc3VwcG9ydGVkLlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaW50bC1sb2NhbGVtYXRjaGVyXHJcbiAgICBsZXQgbGFuZ3VhZ2UgPSAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkZ2V0TGFuZ3VhZ2UobG9jYWxlKTtcclxuICAgIGlmIChzdHJpbmdzW2xhbmd1YWdlXSkgcmV0dXJuIHN0cmluZ3NbbGFuZ3VhZ2VdO1xyXG4gICAgZm9yKGxldCBrZXkgaW4gc3RyaW5ncyl7XHJcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGxhbmd1YWdlICsgXCItXCIpKSByZXR1cm4gc3RyaW5nc1trZXldO1xyXG4gICAgfVxyXG4gICAgLy8gTm90aGluZyBjbG9zZSwgdXNlIGVuZ2xpc2guXHJcbiAgICByZXR1cm4gc3RyaW5nc1tkZWZhdWx0TG9jYWxlXTtcclxufVxyXG5mdW5jdGlvbiAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkZ2V0TGFuZ3VhZ2UobG9jYWxlKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAoSW50bC5Mb2NhbGUpIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBuZXcgSW50bC5Mb2NhbGUobG9jYWxlKS5sYW5ndWFnZTtcclxuICAgIHJldHVybiBsb2NhbGUuc3BsaXQoXCItXCIpWzBdO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcclxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXHJcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxyXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi8gY29uc3QgJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJHBsdXJhbFJ1bGVzQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbmNvbnN0ICQ2ZGI1OGRjODhlNzhiMDI0JHZhciRudW1iZXJGb3JtYXRDYWNoZSA9IG5ldyBNYXAoKTtcclxuY2xhc3MgJDZkYjU4ZGM4OGU3OGIwMjQkZXhwb3J0JDJmODE3ZmNkYzRiODlhZTAge1xyXG4gICAgLyoqIEZvcm1hdHMgYSBsb2NhbGl6ZWQgc3RyaW5nIGZvciB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlIHByb3ZpZGVkIHZhcmlhYmxlcy4gKi8gZm9ybWF0KGtleSwgdmFyaWFibGVzKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLnN0cmluZ3MuZ2V0U3RyaW5nRm9yTG9jYWxlKGtleSwgdGhpcy5sb2NhbGUpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZSh2YXJpYWJsZXMsIHRoaXMpIDogbWVzc2FnZTtcclxuICAgIH1cclxuICAgIHBsdXJhbChjb3VudCwgb3B0aW9ucywgdHlwZSA9IFwiY2FyZGluYWxcIikge1xyXG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW1wiPVwiICsgY291bnRdO1xyXG4gICAgICAgIGlmIChvcHQpIHJldHVybiB0eXBlb2Ygb3B0ID09PSBcImZ1bmN0aW9uXCIgPyBvcHQoKSA6IG9wdDtcclxuICAgICAgICBsZXQga2V5ID0gdGhpcy5sb2NhbGUgKyBcIjpcIiArIHR5cGU7XHJcbiAgICAgICAgbGV0IHBsdXJhbFJ1bGVzID0gJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJHBsdXJhbFJ1bGVzQ2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFwbHVyYWxSdWxlcykge1xyXG4gICAgICAgICAgICBwbHVyYWxSdWxlcyA9IG5ldyBJbnRsLlBsdXJhbFJ1bGVzKHRoaXMubG9jYWxlLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkNmRiNThkYzg4ZTc4YjAyNCR2YXIkcGx1cmFsUnVsZXNDYWNoZS5zZXQoa2V5LCBwbHVyYWxSdWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHBsdXJhbFJ1bGVzLnNlbGVjdChjb3VudCk7XHJcbiAgICAgICAgb3B0ID0gb3B0aW9uc1tzZWxlY3RlZF0gfHwgb3B0aW9ucy5vdGhlcjtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9wdCA9PT0gXCJmdW5jdGlvblwiID8gb3B0KCkgOiBvcHQ7XHJcbiAgICB9XHJcbiAgICBudW1iZXIodmFsdWUpIHtcclxuICAgICAgICBsZXQgbnVtYmVyRm9ybWF0ID0gJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJG51bWJlckZvcm1hdENhY2hlLmdldCh0aGlzLmxvY2FsZSk7XHJcbiAgICAgICAgaWYgKCFudW1iZXJGb3JtYXQpIHtcclxuICAgICAgICAgICAgbnVtYmVyRm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlKTtcclxuICAgICAgICAgICAgJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJG51bWJlckZvcm1hdENhY2hlLnNldCh0aGlzLmxvY2FsZSwgbnVtYmVyRm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bWJlckZvcm1hdC5mb3JtYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgc2VsZWN0KG9wdGlvbnMsIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNbdmFsdWVdIHx8IG9wdGlvbnMub3RoZXI7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHQgPT09IFwiZnVuY3Rpb25cIiA/IG9wdCgpIDogb3B0O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBzdHJpbmdzKXtcclxuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcclxuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgeyQ1YjE2MGQyOGE0MzMzMTBkJGV4cG9ydCRjMTdmYTQ3ODc4ZGM1NWI2IGFzIExvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnksICQ2ZGI1OGRjODhlNzhiMDI0JGV4cG9ydCQyZjgxN2ZjZGM0Yjg5YWUwIGFzIExvY2FsaXplZFN0cmluZ0Zvcm1hdHRlcn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/string/dist/import.mjs\n");

/***/ })

};
;